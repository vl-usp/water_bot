// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/vl-usp/water_bot/pkg/client/cache.Client -o client_minimock.go -n ClientMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientMock implements mm_cache.Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDel          func(ctx context.Context, keys ...string) (err error)
	funcDelOrigin    string
	inspectFuncDel   func(ctx context.Context, keys ...string)
	afterDelCounter  uint64
	beforeDelCounter uint64
	DelMock          mClientMockDel

	funcExists          func(ctx context.Context, key string) (b1 bool, err error)
	funcExistsOrigin    string
	inspectFuncExists   func(ctx context.Context, key string)
	afterExistsCounter  uint64
	beforeExistsCounter uint64
	ExistsMock          mClientMockExists

	funcExpire          func(ctx context.Context, key string, expiration time.Duration) (err error)
	funcExpireOrigin    string
	inspectFuncExpire   func(ctx context.Context, key string, expiration time.Duration)
	afterExpireCounter  uint64
	beforeExpireCounter uint64
	ExpireMock          mClientMockExpire

	funcGet          func(ctx context.Context, key string) (s1 string, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, key string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mClientMockGet

	funcHGetAll          func(ctx context.Context, key string) (m1 map[string]string, err error)
	funcHGetAllOrigin    string
	inspectFuncHGetAll   func(ctx context.Context, key string)
	afterHGetAllCounter  uint64
	beforeHGetAllCounter uint64
	HGetAllMock          mClientMockHGetAll

	funcHSet          func(ctx context.Context, key string, values interface{}) (err error)
	funcHSetOrigin    string
	inspectFuncHSet   func(ctx context.Context, key string, values interface{})
	afterHSetCounter  uint64
	beforeHSetCounter uint64
	HSetMock          mClientMockHSet

	funcHSetField          func(ctx context.Context, key string, field string, value interface{}) (err error)
	funcHSetFieldOrigin    string
	inspectFuncHSetField   func(ctx context.Context, key string, field string, value interface{})
	afterHSetFieldCounter  uint64
	beforeHSetFieldCounter uint64
	HSetFieldMock          mClientMockHSetField

	funcPing          func(ctx context.Context) (err error)
	funcPingOrigin    string
	inspectFuncPing   func(ctx context.Context)
	afterPingCounter  uint64
	beforePingCounter uint64
	PingMock          mClientMockPing

	funcSet          func(ctx context.Context, key string, value interface{}) (err error)
	funcSetOrigin    string
	inspectFuncSet   func(ctx context.Context, key string, value interface{})
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mClientMockSet
}

// NewClientMock returns a mock for mm_cache.Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DelMock = mClientMockDel{mock: m}
	m.DelMock.callArgs = []*ClientMockDelParams{}

	m.ExistsMock = mClientMockExists{mock: m}
	m.ExistsMock.callArgs = []*ClientMockExistsParams{}

	m.ExpireMock = mClientMockExpire{mock: m}
	m.ExpireMock.callArgs = []*ClientMockExpireParams{}

	m.GetMock = mClientMockGet{mock: m}
	m.GetMock.callArgs = []*ClientMockGetParams{}

	m.HGetAllMock = mClientMockHGetAll{mock: m}
	m.HGetAllMock.callArgs = []*ClientMockHGetAllParams{}

	m.HSetMock = mClientMockHSet{mock: m}
	m.HSetMock.callArgs = []*ClientMockHSetParams{}

	m.HSetFieldMock = mClientMockHSetField{mock: m}
	m.HSetFieldMock.callArgs = []*ClientMockHSetFieldParams{}

	m.PingMock = mClientMockPing{mock: m}
	m.PingMock.callArgs = []*ClientMockPingParams{}

	m.SetMock = mClientMockSet{mock: m}
	m.SetMock.callArgs = []*ClientMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockDel struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDelExpectation
	expectations       []*ClientMockDelExpectation

	callArgs []*ClientMockDelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockDelExpectation specifies expectation struct of the Client.Del
type ClientMockDelExpectation struct {
	mock               *ClientMock
	params             *ClientMockDelParams
	paramPtrs          *ClientMockDelParamPtrs
	expectationOrigins ClientMockDelExpectationOrigins
	results            *ClientMockDelResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockDelParams contains parameters of the Client.Del
type ClientMockDelParams struct {
	ctx  context.Context
	keys []string
}

// ClientMockDelParamPtrs contains pointers to parameters of the Client.Del
type ClientMockDelParamPtrs struct {
	ctx  *context.Context
	keys *[]string
}

// ClientMockDelResults contains results of the Client.Del
type ClientMockDelResults struct {
	err error
}

// ClientMockDelOrigins contains origins of expectations of the Client.Del
type ClientMockDelExpectationOrigins struct {
	origin     string
	originCtx  string
	originKeys string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDel *mClientMockDel) Optional() *mClientMockDel {
	mmDel.optional = true
	return mmDel
}

// Expect sets up expected params for Client.Del
func (mmDel *mClientMockDel) Expect(ctx context.Context, keys ...string) *mClientMockDel {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("ClientMock.Del mock is already set by Set")
	}

	if mmDel.defaultExpectation == nil {
		mmDel.defaultExpectation = &ClientMockDelExpectation{}
	}

	if mmDel.defaultExpectation.paramPtrs != nil {
		mmDel.mock.t.Fatalf("ClientMock.Del mock is already set by ExpectParams functions")
	}

	mmDel.defaultExpectation.params = &ClientMockDelParams{ctx, keys}
	mmDel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDel.expectations {
		if minimock.Equal(e.params, mmDel.defaultExpectation.params) {
			mmDel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDel.defaultExpectation.params)
		}
	}

	return mmDel
}

// ExpectCtxParam1 sets up expected param ctx for Client.Del
func (mmDel *mClientMockDel) ExpectCtxParam1(ctx context.Context) *mClientMockDel {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("ClientMock.Del mock is already set by Set")
	}

	if mmDel.defaultExpectation == nil {
		mmDel.defaultExpectation = &ClientMockDelExpectation{}
	}

	if mmDel.defaultExpectation.params != nil {
		mmDel.mock.t.Fatalf("ClientMock.Del mock is already set by Expect")
	}

	if mmDel.defaultExpectation.paramPtrs == nil {
		mmDel.defaultExpectation.paramPtrs = &ClientMockDelParamPtrs{}
	}
	mmDel.defaultExpectation.paramPtrs.ctx = &ctx
	mmDel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDel
}

// ExpectKeysParam2 sets up expected param keys for Client.Del
func (mmDel *mClientMockDel) ExpectKeysParam2(keys ...string) *mClientMockDel {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("ClientMock.Del mock is already set by Set")
	}

	if mmDel.defaultExpectation == nil {
		mmDel.defaultExpectation = &ClientMockDelExpectation{}
	}

	if mmDel.defaultExpectation.params != nil {
		mmDel.mock.t.Fatalf("ClientMock.Del mock is already set by Expect")
	}

	if mmDel.defaultExpectation.paramPtrs == nil {
		mmDel.defaultExpectation.paramPtrs = &ClientMockDelParamPtrs{}
	}
	mmDel.defaultExpectation.paramPtrs.keys = &keys
	mmDel.defaultExpectation.expectationOrigins.originKeys = minimock.CallerInfo(1)

	return mmDel
}

// Inspect accepts an inspector function that has same arguments as the Client.Del
func (mmDel *mClientMockDel) Inspect(f func(ctx context.Context, keys ...string)) *mClientMockDel {
	if mmDel.mock.inspectFuncDel != nil {
		mmDel.mock.t.Fatalf("Inspect function is already set for ClientMock.Del")
	}

	mmDel.mock.inspectFuncDel = f

	return mmDel
}

// Return sets up results that will be returned by Client.Del
func (mmDel *mClientMockDel) Return(err error) *ClientMock {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("ClientMock.Del mock is already set by Set")
	}

	if mmDel.defaultExpectation == nil {
		mmDel.defaultExpectation = &ClientMockDelExpectation{mock: mmDel.mock}
	}
	mmDel.defaultExpectation.results = &ClientMockDelResults{err}
	mmDel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDel.mock
}

// Set uses given function f to mock the Client.Del method
func (mmDel *mClientMockDel) Set(f func(ctx context.Context, keys ...string) (err error)) *ClientMock {
	if mmDel.defaultExpectation != nil {
		mmDel.mock.t.Fatalf("Default expectation is already set for the Client.Del method")
	}

	if len(mmDel.expectations) > 0 {
		mmDel.mock.t.Fatalf("Some expectations are already set for the Client.Del method")
	}

	mmDel.mock.funcDel = f
	mmDel.mock.funcDelOrigin = minimock.CallerInfo(1)
	return mmDel.mock
}

// When sets expectation for the Client.Del which will trigger the result defined by the following
// Then helper
func (mmDel *mClientMockDel) When(ctx context.Context, keys ...string) *ClientMockDelExpectation {
	if mmDel.mock.funcDel != nil {
		mmDel.mock.t.Fatalf("ClientMock.Del mock is already set by Set")
	}

	expectation := &ClientMockDelExpectation{
		mock:               mmDel.mock,
		params:             &ClientMockDelParams{ctx, keys},
		expectationOrigins: ClientMockDelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDel.expectations = append(mmDel.expectations, expectation)
	return expectation
}

// Then sets up Client.Del return parameters for the expectation previously defined by the When method
func (e *ClientMockDelExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDelResults{err}
	return e.mock
}

// Times sets number of times Client.Del should be invoked
func (mmDel *mClientMockDel) Times(n uint64) *mClientMockDel {
	if n == 0 {
		mmDel.mock.t.Fatalf("Times of ClientMock.Del mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDel.expectedInvocations, n)
	mmDel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDel
}

func (mmDel *mClientMockDel) invocationsDone() bool {
	if len(mmDel.expectations) == 0 && mmDel.defaultExpectation == nil && mmDel.mock.funcDel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDel.mock.afterDelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Del implements mm_cache.Client
func (mmDel *ClientMock) Del(ctx context.Context, keys ...string) (err error) {
	mm_atomic.AddUint64(&mmDel.beforeDelCounter, 1)
	defer mm_atomic.AddUint64(&mmDel.afterDelCounter, 1)

	mmDel.t.Helper()

	if mmDel.inspectFuncDel != nil {
		mmDel.inspectFuncDel(ctx, keys...)
	}

	mm_params := ClientMockDelParams{ctx, keys}

	// Record call args
	mmDel.DelMock.mutex.Lock()
	mmDel.DelMock.callArgs = append(mmDel.DelMock.callArgs, &mm_params)
	mmDel.DelMock.mutex.Unlock()

	for _, e := range mmDel.DelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDel.DelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDel.DelMock.defaultExpectation.Counter, 1)
		mm_want := mmDel.DelMock.defaultExpectation.params
		mm_want_ptrs := mmDel.DelMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDelParams{ctx, keys}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDel.t.Errorf("ClientMock.Del got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDel.DelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.keys != nil && !minimock.Equal(*mm_want_ptrs.keys, mm_got.keys) {
				mmDel.t.Errorf("ClientMock.Del got unexpected parameter keys, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDel.DelMock.defaultExpectation.expectationOrigins.originKeys, *mm_want_ptrs.keys, mm_got.keys, minimock.Diff(*mm_want_ptrs.keys, mm_got.keys))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDel.t.Errorf("ClientMock.Del got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDel.DelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDel.DelMock.defaultExpectation.results
		if mm_results == nil {
			mmDel.t.Fatal("No results are set for the ClientMock.Del")
		}
		return (*mm_results).err
	}
	if mmDel.funcDel != nil {
		return mmDel.funcDel(ctx, keys...)
	}
	mmDel.t.Fatalf("Unexpected call to ClientMock.Del. %v %v", ctx, keys)
	return
}

// DelAfterCounter returns a count of finished ClientMock.Del invocations
func (mmDel *ClientMock) DelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDel.afterDelCounter)
}

// DelBeforeCounter returns a count of ClientMock.Del invocations
func (mmDel *ClientMock) DelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDel.beforeDelCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Del.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDel *mClientMockDel) Calls() []*ClientMockDelParams {
	mmDel.mutex.RLock()

	argCopy := make([]*ClientMockDelParams, len(mmDel.callArgs))
	copy(argCopy, mmDel.callArgs)

	mmDel.mutex.RUnlock()

	return argCopy
}

// MinimockDelDone returns true if the count of the Del invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDelDone() bool {
	if m.DelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DelMock.invocationsDone()
}

// MinimockDelInspect logs each unmet expectation
func (m *ClientMock) MinimockDelInspect() {
	for _, e := range m.DelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Del at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDelCounter := mm_atomic.LoadUint64(&m.afterDelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DelMock.defaultExpectation != nil && afterDelCounter < 1 {
		if m.DelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Del at\n%s", m.DelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Del at\n%s with params: %#v", m.DelMock.defaultExpectation.expectationOrigins.origin, *m.DelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDel != nil && afterDelCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Del at\n%s", m.funcDelOrigin)
	}

	if !m.DelMock.invocationsDone() && afterDelCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Del at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DelMock.expectedInvocations), m.DelMock.expectedInvocationsOrigin, afterDelCounter)
	}
}

type mClientMockExists struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockExistsExpectation
	expectations       []*ClientMockExistsExpectation

	callArgs []*ClientMockExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockExistsExpectation specifies expectation struct of the Client.Exists
type ClientMockExistsExpectation struct {
	mock               *ClientMock
	params             *ClientMockExistsParams
	paramPtrs          *ClientMockExistsParamPtrs
	expectationOrigins ClientMockExistsExpectationOrigins
	results            *ClientMockExistsResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockExistsParams contains parameters of the Client.Exists
type ClientMockExistsParams struct {
	ctx context.Context
	key string
}

// ClientMockExistsParamPtrs contains pointers to parameters of the Client.Exists
type ClientMockExistsParamPtrs struct {
	ctx *context.Context
	key *string
}

// ClientMockExistsResults contains results of the Client.Exists
type ClientMockExistsResults struct {
	b1  bool
	err error
}

// ClientMockExistsOrigins contains origins of expectations of the Client.Exists
type ClientMockExistsExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExists *mClientMockExists) Optional() *mClientMockExists {
	mmExists.optional = true
	return mmExists
}

// Expect sets up expected params for Client.Exists
func (mmExists *mClientMockExists) Expect(ctx context.Context, key string) *mClientMockExists {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("ClientMock.Exists mock is already set by Set")
	}

	if mmExists.defaultExpectation == nil {
		mmExists.defaultExpectation = &ClientMockExistsExpectation{}
	}

	if mmExists.defaultExpectation.paramPtrs != nil {
		mmExists.mock.t.Fatalf("ClientMock.Exists mock is already set by ExpectParams functions")
	}

	mmExists.defaultExpectation.params = &ClientMockExistsParams{ctx, key}
	mmExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExists.expectations {
		if minimock.Equal(e.params, mmExists.defaultExpectation.params) {
			mmExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExists.defaultExpectation.params)
		}
	}

	return mmExists
}

// ExpectCtxParam1 sets up expected param ctx for Client.Exists
func (mmExists *mClientMockExists) ExpectCtxParam1(ctx context.Context) *mClientMockExists {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("ClientMock.Exists mock is already set by Set")
	}

	if mmExists.defaultExpectation == nil {
		mmExists.defaultExpectation = &ClientMockExistsExpectation{}
	}

	if mmExists.defaultExpectation.params != nil {
		mmExists.mock.t.Fatalf("ClientMock.Exists mock is already set by Expect")
	}

	if mmExists.defaultExpectation.paramPtrs == nil {
		mmExists.defaultExpectation.paramPtrs = &ClientMockExistsParamPtrs{}
	}
	mmExists.defaultExpectation.paramPtrs.ctx = &ctx
	mmExists.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExists
}

// ExpectKeyParam2 sets up expected param key for Client.Exists
func (mmExists *mClientMockExists) ExpectKeyParam2(key string) *mClientMockExists {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("ClientMock.Exists mock is already set by Set")
	}

	if mmExists.defaultExpectation == nil {
		mmExists.defaultExpectation = &ClientMockExistsExpectation{}
	}

	if mmExists.defaultExpectation.params != nil {
		mmExists.mock.t.Fatalf("ClientMock.Exists mock is already set by Expect")
	}

	if mmExists.defaultExpectation.paramPtrs == nil {
		mmExists.defaultExpectation.paramPtrs = &ClientMockExistsParamPtrs{}
	}
	mmExists.defaultExpectation.paramPtrs.key = &key
	mmExists.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmExists
}

// Inspect accepts an inspector function that has same arguments as the Client.Exists
func (mmExists *mClientMockExists) Inspect(f func(ctx context.Context, key string)) *mClientMockExists {
	if mmExists.mock.inspectFuncExists != nil {
		mmExists.mock.t.Fatalf("Inspect function is already set for ClientMock.Exists")
	}

	mmExists.mock.inspectFuncExists = f

	return mmExists
}

// Return sets up results that will be returned by Client.Exists
func (mmExists *mClientMockExists) Return(b1 bool, err error) *ClientMock {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("ClientMock.Exists mock is already set by Set")
	}

	if mmExists.defaultExpectation == nil {
		mmExists.defaultExpectation = &ClientMockExistsExpectation{mock: mmExists.mock}
	}
	mmExists.defaultExpectation.results = &ClientMockExistsResults{b1, err}
	mmExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExists.mock
}

// Set uses given function f to mock the Client.Exists method
func (mmExists *mClientMockExists) Set(f func(ctx context.Context, key string) (b1 bool, err error)) *ClientMock {
	if mmExists.defaultExpectation != nil {
		mmExists.mock.t.Fatalf("Default expectation is already set for the Client.Exists method")
	}

	if len(mmExists.expectations) > 0 {
		mmExists.mock.t.Fatalf("Some expectations are already set for the Client.Exists method")
	}

	mmExists.mock.funcExists = f
	mmExists.mock.funcExistsOrigin = minimock.CallerInfo(1)
	return mmExists.mock
}

// When sets expectation for the Client.Exists which will trigger the result defined by the following
// Then helper
func (mmExists *mClientMockExists) When(ctx context.Context, key string) *ClientMockExistsExpectation {
	if mmExists.mock.funcExists != nil {
		mmExists.mock.t.Fatalf("ClientMock.Exists mock is already set by Set")
	}

	expectation := &ClientMockExistsExpectation{
		mock:               mmExists.mock,
		params:             &ClientMockExistsParams{ctx, key},
		expectationOrigins: ClientMockExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExists.expectations = append(mmExists.expectations, expectation)
	return expectation
}

// Then sets up Client.Exists return parameters for the expectation previously defined by the When method
func (e *ClientMockExistsExpectation) Then(b1 bool, err error) *ClientMock {
	e.results = &ClientMockExistsResults{b1, err}
	return e.mock
}

// Times sets number of times Client.Exists should be invoked
func (mmExists *mClientMockExists) Times(n uint64) *mClientMockExists {
	if n == 0 {
		mmExists.mock.t.Fatalf("Times of ClientMock.Exists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExists.expectedInvocations, n)
	mmExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExists
}

func (mmExists *mClientMockExists) invocationsDone() bool {
	if len(mmExists.expectations) == 0 && mmExists.defaultExpectation == nil && mmExists.mock.funcExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExists.mock.afterExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Exists implements mm_cache.Client
func (mmExists *ClientMock) Exists(ctx context.Context, key string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmExists.beforeExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmExists.afterExistsCounter, 1)

	mmExists.t.Helper()

	if mmExists.inspectFuncExists != nil {
		mmExists.inspectFuncExists(ctx, key)
	}

	mm_params := ClientMockExistsParams{ctx, key}

	// Record call args
	mmExists.ExistsMock.mutex.Lock()
	mmExists.ExistsMock.callArgs = append(mmExists.ExistsMock.callArgs, &mm_params)
	mmExists.ExistsMock.mutex.Unlock()

	for _, e := range mmExists.ExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmExists.ExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExists.ExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmExists.ExistsMock.defaultExpectation.params
		mm_want_ptrs := mmExists.ExistsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockExistsParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExists.t.Errorf("ClientMock.Exists got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExists.ExistsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmExists.t.Errorf("ClientMock.Exists got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExists.ExistsMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExists.t.Errorf("ClientMock.Exists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExists.ExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExists.ExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmExists.t.Fatal("No results are set for the ClientMock.Exists")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmExists.funcExists != nil {
		return mmExists.funcExists(ctx, key)
	}
	mmExists.t.Fatalf("Unexpected call to ClientMock.Exists. %v %v", ctx, key)
	return
}

// ExistsAfterCounter returns a count of finished ClientMock.Exists invocations
func (mmExists *ClientMock) ExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExists.afterExistsCounter)
}

// ExistsBeforeCounter returns a count of ClientMock.Exists invocations
func (mmExists *ClientMock) ExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExists.beforeExistsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Exists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExists *mClientMockExists) Calls() []*ClientMockExistsParams {
	mmExists.mutex.RLock()

	argCopy := make([]*ClientMockExistsParams, len(mmExists.callArgs))
	copy(argCopy, mmExists.callArgs)

	mmExists.mutex.RUnlock()

	return argCopy
}

// MinimockExistsDone returns true if the count of the Exists invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockExistsDone() bool {
	if m.ExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExistsMock.invocationsDone()
}

// MinimockExistsInspect logs each unmet expectation
func (m *ClientMock) MinimockExistsInspect() {
	for _, e := range m.ExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Exists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExistsCounter := mm_atomic.LoadUint64(&m.afterExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExistsMock.defaultExpectation != nil && afterExistsCounter < 1 {
		if m.ExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Exists at\n%s", m.ExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Exists at\n%s with params: %#v", m.ExistsMock.defaultExpectation.expectationOrigins.origin, *m.ExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExists != nil && afterExistsCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Exists at\n%s", m.funcExistsOrigin)
	}

	if !m.ExistsMock.invocationsDone() && afterExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Exists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExistsMock.expectedInvocations), m.ExistsMock.expectedInvocationsOrigin, afterExistsCounter)
	}
}

type mClientMockExpire struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockExpireExpectation
	expectations       []*ClientMockExpireExpectation

	callArgs []*ClientMockExpireParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockExpireExpectation specifies expectation struct of the Client.Expire
type ClientMockExpireExpectation struct {
	mock               *ClientMock
	params             *ClientMockExpireParams
	paramPtrs          *ClientMockExpireParamPtrs
	expectationOrigins ClientMockExpireExpectationOrigins
	results            *ClientMockExpireResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockExpireParams contains parameters of the Client.Expire
type ClientMockExpireParams struct {
	ctx        context.Context
	key        string
	expiration time.Duration
}

// ClientMockExpireParamPtrs contains pointers to parameters of the Client.Expire
type ClientMockExpireParamPtrs struct {
	ctx        *context.Context
	key        *string
	expiration *time.Duration
}

// ClientMockExpireResults contains results of the Client.Expire
type ClientMockExpireResults struct {
	err error
}

// ClientMockExpireOrigins contains origins of expectations of the Client.Expire
type ClientMockExpireExpectationOrigins struct {
	origin           string
	originCtx        string
	originKey        string
	originExpiration string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExpire *mClientMockExpire) Optional() *mClientMockExpire {
	mmExpire.optional = true
	return mmExpire
}

// Expect sets up expected params for Client.Expire
func (mmExpire *mClientMockExpire) Expect(ctx context.Context, key string, expiration time.Duration) *mClientMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("ClientMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &ClientMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.paramPtrs != nil {
		mmExpire.mock.t.Fatalf("ClientMock.Expire mock is already set by ExpectParams functions")
	}

	mmExpire.defaultExpectation.params = &ClientMockExpireParams{ctx, key, expiration}
	mmExpire.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExpire.expectations {
		if minimock.Equal(e.params, mmExpire.defaultExpectation.params) {
			mmExpire.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExpire.defaultExpectation.params)
		}
	}

	return mmExpire
}

// ExpectCtxParam1 sets up expected param ctx for Client.Expire
func (mmExpire *mClientMockExpire) ExpectCtxParam1(ctx context.Context) *mClientMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("ClientMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &ClientMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("ClientMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &ClientMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.ctx = &ctx
	mmExpire.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExpire
}

// ExpectKeyParam2 sets up expected param key for Client.Expire
func (mmExpire *mClientMockExpire) ExpectKeyParam2(key string) *mClientMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("ClientMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &ClientMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("ClientMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &ClientMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.key = &key
	mmExpire.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmExpire
}

// ExpectExpirationParam3 sets up expected param expiration for Client.Expire
func (mmExpire *mClientMockExpire) ExpectExpirationParam3(expiration time.Duration) *mClientMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("ClientMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &ClientMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("ClientMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &ClientMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.expiration = &expiration
	mmExpire.defaultExpectation.expectationOrigins.originExpiration = minimock.CallerInfo(1)

	return mmExpire
}

// Inspect accepts an inspector function that has same arguments as the Client.Expire
func (mmExpire *mClientMockExpire) Inspect(f func(ctx context.Context, key string, expiration time.Duration)) *mClientMockExpire {
	if mmExpire.mock.inspectFuncExpire != nil {
		mmExpire.mock.t.Fatalf("Inspect function is already set for ClientMock.Expire")
	}

	mmExpire.mock.inspectFuncExpire = f

	return mmExpire
}

// Return sets up results that will be returned by Client.Expire
func (mmExpire *mClientMockExpire) Return(err error) *ClientMock {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("ClientMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &ClientMockExpireExpectation{mock: mmExpire.mock}
	}
	mmExpire.defaultExpectation.results = &ClientMockExpireResults{err}
	mmExpire.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExpire.mock
}

// Set uses given function f to mock the Client.Expire method
func (mmExpire *mClientMockExpire) Set(f func(ctx context.Context, key string, expiration time.Duration) (err error)) *ClientMock {
	if mmExpire.defaultExpectation != nil {
		mmExpire.mock.t.Fatalf("Default expectation is already set for the Client.Expire method")
	}

	if len(mmExpire.expectations) > 0 {
		mmExpire.mock.t.Fatalf("Some expectations are already set for the Client.Expire method")
	}

	mmExpire.mock.funcExpire = f
	mmExpire.mock.funcExpireOrigin = minimock.CallerInfo(1)
	return mmExpire.mock
}

// When sets expectation for the Client.Expire which will trigger the result defined by the following
// Then helper
func (mmExpire *mClientMockExpire) When(ctx context.Context, key string, expiration time.Duration) *ClientMockExpireExpectation {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("ClientMock.Expire mock is already set by Set")
	}

	expectation := &ClientMockExpireExpectation{
		mock:               mmExpire.mock,
		params:             &ClientMockExpireParams{ctx, key, expiration},
		expectationOrigins: ClientMockExpireExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExpire.expectations = append(mmExpire.expectations, expectation)
	return expectation
}

// Then sets up Client.Expire return parameters for the expectation previously defined by the When method
func (e *ClientMockExpireExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockExpireResults{err}
	return e.mock
}

// Times sets number of times Client.Expire should be invoked
func (mmExpire *mClientMockExpire) Times(n uint64) *mClientMockExpire {
	if n == 0 {
		mmExpire.mock.t.Fatalf("Times of ClientMock.Expire mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExpire.expectedInvocations, n)
	mmExpire.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExpire
}

func (mmExpire *mClientMockExpire) invocationsDone() bool {
	if len(mmExpire.expectations) == 0 && mmExpire.defaultExpectation == nil && mmExpire.mock.funcExpire == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExpire.mock.afterExpireCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExpire.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Expire implements mm_cache.Client
func (mmExpire *ClientMock) Expire(ctx context.Context, key string, expiration time.Duration) (err error) {
	mm_atomic.AddUint64(&mmExpire.beforeExpireCounter, 1)
	defer mm_atomic.AddUint64(&mmExpire.afterExpireCounter, 1)

	mmExpire.t.Helper()

	if mmExpire.inspectFuncExpire != nil {
		mmExpire.inspectFuncExpire(ctx, key, expiration)
	}

	mm_params := ClientMockExpireParams{ctx, key, expiration}

	// Record call args
	mmExpire.ExpireMock.mutex.Lock()
	mmExpire.ExpireMock.callArgs = append(mmExpire.ExpireMock.callArgs, &mm_params)
	mmExpire.ExpireMock.mutex.Unlock()

	for _, e := range mmExpire.ExpireMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmExpire.ExpireMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExpire.ExpireMock.defaultExpectation.Counter, 1)
		mm_want := mmExpire.ExpireMock.defaultExpectation.params
		mm_want_ptrs := mmExpire.ExpireMock.defaultExpectation.paramPtrs

		mm_got := ClientMockExpireParams{ctx, key, expiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExpire.t.Errorf("ClientMock.Expire got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpire.ExpireMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmExpire.t.Errorf("ClientMock.Expire got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpire.ExpireMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.expiration != nil && !minimock.Equal(*mm_want_ptrs.expiration, mm_got.expiration) {
				mmExpire.t.Errorf("ClientMock.Expire got unexpected parameter expiration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpire.ExpireMock.defaultExpectation.expectationOrigins.originExpiration, *mm_want_ptrs.expiration, mm_got.expiration, minimock.Diff(*mm_want_ptrs.expiration, mm_got.expiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExpire.t.Errorf("ClientMock.Expire got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExpire.ExpireMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExpire.ExpireMock.defaultExpectation.results
		if mm_results == nil {
			mmExpire.t.Fatal("No results are set for the ClientMock.Expire")
		}
		return (*mm_results).err
	}
	if mmExpire.funcExpire != nil {
		return mmExpire.funcExpire(ctx, key, expiration)
	}
	mmExpire.t.Fatalf("Unexpected call to ClientMock.Expire. %v %v %v", ctx, key, expiration)
	return
}

// ExpireAfterCounter returns a count of finished ClientMock.Expire invocations
func (mmExpire *ClientMock) ExpireAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.afterExpireCounter)
}

// ExpireBeforeCounter returns a count of ClientMock.Expire invocations
func (mmExpire *ClientMock) ExpireBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.beforeExpireCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Expire.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExpire *mClientMockExpire) Calls() []*ClientMockExpireParams {
	mmExpire.mutex.RLock()

	argCopy := make([]*ClientMockExpireParams, len(mmExpire.callArgs))
	copy(argCopy, mmExpire.callArgs)

	mmExpire.mutex.RUnlock()

	return argCopy
}

// MinimockExpireDone returns true if the count of the Expire invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockExpireDone() bool {
	if m.ExpireMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExpireMock.invocationsDone()
}

// MinimockExpireInspect logs each unmet expectation
func (m *ClientMock) MinimockExpireInspect() {
	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Expire at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExpireCounter := mm_atomic.LoadUint64(&m.afterExpireCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExpireMock.defaultExpectation != nil && afterExpireCounter < 1 {
		if m.ExpireMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Expire at\n%s", m.ExpireMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Expire at\n%s with params: %#v", m.ExpireMock.defaultExpectation.expectationOrigins.origin, *m.ExpireMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExpire != nil && afterExpireCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Expire at\n%s", m.funcExpireOrigin)
	}

	if !m.ExpireMock.invocationsDone() && afterExpireCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Expire at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExpireMock.expectedInvocations), m.ExpireMock.expectedInvocationsOrigin, afterExpireCounter)
	}
}

type mClientMockGet struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetExpectation
	expectations       []*ClientMockGetExpectation

	callArgs []*ClientMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetExpectation specifies expectation struct of the Client.Get
type ClientMockGetExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetParams
	paramPtrs          *ClientMockGetParamPtrs
	expectationOrigins ClientMockGetExpectationOrigins
	results            *ClientMockGetResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetParams contains parameters of the Client.Get
type ClientMockGetParams struct {
	ctx context.Context
	key string
}

// ClientMockGetParamPtrs contains pointers to parameters of the Client.Get
type ClientMockGetParamPtrs struct {
	ctx *context.Context
	key *string
}

// ClientMockGetResults contains results of the Client.Get
type ClientMockGetResults struct {
	s1  string
	err error
}

// ClientMockGetOrigins contains origins of expectations of the Client.Get
type ClientMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mClientMockGet) Optional() *mClientMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for Client.Get
func (mmGet *mClientMockGet) Expect(ctx context.Context, key string) *mClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &ClientMockGetParams{ctx, key}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for Client.Get
func (mmGet *mClientMockGet) ExpectCtxParam1(ctx context.Context) *mClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &ClientMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectKeyParam2 sets up expected param key for Client.Get
func (mmGet *mClientMockGet) ExpectKeyParam2(key string) *mClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &ClientMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.key = &key
	mmGet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Client.Get
func (mmGet *mClientMockGet) Inspect(f func(ctx context.Context, key string)) *mClientMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for ClientMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Client.Get
func (mmGet *mClientMockGet) Return(s1 string, err error) *ClientMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &ClientMockGetResults{s1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the Client.Get method
func (mmGet *mClientMockGet) Set(f func(ctx context.Context, key string) (s1 string, err error)) *ClientMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Client.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Client.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the Client.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mClientMockGet) When(ctx context.Context, key string) *ClientMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	expectation := &ClientMockGetExpectation{
		mock:               mmGet.mock,
		params:             &ClientMockGetParams{ctx, key},
		expectationOrigins: ClientMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Client.Get return parameters for the expectation previously defined by the When method
func (e *ClientMockGetExpectation) Then(s1 string, err error) *ClientMock {
	e.results = &ClientMockGetResults{s1, err}
	return e.mock
}

// Times sets number of times Client.Get should be invoked
func (mmGet *mClientMockGet) Times(n uint64) *mClientMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of ClientMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mClientMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_cache.Client
func (mmGet *ClientMock) Get(ctx context.Context, key string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, key)
	}

	mm_params := ClientMockGetParams{ctx, key}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("ClientMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGet.t.Errorf("ClientMock.Get got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("ClientMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the ClientMock.Get")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, key)
	}
	mmGet.t.Fatalf("Unexpected call to ClientMock.Get. %v %v", ctx, key)
	return
}

// GetAfterCounter returns a count of finished ClientMock.Get invocations
func (mmGet *ClientMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of ClientMock.Get invocations
func (mmGet *ClientMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mClientMockGet) Calls() []*ClientMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*ClientMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *ClientMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mClientMockHGetAll struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockHGetAllExpectation
	expectations       []*ClientMockHGetAllExpectation

	callArgs []*ClientMockHGetAllParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockHGetAllExpectation specifies expectation struct of the Client.HGetAll
type ClientMockHGetAllExpectation struct {
	mock               *ClientMock
	params             *ClientMockHGetAllParams
	paramPtrs          *ClientMockHGetAllParamPtrs
	expectationOrigins ClientMockHGetAllExpectationOrigins
	results            *ClientMockHGetAllResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockHGetAllParams contains parameters of the Client.HGetAll
type ClientMockHGetAllParams struct {
	ctx context.Context
	key string
}

// ClientMockHGetAllParamPtrs contains pointers to parameters of the Client.HGetAll
type ClientMockHGetAllParamPtrs struct {
	ctx *context.Context
	key *string
}

// ClientMockHGetAllResults contains results of the Client.HGetAll
type ClientMockHGetAllResults struct {
	m1  map[string]string
	err error
}

// ClientMockHGetAllOrigins contains origins of expectations of the Client.HGetAll
type ClientMockHGetAllExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHGetAll *mClientMockHGetAll) Optional() *mClientMockHGetAll {
	mmHGetAll.optional = true
	return mmHGetAll
}

// Expect sets up expected params for Client.HGetAll
func (mmHGetAll *mClientMockHGetAll) Expect(ctx context.Context, key string) *mClientMockHGetAll {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("ClientMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &ClientMockHGetAllExpectation{}
	}

	if mmHGetAll.defaultExpectation.paramPtrs != nil {
		mmHGetAll.mock.t.Fatalf("ClientMock.HGetAll mock is already set by ExpectParams functions")
	}

	mmHGetAll.defaultExpectation.params = &ClientMockHGetAllParams{ctx, key}
	mmHGetAll.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHGetAll.expectations {
		if minimock.Equal(e.params, mmHGetAll.defaultExpectation.params) {
			mmHGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHGetAll.defaultExpectation.params)
		}
	}

	return mmHGetAll
}

// ExpectCtxParam1 sets up expected param ctx for Client.HGetAll
func (mmHGetAll *mClientMockHGetAll) ExpectCtxParam1(ctx context.Context) *mClientMockHGetAll {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("ClientMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &ClientMockHGetAllExpectation{}
	}

	if mmHGetAll.defaultExpectation.params != nil {
		mmHGetAll.mock.t.Fatalf("ClientMock.HGetAll mock is already set by Expect")
	}

	if mmHGetAll.defaultExpectation.paramPtrs == nil {
		mmHGetAll.defaultExpectation.paramPtrs = &ClientMockHGetAllParamPtrs{}
	}
	mmHGetAll.defaultExpectation.paramPtrs.ctx = &ctx
	mmHGetAll.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHGetAll
}

// ExpectKeyParam2 sets up expected param key for Client.HGetAll
func (mmHGetAll *mClientMockHGetAll) ExpectKeyParam2(key string) *mClientMockHGetAll {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("ClientMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &ClientMockHGetAllExpectation{}
	}

	if mmHGetAll.defaultExpectation.params != nil {
		mmHGetAll.mock.t.Fatalf("ClientMock.HGetAll mock is already set by Expect")
	}

	if mmHGetAll.defaultExpectation.paramPtrs == nil {
		mmHGetAll.defaultExpectation.paramPtrs = &ClientMockHGetAllParamPtrs{}
	}
	mmHGetAll.defaultExpectation.paramPtrs.key = &key
	mmHGetAll.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmHGetAll
}

// Inspect accepts an inspector function that has same arguments as the Client.HGetAll
func (mmHGetAll *mClientMockHGetAll) Inspect(f func(ctx context.Context, key string)) *mClientMockHGetAll {
	if mmHGetAll.mock.inspectFuncHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("Inspect function is already set for ClientMock.HGetAll")
	}

	mmHGetAll.mock.inspectFuncHGetAll = f

	return mmHGetAll
}

// Return sets up results that will be returned by Client.HGetAll
func (mmHGetAll *mClientMockHGetAll) Return(m1 map[string]string, err error) *ClientMock {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("ClientMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &ClientMockHGetAllExpectation{mock: mmHGetAll.mock}
	}
	mmHGetAll.defaultExpectation.results = &ClientMockHGetAllResults{m1, err}
	mmHGetAll.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHGetAll.mock
}

// Set uses given function f to mock the Client.HGetAll method
func (mmHGetAll *mClientMockHGetAll) Set(f func(ctx context.Context, key string) (m1 map[string]string, err error)) *ClientMock {
	if mmHGetAll.defaultExpectation != nil {
		mmHGetAll.mock.t.Fatalf("Default expectation is already set for the Client.HGetAll method")
	}

	if len(mmHGetAll.expectations) > 0 {
		mmHGetAll.mock.t.Fatalf("Some expectations are already set for the Client.HGetAll method")
	}

	mmHGetAll.mock.funcHGetAll = f
	mmHGetAll.mock.funcHGetAllOrigin = minimock.CallerInfo(1)
	return mmHGetAll.mock
}

// When sets expectation for the Client.HGetAll which will trigger the result defined by the following
// Then helper
func (mmHGetAll *mClientMockHGetAll) When(ctx context.Context, key string) *ClientMockHGetAllExpectation {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("ClientMock.HGetAll mock is already set by Set")
	}

	expectation := &ClientMockHGetAllExpectation{
		mock:               mmHGetAll.mock,
		params:             &ClientMockHGetAllParams{ctx, key},
		expectationOrigins: ClientMockHGetAllExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHGetAll.expectations = append(mmHGetAll.expectations, expectation)
	return expectation
}

// Then sets up Client.HGetAll return parameters for the expectation previously defined by the When method
func (e *ClientMockHGetAllExpectation) Then(m1 map[string]string, err error) *ClientMock {
	e.results = &ClientMockHGetAllResults{m1, err}
	return e.mock
}

// Times sets number of times Client.HGetAll should be invoked
func (mmHGetAll *mClientMockHGetAll) Times(n uint64) *mClientMockHGetAll {
	if n == 0 {
		mmHGetAll.mock.t.Fatalf("Times of ClientMock.HGetAll mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHGetAll.expectedInvocations, n)
	mmHGetAll.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHGetAll
}

func (mmHGetAll *mClientMockHGetAll) invocationsDone() bool {
	if len(mmHGetAll.expectations) == 0 && mmHGetAll.defaultExpectation == nil && mmHGetAll.mock.funcHGetAll == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHGetAll.mock.afterHGetAllCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHGetAll.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HGetAll implements mm_cache.Client
func (mmHGetAll *ClientMock) HGetAll(ctx context.Context, key string) (m1 map[string]string, err error) {
	mm_atomic.AddUint64(&mmHGetAll.beforeHGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmHGetAll.afterHGetAllCounter, 1)

	mmHGetAll.t.Helper()

	if mmHGetAll.inspectFuncHGetAll != nil {
		mmHGetAll.inspectFuncHGetAll(ctx, key)
	}

	mm_params := ClientMockHGetAllParams{ctx, key}

	// Record call args
	mmHGetAll.HGetAllMock.mutex.Lock()
	mmHGetAll.HGetAllMock.callArgs = append(mmHGetAll.HGetAllMock.callArgs, &mm_params)
	mmHGetAll.HGetAllMock.mutex.Unlock()

	for _, e := range mmHGetAll.HGetAllMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmHGetAll.HGetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHGetAll.HGetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmHGetAll.HGetAllMock.defaultExpectation.params
		mm_want_ptrs := mmHGetAll.HGetAllMock.defaultExpectation.paramPtrs

		mm_got := ClientMockHGetAllParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHGetAll.t.Errorf("ClientMock.HGetAll got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHGetAll.HGetAllMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmHGetAll.t.Errorf("ClientMock.HGetAll got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHGetAll.HGetAllMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHGetAll.t.Errorf("ClientMock.HGetAll got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHGetAll.HGetAllMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHGetAll.HGetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmHGetAll.t.Fatal("No results are set for the ClientMock.HGetAll")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmHGetAll.funcHGetAll != nil {
		return mmHGetAll.funcHGetAll(ctx, key)
	}
	mmHGetAll.t.Fatalf("Unexpected call to ClientMock.HGetAll. %v %v", ctx, key)
	return
}

// HGetAllAfterCounter returns a count of finished ClientMock.HGetAll invocations
func (mmHGetAll *ClientMock) HGetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHGetAll.afterHGetAllCounter)
}

// HGetAllBeforeCounter returns a count of ClientMock.HGetAll invocations
func (mmHGetAll *ClientMock) HGetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHGetAll.beforeHGetAllCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.HGetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHGetAll *mClientMockHGetAll) Calls() []*ClientMockHGetAllParams {
	mmHGetAll.mutex.RLock()

	argCopy := make([]*ClientMockHGetAllParams, len(mmHGetAll.callArgs))
	copy(argCopy, mmHGetAll.callArgs)

	mmHGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockHGetAllDone returns true if the count of the HGetAll invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockHGetAllDone() bool {
	if m.HGetAllMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HGetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HGetAllMock.invocationsDone()
}

// MinimockHGetAllInspect logs each unmet expectation
func (m *ClientMock) MinimockHGetAllInspect() {
	for _, e := range m.HGetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.HGetAll at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHGetAllCounter := mm_atomic.LoadUint64(&m.afterHGetAllCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HGetAllMock.defaultExpectation != nil && afterHGetAllCounter < 1 {
		if m.HGetAllMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.HGetAll at\n%s", m.HGetAllMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.HGetAll at\n%s with params: %#v", m.HGetAllMock.defaultExpectation.expectationOrigins.origin, *m.HGetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHGetAll != nil && afterHGetAllCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.HGetAll at\n%s", m.funcHGetAllOrigin)
	}

	if !m.HGetAllMock.invocationsDone() && afterHGetAllCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.HGetAll at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HGetAllMock.expectedInvocations), m.HGetAllMock.expectedInvocationsOrigin, afterHGetAllCounter)
	}
}

type mClientMockHSet struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockHSetExpectation
	expectations       []*ClientMockHSetExpectation

	callArgs []*ClientMockHSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockHSetExpectation specifies expectation struct of the Client.HSet
type ClientMockHSetExpectation struct {
	mock               *ClientMock
	params             *ClientMockHSetParams
	paramPtrs          *ClientMockHSetParamPtrs
	expectationOrigins ClientMockHSetExpectationOrigins
	results            *ClientMockHSetResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockHSetParams contains parameters of the Client.HSet
type ClientMockHSetParams struct {
	ctx    context.Context
	key    string
	values interface{}
}

// ClientMockHSetParamPtrs contains pointers to parameters of the Client.HSet
type ClientMockHSetParamPtrs struct {
	ctx    *context.Context
	key    *string
	values *interface{}
}

// ClientMockHSetResults contains results of the Client.HSet
type ClientMockHSetResults struct {
	err error
}

// ClientMockHSetOrigins contains origins of expectations of the Client.HSet
type ClientMockHSetExpectationOrigins struct {
	origin       string
	originCtx    string
	originKey    string
	originValues string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHSet *mClientMockHSet) Optional() *mClientMockHSet {
	mmHSet.optional = true
	return mmHSet
}

// Expect sets up expected params for Client.HSet
func (mmHSet *mClientMockHSet) Expect(ctx context.Context, key string, values interface{}) *mClientMockHSet {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("ClientMock.HSet mock is already set by Set")
	}

	if mmHSet.defaultExpectation == nil {
		mmHSet.defaultExpectation = &ClientMockHSetExpectation{}
	}

	if mmHSet.defaultExpectation.paramPtrs != nil {
		mmHSet.mock.t.Fatalf("ClientMock.HSet mock is already set by ExpectParams functions")
	}

	mmHSet.defaultExpectation.params = &ClientMockHSetParams{ctx, key, values}
	mmHSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHSet.expectations {
		if minimock.Equal(e.params, mmHSet.defaultExpectation.params) {
			mmHSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHSet.defaultExpectation.params)
		}
	}

	return mmHSet
}

// ExpectCtxParam1 sets up expected param ctx for Client.HSet
func (mmHSet *mClientMockHSet) ExpectCtxParam1(ctx context.Context) *mClientMockHSet {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("ClientMock.HSet mock is already set by Set")
	}

	if mmHSet.defaultExpectation == nil {
		mmHSet.defaultExpectation = &ClientMockHSetExpectation{}
	}

	if mmHSet.defaultExpectation.params != nil {
		mmHSet.mock.t.Fatalf("ClientMock.HSet mock is already set by Expect")
	}

	if mmHSet.defaultExpectation.paramPtrs == nil {
		mmHSet.defaultExpectation.paramPtrs = &ClientMockHSetParamPtrs{}
	}
	mmHSet.defaultExpectation.paramPtrs.ctx = &ctx
	mmHSet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHSet
}

// ExpectKeyParam2 sets up expected param key for Client.HSet
func (mmHSet *mClientMockHSet) ExpectKeyParam2(key string) *mClientMockHSet {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("ClientMock.HSet mock is already set by Set")
	}

	if mmHSet.defaultExpectation == nil {
		mmHSet.defaultExpectation = &ClientMockHSetExpectation{}
	}

	if mmHSet.defaultExpectation.params != nil {
		mmHSet.mock.t.Fatalf("ClientMock.HSet mock is already set by Expect")
	}

	if mmHSet.defaultExpectation.paramPtrs == nil {
		mmHSet.defaultExpectation.paramPtrs = &ClientMockHSetParamPtrs{}
	}
	mmHSet.defaultExpectation.paramPtrs.key = &key
	mmHSet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmHSet
}

// ExpectValuesParam3 sets up expected param values for Client.HSet
func (mmHSet *mClientMockHSet) ExpectValuesParam3(values interface{}) *mClientMockHSet {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("ClientMock.HSet mock is already set by Set")
	}

	if mmHSet.defaultExpectation == nil {
		mmHSet.defaultExpectation = &ClientMockHSetExpectation{}
	}

	if mmHSet.defaultExpectation.params != nil {
		mmHSet.mock.t.Fatalf("ClientMock.HSet mock is already set by Expect")
	}

	if mmHSet.defaultExpectation.paramPtrs == nil {
		mmHSet.defaultExpectation.paramPtrs = &ClientMockHSetParamPtrs{}
	}
	mmHSet.defaultExpectation.paramPtrs.values = &values
	mmHSet.defaultExpectation.expectationOrigins.originValues = minimock.CallerInfo(1)

	return mmHSet
}

// Inspect accepts an inspector function that has same arguments as the Client.HSet
func (mmHSet *mClientMockHSet) Inspect(f func(ctx context.Context, key string, values interface{})) *mClientMockHSet {
	if mmHSet.mock.inspectFuncHSet != nil {
		mmHSet.mock.t.Fatalf("Inspect function is already set for ClientMock.HSet")
	}

	mmHSet.mock.inspectFuncHSet = f

	return mmHSet
}

// Return sets up results that will be returned by Client.HSet
func (mmHSet *mClientMockHSet) Return(err error) *ClientMock {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("ClientMock.HSet mock is already set by Set")
	}

	if mmHSet.defaultExpectation == nil {
		mmHSet.defaultExpectation = &ClientMockHSetExpectation{mock: mmHSet.mock}
	}
	mmHSet.defaultExpectation.results = &ClientMockHSetResults{err}
	mmHSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHSet.mock
}

// Set uses given function f to mock the Client.HSet method
func (mmHSet *mClientMockHSet) Set(f func(ctx context.Context, key string, values interface{}) (err error)) *ClientMock {
	if mmHSet.defaultExpectation != nil {
		mmHSet.mock.t.Fatalf("Default expectation is already set for the Client.HSet method")
	}

	if len(mmHSet.expectations) > 0 {
		mmHSet.mock.t.Fatalf("Some expectations are already set for the Client.HSet method")
	}

	mmHSet.mock.funcHSet = f
	mmHSet.mock.funcHSetOrigin = minimock.CallerInfo(1)
	return mmHSet.mock
}

// When sets expectation for the Client.HSet which will trigger the result defined by the following
// Then helper
func (mmHSet *mClientMockHSet) When(ctx context.Context, key string, values interface{}) *ClientMockHSetExpectation {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("ClientMock.HSet mock is already set by Set")
	}

	expectation := &ClientMockHSetExpectation{
		mock:               mmHSet.mock,
		params:             &ClientMockHSetParams{ctx, key, values},
		expectationOrigins: ClientMockHSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHSet.expectations = append(mmHSet.expectations, expectation)
	return expectation
}

// Then sets up Client.HSet return parameters for the expectation previously defined by the When method
func (e *ClientMockHSetExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockHSetResults{err}
	return e.mock
}

// Times sets number of times Client.HSet should be invoked
func (mmHSet *mClientMockHSet) Times(n uint64) *mClientMockHSet {
	if n == 0 {
		mmHSet.mock.t.Fatalf("Times of ClientMock.HSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHSet.expectedInvocations, n)
	mmHSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHSet
}

func (mmHSet *mClientMockHSet) invocationsDone() bool {
	if len(mmHSet.expectations) == 0 && mmHSet.defaultExpectation == nil && mmHSet.mock.funcHSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHSet.mock.afterHSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HSet implements mm_cache.Client
func (mmHSet *ClientMock) HSet(ctx context.Context, key string, values interface{}) (err error) {
	mm_atomic.AddUint64(&mmHSet.beforeHSetCounter, 1)
	defer mm_atomic.AddUint64(&mmHSet.afterHSetCounter, 1)

	mmHSet.t.Helper()

	if mmHSet.inspectFuncHSet != nil {
		mmHSet.inspectFuncHSet(ctx, key, values)
	}

	mm_params := ClientMockHSetParams{ctx, key, values}

	// Record call args
	mmHSet.HSetMock.mutex.Lock()
	mmHSet.HSetMock.callArgs = append(mmHSet.HSetMock.callArgs, &mm_params)
	mmHSet.HSetMock.mutex.Unlock()

	for _, e := range mmHSet.HSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHSet.HSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHSet.HSetMock.defaultExpectation.Counter, 1)
		mm_want := mmHSet.HSetMock.defaultExpectation.params
		mm_want_ptrs := mmHSet.HSetMock.defaultExpectation.paramPtrs

		mm_got := ClientMockHSetParams{ctx, key, values}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHSet.t.Errorf("ClientMock.HSet got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHSet.HSetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmHSet.t.Errorf("ClientMock.HSet got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHSet.HSetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.values != nil && !minimock.Equal(*mm_want_ptrs.values, mm_got.values) {
				mmHSet.t.Errorf("ClientMock.HSet got unexpected parameter values, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHSet.HSetMock.defaultExpectation.expectationOrigins.originValues, *mm_want_ptrs.values, mm_got.values, minimock.Diff(*mm_want_ptrs.values, mm_got.values))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHSet.t.Errorf("ClientMock.HSet got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHSet.HSetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHSet.HSetMock.defaultExpectation.results
		if mm_results == nil {
			mmHSet.t.Fatal("No results are set for the ClientMock.HSet")
		}
		return (*mm_results).err
	}
	if mmHSet.funcHSet != nil {
		return mmHSet.funcHSet(ctx, key, values)
	}
	mmHSet.t.Fatalf("Unexpected call to ClientMock.HSet. %v %v %v", ctx, key, values)
	return
}

// HSetAfterCounter returns a count of finished ClientMock.HSet invocations
func (mmHSet *ClientMock) HSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHSet.afterHSetCounter)
}

// HSetBeforeCounter returns a count of ClientMock.HSet invocations
func (mmHSet *ClientMock) HSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHSet.beforeHSetCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.HSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHSet *mClientMockHSet) Calls() []*ClientMockHSetParams {
	mmHSet.mutex.RLock()

	argCopy := make([]*ClientMockHSetParams, len(mmHSet.callArgs))
	copy(argCopy, mmHSet.callArgs)

	mmHSet.mutex.RUnlock()

	return argCopy
}

// MinimockHSetDone returns true if the count of the HSet invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockHSetDone() bool {
	if m.HSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HSetMock.invocationsDone()
}

// MinimockHSetInspect logs each unmet expectation
func (m *ClientMock) MinimockHSetInspect() {
	for _, e := range m.HSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.HSet at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHSetCounter := mm_atomic.LoadUint64(&m.afterHSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HSetMock.defaultExpectation != nil && afterHSetCounter < 1 {
		if m.HSetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.HSet at\n%s", m.HSetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.HSet at\n%s with params: %#v", m.HSetMock.defaultExpectation.expectationOrigins.origin, *m.HSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHSet != nil && afterHSetCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.HSet at\n%s", m.funcHSetOrigin)
	}

	if !m.HSetMock.invocationsDone() && afterHSetCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.HSet at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HSetMock.expectedInvocations), m.HSetMock.expectedInvocationsOrigin, afterHSetCounter)
	}
}

type mClientMockHSetField struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockHSetFieldExpectation
	expectations       []*ClientMockHSetFieldExpectation

	callArgs []*ClientMockHSetFieldParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockHSetFieldExpectation specifies expectation struct of the Client.HSetField
type ClientMockHSetFieldExpectation struct {
	mock               *ClientMock
	params             *ClientMockHSetFieldParams
	paramPtrs          *ClientMockHSetFieldParamPtrs
	expectationOrigins ClientMockHSetFieldExpectationOrigins
	results            *ClientMockHSetFieldResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockHSetFieldParams contains parameters of the Client.HSetField
type ClientMockHSetFieldParams struct {
	ctx   context.Context
	key   string
	field string
	value interface{}
}

// ClientMockHSetFieldParamPtrs contains pointers to parameters of the Client.HSetField
type ClientMockHSetFieldParamPtrs struct {
	ctx   *context.Context
	key   *string
	field *string
	value *interface{}
}

// ClientMockHSetFieldResults contains results of the Client.HSetField
type ClientMockHSetFieldResults struct {
	err error
}

// ClientMockHSetFieldOrigins contains origins of expectations of the Client.HSetField
type ClientMockHSetFieldExpectationOrigins struct {
	origin      string
	originCtx   string
	originKey   string
	originField string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHSetField *mClientMockHSetField) Optional() *mClientMockHSetField {
	mmHSetField.optional = true
	return mmHSetField
}

// Expect sets up expected params for Client.HSetField
func (mmHSetField *mClientMockHSetField) Expect(ctx context.Context, key string, field string, value interface{}) *mClientMockHSetField {
	if mmHSetField.mock.funcHSetField != nil {
		mmHSetField.mock.t.Fatalf("ClientMock.HSetField mock is already set by Set")
	}

	if mmHSetField.defaultExpectation == nil {
		mmHSetField.defaultExpectation = &ClientMockHSetFieldExpectation{}
	}

	if mmHSetField.defaultExpectation.paramPtrs != nil {
		mmHSetField.mock.t.Fatalf("ClientMock.HSetField mock is already set by ExpectParams functions")
	}

	mmHSetField.defaultExpectation.params = &ClientMockHSetFieldParams{ctx, key, field, value}
	mmHSetField.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHSetField.expectations {
		if minimock.Equal(e.params, mmHSetField.defaultExpectation.params) {
			mmHSetField.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHSetField.defaultExpectation.params)
		}
	}

	return mmHSetField
}

// ExpectCtxParam1 sets up expected param ctx for Client.HSetField
func (mmHSetField *mClientMockHSetField) ExpectCtxParam1(ctx context.Context) *mClientMockHSetField {
	if mmHSetField.mock.funcHSetField != nil {
		mmHSetField.mock.t.Fatalf("ClientMock.HSetField mock is already set by Set")
	}

	if mmHSetField.defaultExpectation == nil {
		mmHSetField.defaultExpectation = &ClientMockHSetFieldExpectation{}
	}

	if mmHSetField.defaultExpectation.params != nil {
		mmHSetField.mock.t.Fatalf("ClientMock.HSetField mock is already set by Expect")
	}

	if mmHSetField.defaultExpectation.paramPtrs == nil {
		mmHSetField.defaultExpectation.paramPtrs = &ClientMockHSetFieldParamPtrs{}
	}
	mmHSetField.defaultExpectation.paramPtrs.ctx = &ctx
	mmHSetField.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHSetField
}

// ExpectKeyParam2 sets up expected param key for Client.HSetField
func (mmHSetField *mClientMockHSetField) ExpectKeyParam2(key string) *mClientMockHSetField {
	if mmHSetField.mock.funcHSetField != nil {
		mmHSetField.mock.t.Fatalf("ClientMock.HSetField mock is already set by Set")
	}

	if mmHSetField.defaultExpectation == nil {
		mmHSetField.defaultExpectation = &ClientMockHSetFieldExpectation{}
	}

	if mmHSetField.defaultExpectation.params != nil {
		mmHSetField.mock.t.Fatalf("ClientMock.HSetField mock is already set by Expect")
	}

	if mmHSetField.defaultExpectation.paramPtrs == nil {
		mmHSetField.defaultExpectation.paramPtrs = &ClientMockHSetFieldParamPtrs{}
	}
	mmHSetField.defaultExpectation.paramPtrs.key = &key
	mmHSetField.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmHSetField
}

// ExpectFieldParam3 sets up expected param field for Client.HSetField
func (mmHSetField *mClientMockHSetField) ExpectFieldParam3(field string) *mClientMockHSetField {
	if mmHSetField.mock.funcHSetField != nil {
		mmHSetField.mock.t.Fatalf("ClientMock.HSetField mock is already set by Set")
	}

	if mmHSetField.defaultExpectation == nil {
		mmHSetField.defaultExpectation = &ClientMockHSetFieldExpectation{}
	}

	if mmHSetField.defaultExpectation.params != nil {
		mmHSetField.mock.t.Fatalf("ClientMock.HSetField mock is already set by Expect")
	}

	if mmHSetField.defaultExpectation.paramPtrs == nil {
		mmHSetField.defaultExpectation.paramPtrs = &ClientMockHSetFieldParamPtrs{}
	}
	mmHSetField.defaultExpectation.paramPtrs.field = &field
	mmHSetField.defaultExpectation.expectationOrigins.originField = minimock.CallerInfo(1)

	return mmHSetField
}

// ExpectValueParam4 sets up expected param value for Client.HSetField
func (mmHSetField *mClientMockHSetField) ExpectValueParam4(value interface{}) *mClientMockHSetField {
	if mmHSetField.mock.funcHSetField != nil {
		mmHSetField.mock.t.Fatalf("ClientMock.HSetField mock is already set by Set")
	}

	if mmHSetField.defaultExpectation == nil {
		mmHSetField.defaultExpectation = &ClientMockHSetFieldExpectation{}
	}

	if mmHSetField.defaultExpectation.params != nil {
		mmHSetField.mock.t.Fatalf("ClientMock.HSetField mock is already set by Expect")
	}

	if mmHSetField.defaultExpectation.paramPtrs == nil {
		mmHSetField.defaultExpectation.paramPtrs = &ClientMockHSetFieldParamPtrs{}
	}
	mmHSetField.defaultExpectation.paramPtrs.value = &value
	mmHSetField.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmHSetField
}

// Inspect accepts an inspector function that has same arguments as the Client.HSetField
func (mmHSetField *mClientMockHSetField) Inspect(f func(ctx context.Context, key string, field string, value interface{})) *mClientMockHSetField {
	if mmHSetField.mock.inspectFuncHSetField != nil {
		mmHSetField.mock.t.Fatalf("Inspect function is already set for ClientMock.HSetField")
	}

	mmHSetField.mock.inspectFuncHSetField = f

	return mmHSetField
}

// Return sets up results that will be returned by Client.HSetField
func (mmHSetField *mClientMockHSetField) Return(err error) *ClientMock {
	if mmHSetField.mock.funcHSetField != nil {
		mmHSetField.mock.t.Fatalf("ClientMock.HSetField mock is already set by Set")
	}

	if mmHSetField.defaultExpectation == nil {
		mmHSetField.defaultExpectation = &ClientMockHSetFieldExpectation{mock: mmHSetField.mock}
	}
	mmHSetField.defaultExpectation.results = &ClientMockHSetFieldResults{err}
	mmHSetField.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHSetField.mock
}

// Set uses given function f to mock the Client.HSetField method
func (mmHSetField *mClientMockHSetField) Set(f func(ctx context.Context, key string, field string, value interface{}) (err error)) *ClientMock {
	if mmHSetField.defaultExpectation != nil {
		mmHSetField.mock.t.Fatalf("Default expectation is already set for the Client.HSetField method")
	}

	if len(mmHSetField.expectations) > 0 {
		mmHSetField.mock.t.Fatalf("Some expectations are already set for the Client.HSetField method")
	}

	mmHSetField.mock.funcHSetField = f
	mmHSetField.mock.funcHSetFieldOrigin = minimock.CallerInfo(1)
	return mmHSetField.mock
}

// When sets expectation for the Client.HSetField which will trigger the result defined by the following
// Then helper
func (mmHSetField *mClientMockHSetField) When(ctx context.Context, key string, field string, value interface{}) *ClientMockHSetFieldExpectation {
	if mmHSetField.mock.funcHSetField != nil {
		mmHSetField.mock.t.Fatalf("ClientMock.HSetField mock is already set by Set")
	}

	expectation := &ClientMockHSetFieldExpectation{
		mock:               mmHSetField.mock,
		params:             &ClientMockHSetFieldParams{ctx, key, field, value},
		expectationOrigins: ClientMockHSetFieldExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHSetField.expectations = append(mmHSetField.expectations, expectation)
	return expectation
}

// Then sets up Client.HSetField return parameters for the expectation previously defined by the When method
func (e *ClientMockHSetFieldExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockHSetFieldResults{err}
	return e.mock
}

// Times sets number of times Client.HSetField should be invoked
func (mmHSetField *mClientMockHSetField) Times(n uint64) *mClientMockHSetField {
	if n == 0 {
		mmHSetField.mock.t.Fatalf("Times of ClientMock.HSetField mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHSetField.expectedInvocations, n)
	mmHSetField.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHSetField
}

func (mmHSetField *mClientMockHSetField) invocationsDone() bool {
	if len(mmHSetField.expectations) == 0 && mmHSetField.defaultExpectation == nil && mmHSetField.mock.funcHSetField == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHSetField.mock.afterHSetFieldCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHSetField.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HSetField implements mm_cache.Client
func (mmHSetField *ClientMock) HSetField(ctx context.Context, key string, field string, value interface{}) (err error) {
	mm_atomic.AddUint64(&mmHSetField.beforeHSetFieldCounter, 1)
	defer mm_atomic.AddUint64(&mmHSetField.afterHSetFieldCounter, 1)

	mmHSetField.t.Helper()

	if mmHSetField.inspectFuncHSetField != nil {
		mmHSetField.inspectFuncHSetField(ctx, key, field, value)
	}

	mm_params := ClientMockHSetFieldParams{ctx, key, field, value}

	// Record call args
	mmHSetField.HSetFieldMock.mutex.Lock()
	mmHSetField.HSetFieldMock.callArgs = append(mmHSetField.HSetFieldMock.callArgs, &mm_params)
	mmHSetField.HSetFieldMock.mutex.Unlock()

	for _, e := range mmHSetField.HSetFieldMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHSetField.HSetFieldMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHSetField.HSetFieldMock.defaultExpectation.Counter, 1)
		mm_want := mmHSetField.HSetFieldMock.defaultExpectation.params
		mm_want_ptrs := mmHSetField.HSetFieldMock.defaultExpectation.paramPtrs

		mm_got := ClientMockHSetFieldParams{ctx, key, field, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHSetField.t.Errorf("ClientMock.HSetField got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHSetField.HSetFieldMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmHSetField.t.Errorf("ClientMock.HSetField got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHSetField.HSetFieldMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.field != nil && !minimock.Equal(*mm_want_ptrs.field, mm_got.field) {
				mmHSetField.t.Errorf("ClientMock.HSetField got unexpected parameter field, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHSetField.HSetFieldMock.defaultExpectation.expectationOrigins.originField, *mm_want_ptrs.field, mm_got.field, minimock.Diff(*mm_want_ptrs.field, mm_got.field))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmHSetField.t.Errorf("ClientMock.HSetField got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHSetField.HSetFieldMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHSetField.t.Errorf("ClientMock.HSetField got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHSetField.HSetFieldMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHSetField.HSetFieldMock.defaultExpectation.results
		if mm_results == nil {
			mmHSetField.t.Fatal("No results are set for the ClientMock.HSetField")
		}
		return (*mm_results).err
	}
	if mmHSetField.funcHSetField != nil {
		return mmHSetField.funcHSetField(ctx, key, field, value)
	}
	mmHSetField.t.Fatalf("Unexpected call to ClientMock.HSetField. %v %v %v %v", ctx, key, field, value)
	return
}

// HSetFieldAfterCounter returns a count of finished ClientMock.HSetField invocations
func (mmHSetField *ClientMock) HSetFieldAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHSetField.afterHSetFieldCounter)
}

// HSetFieldBeforeCounter returns a count of ClientMock.HSetField invocations
func (mmHSetField *ClientMock) HSetFieldBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHSetField.beforeHSetFieldCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.HSetField.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHSetField *mClientMockHSetField) Calls() []*ClientMockHSetFieldParams {
	mmHSetField.mutex.RLock()

	argCopy := make([]*ClientMockHSetFieldParams, len(mmHSetField.callArgs))
	copy(argCopy, mmHSetField.callArgs)

	mmHSetField.mutex.RUnlock()

	return argCopy
}

// MinimockHSetFieldDone returns true if the count of the HSetField invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockHSetFieldDone() bool {
	if m.HSetFieldMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HSetFieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HSetFieldMock.invocationsDone()
}

// MinimockHSetFieldInspect logs each unmet expectation
func (m *ClientMock) MinimockHSetFieldInspect() {
	for _, e := range m.HSetFieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.HSetField at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHSetFieldCounter := mm_atomic.LoadUint64(&m.afterHSetFieldCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HSetFieldMock.defaultExpectation != nil && afterHSetFieldCounter < 1 {
		if m.HSetFieldMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.HSetField at\n%s", m.HSetFieldMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.HSetField at\n%s with params: %#v", m.HSetFieldMock.defaultExpectation.expectationOrigins.origin, *m.HSetFieldMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHSetField != nil && afterHSetFieldCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.HSetField at\n%s", m.funcHSetFieldOrigin)
	}

	if !m.HSetFieldMock.invocationsDone() && afterHSetFieldCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.HSetField at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HSetFieldMock.expectedInvocations), m.HSetFieldMock.expectedInvocationsOrigin, afterHSetFieldCounter)
	}
}

type mClientMockPing struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockPingExpectation
	expectations       []*ClientMockPingExpectation

	callArgs []*ClientMockPingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockPingExpectation specifies expectation struct of the Client.Ping
type ClientMockPingExpectation struct {
	mock               *ClientMock
	params             *ClientMockPingParams
	paramPtrs          *ClientMockPingParamPtrs
	expectationOrigins ClientMockPingExpectationOrigins
	results            *ClientMockPingResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockPingParams contains parameters of the Client.Ping
type ClientMockPingParams struct {
	ctx context.Context
}

// ClientMockPingParamPtrs contains pointers to parameters of the Client.Ping
type ClientMockPingParamPtrs struct {
	ctx *context.Context
}

// ClientMockPingResults contains results of the Client.Ping
type ClientMockPingResults struct {
	err error
}

// ClientMockPingOrigins contains origins of expectations of the Client.Ping
type ClientMockPingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPing *mClientMockPing) Optional() *mClientMockPing {
	mmPing.optional = true
	return mmPing
}

// Expect sets up expected params for Client.Ping
func (mmPing *mClientMockPing) Expect(ctx context.Context) *mClientMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("ClientMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &ClientMockPingExpectation{}
	}

	if mmPing.defaultExpectation.paramPtrs != nil {
		mmPing.mock.t.Fatalf("ClientMock.Ping mock is already set by ExpectParams functions")
	}

	mmPing.defaultExpectation.params = &ClientMockPingParams{ctx}
	mmPing.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPing.expectations {
		if minimock.Equal(e.params, mmPing.defaultExpectation.params) {
			mmPing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPing.defaultExpectation.params)
		}
	}

	return mmPing
}

// ExpectCtxParam1 sets up expected param ctx for Client.Ping
func (mmPing *mClientMockPing) ExpectCtxParam1(ctx context.Context) *mClientMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("ClientMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &ClientMockPingExpectation{}
	}

	if mmPing.defaultExpectation.params != nil {
		mmPing.mock.t.Fatalf("ClientMock.Ping mock is already set by Expect")
	}

	if mmPing.defaultExpectation.paramPtrs == nil {
		mmPing.defaultExpectation.paramPtrs = &ClientMockPingParamPtrs{}
	}
	mmPing.defaultExpectation.paramPtrs.ctx = &ctx
	mmPing.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPing
}

// Inspect accepts an inspector function that has same arguments as the Client.Ping
func (mmPing *mClientMockPing) Inspect(f func(ctx context.Context)) *mClientMockPing {
	if mmPing.mock.inspectFuncPing != nil {
		mmPing.mock.t.Fatalf("Inspect function is already set for ClientMock.Ping")
	}

	mmPing.mock.inspectFuncPing = f

	return mmPing
}

// Return sets up results that will be returned by Client.Ping
func (mmPing *mClientMockPing) Return(err error) *ClientMock {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("ClientMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &ClientMockPingExpectation{mock: mmPing.mock}
	}
	mmPing.defaultExpectation.results = &ClientMockPingResults{err}
	mmPing.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPing.mock
}

// Set uses given function f to mock the Client.Ping method
func (mmPing *mClientMockPing) Set(f func(ctx context.Context) (err error)) *ClientMock {
	if mmPing.defaultExpectation != nil {
		mmPing.mock.t.Fatalf("Default expectation is already set for the Client.Ping method")
	}

	if len(mmPing.expectations) > 0 {
		mmPing.mock.t.Fatalf("Some expectations are already set for the Client.Ping method")
	}

	mmPing.mock.funcPing = f
	mmPing.mock.funcPingOrigin = minimock.CallerInfo(1)
	return mmPing.mock
}

// When sets expectation for the Client.Ping which will trigger the result defined by the following
// Then helper
func (mmPing *mClientMockPing) When(ctx context.Context) *ClientMockPingExpectation {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("ClientMock.Ping mock is already set by Set")
	}

	expectation := &ClientMockPingExpectation{
		mock:               mmPing.mock,
		params:             &ClientMockPingParams{ctx},
		expectationOrigins: ClientMockPingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPing.expectations = append(mmPing.expectations, expectation)
	return expectation
}

// Then sets up Client.Ping return parameters for the expectation previously defined by the When method
func (e *ClientMockPingExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockPingResults{err}
	return e.mock
}

// Times sets number of times Client.Ping should be invoked
func (mmPing *mClientMockPing) Times(n uint64) *mClientMockPing {
	if n == 0 {
		mmPing.mock.t.Fatalf("Times of ClientMock.Ping mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPing.expectedInvocations, n)
	mmPing.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPing
}

func (mmPing *mClientMockPing) invocationsDone() bool {
	if len(mmPing.expectations) == 0 && mmPing.defaultExpectation == nil && mmPing.mock.funcPing == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPing.mock.afterPingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPing.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Ping implements mm_cache.Client
func (mmPing *ClientMock) Ping(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPing.beforePingCounter, 1)
	defer mm_atomic.AddUint64(&mmPing.afterPingCounter, 1)

	mmPing.t.Helper()

	if mmPing.inspectFuncPing != nil {
		mmPing.inspectFuncPing(ctx)
	}

	mm_params := ClientMockPingParams{ctx}

	// Record call args
	mmPing.PingMock.mutex.Lock()
	mmPing.PingMock.callArgs = append(mmPing.PingMock.callArgs, &mm_params)
	mmPing.PingMock.mutex.Unlock()

	for _, e := range mmPing.PingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPing.PingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPing.PingMock.defaultExpectation.Counter, 1)
		mm_want := mmPing.PingMock.defaultExpectation.params
		mm_want_ptrs := mmPing.PingMock.defaultExpectation.paramPtrs

		mm_got := ClientMockPingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPing.t.Errorf("ClientMock.Ping got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPing.PingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPing.t.Errorf("ClientMock.Ping got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPing.PingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPing.PingMock.defaultExpectation.results
		if mm_results == nil {
			mmPing.t.Fatal("No results are set for the ClientMock.Ping")
		}
		return (*mm_results).err
	}
	if mmPing.funcPing != nil {
		return mmPing.funcPing(ctx)
	}
	mmPing.t.Fatalf("Unexpected call to ClientMock.Ping. %v", ctx)
	return
}

// PingAfterCounter returns a count of finished ClientMock.Ping invocations
func (mmPing *ClientMock) PingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.afterPingCounter)
}

// PingBeforeCounter returns a count of ClientMock.Ping invocations
func (mmPing *ClientMock) PingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.beforePingCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Ping.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPing *mClientMockPing) Calls() []*ClientMockPingParams {
	mmPing.mutex.RLock()

	argCopy := make([]*ClientMockPingParams, len(mmPing.callArgs))
	copy(argCopy, mmPing.callArgs)

	mmPing.mutex.RUnlock()

	return argCopy
}

// MinimockPingDone returns true if the count of the Ping invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockPingDone() bool {
	if m.PingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PingMock.invocationsDone()
}

// MinimockPingInspect logs each unmet expectation
func (m *ClientMock) MinimockPingInspect() {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Ping at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPingCounter := mm_atomic.LoadUint64(&m.afterPingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && afterPingCounter < 1 {
		if m.PingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Ping at\n%s", m.PingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Ping at\n%s with params: %#v", m.PingMock.defaultExpectation.expectationOrigins.origin, *m.PingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && afterPingCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Ping at\n%s", m.funcPingOrigin)
	}

	if !m.PingMock.invocationsDone() && afterPingCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Ping at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PingMock.expectedInvocations), m.PingMock.expectedInvocationsOrigin, afterPingCounter)
	}
}

type mClientMockSet struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockSetExpectation
	expectations       []*ClientMockSetExpectation

	callArgs []*ClientMockSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockSetExpectation specifies expectation struct of the Client.Set
type ClientMockSetExpectation struct {
	mock               *ClientMock
	params             *ClientMockSetParams
	paramPtrs          *ClientMockSetParamPtrs
	expectationOrigins ClientMockSetExpectationOrigins
	results            *ClientMockSetResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockSetParams contains parameters of the Client.Set
type ClientMockSetParams struct {
	ctx   context.Context
	key   string
	value interface{}
}

// ClientMockSetParamPtrs contains pointers to parameters of the Client.Set
type ClientMockSetParamPtrs struct {
	ctx   *context.Context
	key   *string
	value *interface{}
}

// ClientMockSetResults contains results of the Client.Set
type ClientMockSetResults struct {
	err error
}

// ClientMockSetOrigins contains origins of expectations of the Client.Set
type ClientMockSetExpectationOrigins struct {
	origin      string
	originCtx   string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mClientMockSet) Optional() *mClientMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for Client.Set
func (mmSet *mClientMockSet) Expect(ctx context.Context, key string, value interface{}) *mClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &ClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &ClientMockSetParams{ctx, key, value}
	mmSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectCtxParam1 sets up expected param ctx for Client.Set
func (mmSet *mClientMockSet) ExpectCtxParam1(ctx context.Context) *mClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &ClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &ClientMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.ctx = &ctx
	mmSet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSet
}

// ExpectKeyParam2 sets up expected param key for Client.Set
func (mmSet *mClientMockSet) ExpectKeyParam2(key string) *mClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &ClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &ClientMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.key = &key
	mmSet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSet
}

// ExpectValueParam3 sets up expected param value for Client.Set
func (mmSet *mClientMockSet) ExpectValueParam3(value interface{}) *mClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &ClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &ClientMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.value = &value
	mmSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the Client.Set
func (mmSet *mClientMockSet) Inspect(f func(ctx context.Context, key string, value interface{})) *mClientMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for ClientMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by Client.Set
func (mmSet *mClientMockSet) Return(err error) *ClientMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &ClientMockSetExpectation{mock: mmSet.mock}
	}
	mmSet.defaultExpectation.results = &ClientMockSetResults{err}
	mmSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// Set uses given function f to mock the Client.Set method
func (mmSet *mClientMockSet) Set(f func(ctx context.Context, key string, value interface{}) (err error)) *ClientMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the Client.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the Client.Set method")
	}

	mmSet.mock.funcSet = f
	mmSet.mock.funcSetOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// When sets expectation for the Client.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mClientMockSet) When(ctx context.Context, key string, value interface{}) *ClientMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("ClientMock.Set mock is already set by Set")
	}

	expectation := &ClientMockSetExpectation{
		mock:               mmSet.mock,
		params:             &ClientMockSetParams{ctx, key, value},
		expectationOrigins: ClientMockSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up Client.Set return parameters for the expectation previously defined by the When method
func (e *ClientMockSetExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockSetResults{err}
	return e.mock
}

// Times sets number of times Client.Set should be invoked
func (mmSet *mClientMockSet) Times(n uint64) *mClientMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of ClientMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	mmSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSet
}

func (mmSet *mClientMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements mm_cache.Client
func (mmSet *ClientMock) Set(ctx context.Context, key string, value interface{}) (err error) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	mmSet.t.Helper()

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, key, value)
	}

	mm_params := ClientMockSetParams{ctx, key, value}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := ClientMockSetParams{ctx, key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSet.t.Errorf("ClientMock.Set got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSet.t.Errorf("ClientMock.Set got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSet.t.Errorf("ClientMock.Set got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("ClientMock.Set got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSet.SetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSet.SetMock.defaultExpectation.results
		if mm_results == nil {
			mmSet.t.Fatal("No results are set for the ClientMock.Set")
		}
		return (*mm_results).err
	}
	if mmSet.funcSet != nil {
		return mmSet.funcSet(ctx, key, value)
	}
	mmSet.t.Fatalf("Unexpected call to ClientMock.Set. %v %v %v", ctx, key, value)
	return
}

// SetAfterCounter returns a count of finished ClientMock.Set invocations
func (mmSet *ClientMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of ClientMock.Set invocations
func (mmSet *ClientMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mClientMockSet) Calls() []*ClientMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*ClientMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *ClientMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Set at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Set at\n%s", m.SetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Set at\n%s with params: %#v", m.SetMock.defaultExpectation.expectationOrigins.origin, *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Set at\n%s", m.funcSetOrigin)
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Set at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), m.SetMock.expectedInvocationsOrigin, afterSetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDelInspect()

			m.MinimockExistsInspect()

			m.MinimockExpireInspect()

			m.MinimockGetInspect()

			m.MinimockHGetAllInspect()

			m.MinimockHSetInspect()

			m.MinimockHSetFieldInspect()

			m.MinimockPingInspect()

			m.MinimockSetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDelDone() &&
		m.MinimockExistsDone() &&
		m.MinimockExpireDone() &&
		m.MinimockGetDone() &&
		m.MinimockHGetAllDone() &&
		m.MinimockHSetDone() &&
		m.MinimockHSetFieldDone() &&
		m.MinimockPingDone() &&
		m.MinimockSetDone()
}
