// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/vl-usp/water_bot/internal/storage.User -o user_minimock.go -n UserMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/vl-usp/water_bot/internal/model"
)

// UserMock implements mm_storage.User
type UserMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, user model.User) (i1 int64, err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, user model.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserMockCreateUser

	funcCreateUserParams          func(ctx context.Context, params model.UserParams) (i1 int64, err error)
	funcCreateUserParamsOrigin    string
	inspectFuncCreateUserParams   func(ctx context.Context, params model.UserParams)
	afterCreateUserParamsCounter  uint64
	beforeCreateUserParamsCounter uint64
	CreateUserParamsMock          mUserMockCreateUserParams

	funcGetFullUserParams          func(ctx context.Context, params model.UserParams) (up1 *model.UserParams, err error)
	funcGetFullUserParamsOrigin    string
	inspectFuncGetFullUserParams   func(ctx context.Context, params model.UserParams)
	afterGetFullUserParamsCounter  uint64
	beforeGetFullUserParamsCounter uint64
	GetFullUserParamsMock          mUserMockGetFullUserParams

	funcGetUser          func(ctx context.Context, id int64) (up1 *model.User, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, id int64)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mUserMockGetUser

	funcUpdateUser          func(ctx context.Context, id int64, user model.User) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, id int64, user model.User)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mUserMockUpdateUser

	funcUpdateUserParams          func(ctx context.Context, id int64, params model.UserParams) (err error)
	funcUpdateUserParamsOrigin    string
	inspectFuncUpdateUserParams   func(ctx context.Context, id int64, params model.UserParams)
	afterUpdateUserParamsCounter  uint64
	beforeUpdateUserParamsCounter uint64
	UpdateUserParamsMock          mUserMockUpdateUserParams
}

// NewUserMock returns a mock for mm_storage.User
func NewUserMock(t minimock.Tester) *UserMock {
	m := &UserMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mUserMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserMockCreateUserParams{}

	m.CreateUserParamsMock = mUserMockCreateUserParams{mock: m}
	m.CreateUserParamsMock.callArgs = []*UserMockCreateUserParamsParams{}

	m.GetFullUserParamsMock = mUserMockGetFullUserParams{mock: m}
	m.GetFullUserParamsMock.callArgs = []*UserMockGetFullUserParamsParams{}

	m.GetUserMock = mUserMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*UserMockGetUserParams{}

	m.UpdateUserMock = mUserMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*UserMockUpdateUserParams{}

	m.UpdateUserParamsMock = mUserMockUpdateUserParams{mock: m}
	m.UpdateUserParamsMock.callArgs = []*UserMockUpdateUserParamsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserMockCreateUser struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockCreateUserExpectation
	expectations       []*UserMockCreateUserExpectation

	callArgs []*UserMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockCreateUserExpectation specifies expectation struct of the User.CreateUser
type UserMockCreateUserExpectation struct {
	mock               *UserMock
	params             *UserMockCreateUserParams
	paramPtrs          *UserMockCreateUserParamPtrs
	expectationOrigins UserMockCreateUserExpectationOrigins
	results            *UserMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserMockCreateUserParams contains parameters of the User.CreateUser
type UserMockCreateUserParams struct {
	ctx  context.Context
	user model.User
}

// UserMockCreateUserParamPtrs contains pointers to parameters of the User.CreateUser
type UserMockCreateUserParamPtrs struct {
	ctx  *context.Context
	user *model.User
}

// UserMockCreateUserResults contains results of the User.CreateUser
type UserMockCreateUserResults struct {
	i1  int64
	err error
}

// UserMockCreateUserOrigins contains origins of expectations of the User.CreateUser
type UserMockCreateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserMockCreateUser) Optional() *mUserMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for User.CreateUser
func (mmCreateUser *mUserMockCreateUser) Expect(ctx context.Context, user model.User) *mUserMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &UserMockCreateUserParams{ctx, user}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for User.CreateUser
func (mmCreateUser *mUserMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectUserParam2 sets up expected param user for User.CreateUser
func (mmCreateUser *mUserMockCreateUser) ExpectUserParam2(user model.User) *mUserMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user
	mmCreateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the User.CreateUser
func (mmCreateUser *mUserMockCreateUser) Inspect(f func(ctx context.Context, user model.User)) *mUserMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by User.CreateUser
func (mmCreateUser *mUserMockCreateUser) Return(i1 int64, err error) *UserMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserMockCreateUserResults{i1, err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the User.CreateUser method
func (mmCreateUser *mUserMockCreateUser) Set(f func(ctx context.Context, user model.User) (i1 int64, err error)) *UserMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the User.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the User.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the User.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserMockCreateUser) When(ctx context.Context, user model.User) *UserMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	expectation := &UserMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &UserMockCreateUserParams{ctx, user},
		expectationOrigins: UserMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up User.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserMockCreateUserExpectation) Then(i1 int64, err error) *UserMock {
	e.results = &UserMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times User.CreateUser should be invoked
func (mmCreateUser *mUserMockCreateUser) Times(n uint64) *mUserMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of UserMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mUserMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_storage.User
func (mmCreateUser *UserMock) CreateUser(ctx context.Context, user model.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, user)
	}

	mm_params := UserMockCreateUserParams{ctx, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := UserMockCreateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("UserMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("UserMock.CreateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UserMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserMock.CreateUser. %v %v", ctx, user)
	return
}

// CreateUserAfterCounter returns a count of finished UserMock.CreateUser invocations
func (mmCreateUser *UserMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserMock.CreateUser invocations
func (mmCreateUser *UserMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserMockCreateUser) Calls() []*UserMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to UserMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mUserMockCreateUserParams struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockCreateUserParamsExpectation
	expectations       []*UserMockCreateUserParamsExpectation

	callArgs []*UserMockCreateUserParamsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockCreateUserParamsExpectation specifies expectation struct of the User.CreateUserParams
type UserMockCreateUserParamsExpectation struct {
	mock               *UserMock
	params             *UserMockCreateUserParamsParams
	paramPtrs          *UserMockCreateUserParamsParamPtrs
	expectationOrigins UserMockCreateUserParamsExpectationOrigins
	results            *UserMockCreateUserParamsResults
	returnOrigin       string
	Counter            uint64
}

// UserMockCreateUserParamsParams contains parameters of the User.CreateUserParams
type UserMockCreateUserParamsParams struct {
	ctx    context.Context
	params model.UserParams
}

// UserMockCreateUserParamsParamPtrs contains pointers to parameters of the User.CreateUserParams
type UserMockCreateUserParamsParamPtrs struct {
	ctx    *context.Context
	params *model.UserParams
}

// UserMockCreateUserParamsResults contains results of the User.CreateUserParams
type UserMockCreateUserParamsResults struct {
	i1  int64
	err error
}

// UserMockCreateUserParamsOrigins contains origins of expectations of the User.CreateUserParams
type UserMockCreateUserParamsExpectationOrigins struct {
	origin       string
	originCtx    string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUserParams *mUserMockCreateUserParams) Optional() *mUserMockCreateUserParams {
	mmCreateUserParams.optional = true
	return mmCreateUserParams
}

// Expect sets up expected params for User.CreateUserParams
func (mmCreateUserParams *mUserMockCreateUserParams) Expect(ctx context.Context, params model.UserParams) *mUserMockCreateUserParams {
	if mmCreateUserParams.mock.funcCreateUserParams != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Set")
	}

	if mmCreateUserParams.defaultExpectation == nil {
		mmCreateUserParams.defaultExpectation = &UserMockCreateUserParamsExpectation{}
	}

	if mmCreateUserParams.defaultExpectation.paramPtrs != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by ExpectParams functions")
	}

	mmCreateUserParams.defaultExpectation.params = &UserMockCreateUserParamsParams{ctx, params}
	mmCreateUserParams.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUserParams.expectations {
		if minimock.Equal(e.params, mmCreateUserParams.defaultExpectation.params) {
			mmCreateUserParams.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUserParams.defaultExpectation.params)
		}
	}

	return mmCreateUserParams
}

// ExpectCtxParam1 sets up expected param ctx for User.CreateUserParams
func (mmCreateUserParams *mUserMockCreateUserParams) ExpectCtxParam1(ctx context.Context) *mUserMockCreateUserParams {
	if mmCreateUserParams.mock.funcCreateUserParams != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Set")
	}

	if mmCreateUserParams.defaultExpectation == nil {
		mmCreateUserParams.defaultExpectation = &UserMockCreateUserParamsExpectation{}
	}

	if mmCreateUserParams.defaultExpectation.params != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Expect")
	}

	if mmCreateUserParams.defaultExpectation.paramPtrs == nil {
		mmCreateUserParams.defaultExpectation.paramPtrs = &UserMockCreateUserParamsParamPtrs{}
	}
	mmCreateUserParams.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUserParams.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUserParams
}

// ExpectParamsParam2 sets up expected param params for User.CreateUserParams
func (mmCreateUserParams *mUserMockCreateUserParams) ExpectParamsParam2(params model.UserParams) *mUserMockCreateUserParams {
	if mmCreateUserParams.mock.funcCreateUserParams != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Set")
	}

	if mmCreateUserParams.defaultExpectation == nil {
		mmCreateUserParams.defaultExpectation = &UserMockCreateUserParamsExpectation{}
	}

	if mmCreateUserParams.defaultExpectation.params != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Expect")
	}

	if mmCreateUserParams.defaultExpectation.paramPtrs == nil {
		mmCreateUserParams.defaultExpectation.paramPtrs = &UserMockCreateUserParamsParamPtrs{}
	}
	mmCreateUserParams.defaultExpectation.paramPtrs.params = &params
	mmCreateUserParams.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmCreateUserParams
}

// Inspect accepts an inspector function that has same arguments as the User.CreateUserParams
func (mmCreateUserParams *mUserMockCreateUserParams) Inspect(f func(ctx context.Context, params model.UserParams)) *mUserMockCreateUserParams {
	if mmCreateUserParams.mock.inspectFuncCreateUserParams != nil {
		mmCreateUserParams.mock.t.Fatalf("Inspect function is already set for UserMock.CreateUserParams")
	}

	mmCreateUserParams.mock.inspectFuncCreateUserParams = f

	return mmCreateUserParams
}

// Return sets up results that will be returned by User.CreateUserParams
func (mmCreateUserParams *mUserMockCreateUserParams) Return(i1 int64, err error) *UserMock {
	if mmCreateUserParams.mock.funcCreateUserParams != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Set")
	}

	if mmCreateUserParams.defaultExpectation == nil {
		mmCreateUserParams.defaultExpectation = &UserMockCreateUserParamsExpectation{mock: mmCreateUserParams.mock}
	}
	mmCreateUserParams.defaultExpectation.results = &UserMockCreateUserParamsResults{i1, err}
	mmCreateUserParams.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUserParams.mock
}

// Set uses given function f to mock the User.CreateUserParams method
func (mmCreateUserParams *mUserMockCreateUserParams) Set(f func(ctx context.Context, params model.UserParams) (i1 int64, err error)) *UserMock {
	if mmCreateUserParams.defaultExpectation != nil {
		mmCreateUserParams.mock.t.Fatalf("Default expectation is already set for the User.CreateUserParams method")
	}

	if len(mmCreateUserParams.expectations) > 0 {
		mmCreateUserParams.mock.t.Fatalf("Some expectations are already set for the User.CreateUserParams method")
	}

	mmCreateUserParams.mock.funcCreateUserParams = f
	mmCreateUserParams.mock.funcCreateUserParamsOrigin = minimock.CallerInfo(1)
	return mmCreateUserParams.mock
}

// When sets expectation for the User.CreateUserParams which will trigger the result defined by the following
// Then helper
func (mmCreateUserParams *mUserMockCreateUserParams) When(ctx context.Context, params model.UserParams) *UserMockCreateUserParamsExpectation {
	if mmCreateUserParams.mock.funcCreateUserParams != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Set")
	}

	expectation := &UserMockCreateUserParamsExpectation{
		mock:               mmCreateUserParams.mock,
		params:             &UserMockCreateUserParamsParams{ctx, params},
		expectationOrigins: UserMockCreateUserParamsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUserParams.expectations = append(mmCreateUserParams.expectations, expectation)
	return expectation
}

// Then sets up User.CreateUserParams return parameters for the expectation previously defined by the When method
func (e *UserMockCreateUserParamsExpectation) Then(i1 int64, err error) *UserMock {
	e.results = &UserMockCreateUserParamsResults{i1, err}
	return e.mock
}

// Times sets number of times User.CreateUserParams should be invoked
func (mmCreateUserParams *mUserMockCreateUserParams) Times(n uint64) *mUserMockCreateUserParams {
	if n == 0 {
		mmCreateUserParams.mock.t.Fatalf("Times of UserMock.CreateUserParams mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUserParams.expectedInvocations, n)
	mmCreateUserParams.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUserParams
}

func (mmCreateUserParams *mUserMockCreateUserParams) invocationsDone() bool {
	if len(mmCreateUserParams.expectations) == 0 && mmCreateUserParams.defaultExpectation == nil && mmCreateUserParams.mock.funcCreateUserParams == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUserParams.mock.afterCreateUserParamsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUserParams.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUserParams implements mm_storage.User
func (mmCreateUserParams *UserMock) CreateUserParams(ctx context.Context, params model.UserParams) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUserParams.beforeCreateUserParamsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUserParams.afterCreateUserParamsCounter, 1)

	mmCreateUserParams.t.Helper()

	if mmCreateUserParams.inspectFuncCreateUserParams != nil {
		mmCreateUserParams.inspectFuncCreateUserParams(ctx, params)
	}

	mm_params := UserMockCreateUserParamsParams{ctx, params}

	// Record call args
	mmCreateUserParams.CreateUserParamsMock.mutex.Lock()
	mmCreateUserParams.CreateUserParamsMock.callArgs = append(mmCreateUserParams.CreateUserParamsMock.callArgs, &mm_params)
	mmCreateUserParams.CreateUserParamsMock.mutex.Unlock()

	for _, e := range mmCreateUserParams.CreateUserParamsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUserParams.CreateUserParamsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUserParams.CreateUserParamsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUserParams.CreateUserParamsMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUserParams.CreateUserParamsMock.defaultExpectation.paramPtrs

		mm_got := UserMockCreateUserParamsParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUserParams.t.Errorf("UserMock.CreateUserParams got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUserParams.CreateUserParamsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmCreateUserParams.t.Errorf("UserMock.CreateUserParams got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUserParams.CreateUserParamsMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUserParams.t.Errorf("UserMock.CreateUserParams got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUserParams.CreateUserParamsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUserParams.CreateUserParamsMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUserParams.t.Fatal("No results are set for the UserMock.CreateUserParams")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUserParams.funcCreateUserParams != nil {
		return mmCreateUserParams.funcCreateUserParams(ctx, params)
	}
	mmCreateUserParams.t.Fatalf("Unexpected call to UserMock.CreateUserParams. %v %v", ctx, params)
	return
}

// CreateUserParamsAfterCounter returns a count of finished UserMock.CreateUserParams invocations
func (mmCreateUserParams *UserMock) CreateUserParamsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUserParams.afterCreateUserParamsCounter)
}

// CreateUserParamsBeforeCounter returns a count of UserMock.CreateUserParams invocations
func (mmCreateUserParams *UserMock) CreateUserParamsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUserParams.beforeCreateUserParamsCounter)
}

// Calls returns a list of arguments used in each call to UserMock.CreateUserParams.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUserParams *mUserMockCreateUserParams) Calls() []*UserMockCreateUserParamsParams {
	mmCreateUserParams.mutex.RLock()

	argCopy := make([]*UserMockCreateUserParamsParams, len(mmCreateUserParams.callArgs))
	copy(argCopy, mmCreateUserParams.callArgs)

	mmCreateUserParams.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserParamsDone returns true if the count of the CreateUserParams invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockCreateUserParamsDone() bool {
	if m.CreateUserParamsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserParamsMock.invocationsDone()
}

// MinimockCreateUserParamsInspect logs each unmet expectation
func (m *UserMock) MinimockCreateUserParamsInspect() {
	for _, e := range m.CreateUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.CreateUserParams at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserParamsCounter := mm_atomic.LoadUint64(&m.afterCreateUserParamsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserParamsMock.defaultExpectation != nil && afterCreateUserParamsCounter < 1 {
		if m.CreateUserParamsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.CreateUserParams at\n%s", m.CreateUserParamsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.CreateUserParams at\n%s with params: %#v", m.CreateUserParamsMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserParamsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUserParams != nil && afterCreateUserParamsCounter < 1 {
		m.t.Errorf("Expected call to UserMock.CreateUserParams at\n%s", m.funcCreateUserParamsOrigin)
	}

	if !m.CreateUserParamsMock.invocationsDone() && afterCreateUserParamsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.CreateUserParams at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserParamsMock.expectedInvocations), m.CreateUserParamsMock.expectedInvocationsOrigin, afterCreateUserParamsCounter)
	}
}

type mUserMockGetFullUserParams struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockGetFullUserParamsExpectation
	expectations       []*UserMockGetFullUserParamsExpectation

	callArgs []*UserMockGetFullUserParamsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockGetFullUserParamsExpectation specifies expectation struct of the User.GetFullUserParams
type UserMockGetFullUserParamsExpectation struct {
	mock               *UserMock
	params             *UserMockGetFullUserParamsParams
	paramPtrs          *UserMockGetFullUserParamsParamPtrs
	expectationOrigins UserMockGetFullUserParamsExpectationOrigins
	results            *UserMockGetFullUserParamsResults
	returnOrigin       string
	Counter            uint64
}

// UserMockGetFullUserParamsParams contains parameters of the User.GetFullUserParams
type UserMockGetFullUserParamsParams struct {
	ctx    context.Context
	params model.UserParams
}

// UserMockGetFullUserParamsParamPtrs contains pointers to parameters of the User.GetFullUserParams
type UserMockGetFullUserParamsParamPtrs struct {
	ctx    *context.Context
	params *model.UserParams
}

// UserMockGetFullUserParamsResults contains results of the User.GetFullUserParams
type UserMockGetFullUserParamsResults struct {
	up1 *model.UserParams
	err error
}

// UserMockGetFullUserParamsOrigins contains origins of expectations of the User.GetFullUserParams
type UserMockGetFullUserParamsExpectationOrigins struct {
	origin       string
	originCtx    string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFullUserParams *mUserMockGetFullUserParams) Optional() *mUserMockGetFullUserParams {
	mmGetFullUserParams.optional = true
	return mmGetFullUserParams
}

// Expect sets up expected params for User.GetFullUserParams
func (mmGetFullUserParams *mUserMockGetFullUserParams) Expect(ctx context.Context, params model.UserParams) *mUserMockGetFullUserParams {
	if mmGetFullUserParams.mock.funcGetFullUserParams != nil {
		mmGetFullUserParams.mock.t.Fatalf("UserMock.GetFullUserParams mock is already set by Set")
	}

	if mmGetFullUserParams.defaultExpectation == nil {
		mmGetFullUserParams.defaultExpectation = &UserMockGetFullUserParamsExpectation{}
	}

	if mmGetFullUserParams.defaultExpectation.paramPtrs != nil {
		mmGetFullUserParams.mock.t.Fatalf("UserMock.GetFullUserParams mock is already set by ExpectParams functions")
	}

	mmGetFullUserParams.defaultExpectation.params = &UserMockGetFullUserParamsParams{ctx, params}
	mmGetFullUserParams.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFullUserParams.expectations {
		if minimock.Equal(e.params, mmGetFullUserParams.defaultExpectation.params) {
			mmGetFullUserParams.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFullUserParams.defaultExpectation.params)
		}
	}

	return mmGetFullUserParams
}

// ExpectCtxParam1 sets up expected param ctx for User.GetFullUserParams
func (mmGetFullUserParams *mUserMockGetFullUserParams) ExpectCtxParam1(ctx context.Context) *mUserMockGetFullUserParams {
	if mmGetFullUserParams.mock.funcGetFullUserParams != nil {
		mmGetFullUserParams.mock.t.Fatalf("UserMock.GetFullUserParams mock is already set by Set")
	}

	if mmGetFullUserParams.defaultExpectation == nil {
		mmGetFullUserParams.defaultExpectation = &UserMockGetFullUserParamsExpectation{}
	}

	if mmGetFullUserParams.defaultExpectation.params != nil {
		mmGetFullUserParams.mock.t.Fatalf("UserMock.GetFullUserParams mock is already set by Expect")
	}

	if mmGetFullUserParams.defaultExpectation.paramPtrs == nil {
		mmGetFullUserParams.defaultExpectation.paramPtrs = &UserMockGetFullUserParamsParamPtrs{}
	}
	mmGetFullUserParams.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFullUserParams.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFullUserParams
}

// ExpectParamsParam2 sets up expected param params for User.GetFullUserParams
func (mmGetFullUserParams *mUserMockGetFullUserParams) ExpectParamsParam2(params model.UserParams) *mUserMockGetFullUserParams {
	if mmGetFullUserParams.mock.funcGetFullUserParams != nil {
		mmGetFullUserParams.mock.t.Fatalf("UserMock.GetFullUserParams mock is already set by Set")
	}

	if mmGetFullUserParams.defaultExpectation == nil {
		mmGetFullUserParams.defaultExpectation = &UserMockGetFullUserParamsExpectation{}
	}

	if mmGetFullUserParams.defaultExpectation.params != nil {
		mmGetFullUserParams.mock.t.Fatalf("UserMock.GetFullUserParams mock is already set by Expect")
	}

	if mmGetFullUserParams.defaultExpectation.paramPtrs == nil {
		mmGetFullUserParams.defaultExpectation.paramPtrs = &UserMockGetFullUserParamsParamPtrs{}
	}
	mmGetFullUserParams.defaultExpectation.paramPtrs.params = &params
	mmGetFullUserParams.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmGetFullUserParams
}

// Inspect accepts an inspector function that has same arguments as the User.GetFullUserParams
func (mmGetFullUserParams *mUserMockGetFullUserParams) Inspect(f func(ctx context.Context, params model.UserParams)) *mUserMockGetFullUserParams {
	if mmGetFullUserParams.mock.inspectFuncGetFullUserParams != nil {
		mmGetFullUserParams.mock.t.Fatalf("Inspect function is already set for UserMock.GetFullUserParams")
	}

	mmGetFullUserParams.mock.inspectFuncGetFullUserParams = f

	return mmGetFullUserParams
}

// Return sets up results that will be returned by User.GetFullUserParams
func (mmGetFullUserParams *mUserMockGetFullUserParams) Return(up1 *model.UserParams, err error) *UserMock {
	if mmGetFullUserParams.mock.funcGetFullUserParams != nil {
		mmGetFullUserParams.mock.t.Fatalf("UserMock.GetFullUserParams mock is already set by Set")
	}

	if mmGetFullUserParams.defaultExpectation == nil {
		mmGetFullUserParams.defaultExpectation = &UserMockGetFullUserParamsExpectation{mock: mmGetFullUserParams.mock}
	}
	mmGetFullUserParams.defaultExpectation.results = &UserMockGetFullUserParamsResults{up1, err}
	mmGetFullUserParams.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFullUserParams.mock
}

// Set uses given function f to mock the User.GetFullUserParams method
func (mmGetFullUserParams *mUserMockGetFullUserParams) Set(f func(ctx context.Context, params model.UserParams) (up1 *model.UserParams, err error)) *UserMock {
	if mmGetFullUserParams.defaultExpectation != nil {
		mmGetFullUserParams.mock.t.Fatalf("Default expectation is already set for the User.GetFullUserParams method")
	}

	if len(mmGetFullUserParams.expectations) > 0 {
		mmGetFullUserParams.mock.t.Fatalf("Some expectations are already set for the User.GetFullUserParams method")
	}

	mmGetFullUserParams.mock.funcGetFullUserParams = f
	mmGetFullUserParams.mock.funcGetFullUserParamsOrigin = minimock.CallerInfo(1)
	return mmGetFullUserParams.mock
}

// When sets expectation for the User.GetFullUserParams which will trigger the result defined by the following
// Then helper
func (mmGetFullUserParams *mUserMockGetFullUserParams) When(ctx context.Context, params model.UserParams) *UserMockGetFullUserParamsExpectation {
	if mmGetFullUserParams.mock.funcGetFullUserParams != nil {
		mmGetFullUserParams.mock.t.Fatalf("UserMock.GetFullUserParams mock is already set by Set")
	}

	expectation := &UserMockGetFullUserParamsExpectation{
		mock:               mmGetFullUserParams.mock,
		params:             &UserMockGetFullUserParamsParams{ctx, params},
		expectationOrigins: UserMockGetFullUserParamsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFullUserParams.expectations = append(mmGetFullUserParams.expectations, expectation)
	return expectation
}

// Then sets up User.GetFullUserParams return parameters for the expectation previously defined by the When method
func (e *UserMockGetFullUserParamsExpectation) Then(up1 *model.UserParams, err error) *UserMock {
	e.results = &UserMockGetFullUserParamsResults{up1, err}
	return e.mock
}

// Times sets number of times User.GetFullUserParams should be invoked
func (mmGetFullUserParams *mUserMockGetFullUserParams) Times(n uint64) *mUserMockGetFullUserParams {
	if n == 0 {
		mmGetFullUserParams.mock.t.Fatalf("Times of UserMock.GetFullUserParams mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFullUserParams.expectedInvocations, n)
	mmGetFullUserParams.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFullUserParams
}

func (mmGetFullUserParams *mUserMockGetFullUserParams) invocationsDone() bool {
	if len(mmGetFullUserParams.expectations) == 0 && mmGetFullUserParams.defaultExpectation == nil && mmGetFullUserParams.mock.funcGetFullUserParams == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFullUserParams.mock.afterGetFullUserParamsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFullUserParams.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFullUserParams implements mm_storage.User
func (mmGetFullUserParams *UserMock) GetFullUserParams(ctx context.Context, params model.UserParams) (up1 *model.UserParams, err error) {
	mm_atomic.AddUint64(&mmGetFullUserParams.beforeGetFullUserParamsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFullUserParams.afterGetFullUserParamsCounter, 1)

	mmGetFullUserParams.t.Helper()

	if mmGetFullUserParams.inspectFuncGetFullUserParams != nil {
		mmGetFullUserParams.inspectFuncGetFullUserParams(ctx, params)
	}

	mm_params := UserMockGetFullUserParamsParams{ctx, params}

	// Record call args
	mmGetFullUserParams.GetFullUserParamsMock.mutex.Lock()
	mmGetFullUserParams.GetFullUserParamsMock.callArgs = append(mmGetFullUserParams.GetFullUserParamsMock.callArgs, &mm_params)
	mmGetFullUserParams.GetFullUserParamsMock.mutex.Unlock()

	for _, e := range mmGetFullUserParams.GetFullUserParamsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetFullUserParams.GetFullUserParamsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFullUserParams.GetFullUserParamsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFullUserParams.GetFullUserParamsMock.defaultExpectation.params
		mm_want_ptrs := mmGetFullUserParams.GetFullUserParamsMock.defaultExpectation.paramPtrs

		mm_got := UserMockGetFullUserParamsParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFullUserParams.t.Errorf("UserMock.GetFullUserParams got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFullUserParams.GetFullUserParamsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmGetFullUserParams.t.Errorf("UserMock.GetFullUserParams got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFullUserParams.GetFullUserParamsMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFullUserParams.t.Errorf("UserMock.GetFullUserParams got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFullUserParams.GetFullUserParamsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFullUserParams.GetFullUserParamsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFullUserParams.t.Fatal("No results are set for the UserMock.GetFullUserParams")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetFullUserParams.funcGetFullUserParams != nil {
		return mmGetFullUserParams.funcGetFullUserParams(ctx, params)
	}
	mmGetFullUserParams.t.Fatalf("Unexpected call to UserMock.GetFullUserParams. %v %v", ctx, params)
	return
}

// GetFullUserParamsAfterCounter returns a count of finished UserMock.GetFullUserParams invocations
func (mmGetFullUserParams *UserMock) GetFullUserParamsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFullUserParams.afterGetFullUserParamsCounter)
}

// GetFullUserParamsBeforeCounter returns a count of UserMock.GetFullUserParams invocations
func (mmGetFullUserParams *UserMock) GetFullUserParamsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFullUserParams.beforeGetFullUserParamsCounter)
}

// Calls returns a list of arguments used in each call to UserMock.GetFullUserParams.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFullUserParams *mUserMockGetFullUserParams) Calls() []*UserMockGetFullUserParamsParams {
	mmGetFullUserParams.mutex.RLock()

	argCopy := make([]*UserMockGetFullUserParamsParams, len(mmGetFullUserParams.callArgs))
	copy(argCopy, mmGetFullUserParams.callArgs)

	mmGetFullUserParams.mutex.RUnlock()

	return argCopy
}

// MinimockGetFullUserParamsDone returns true if the count of the GetFullUserParams invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockGetFullUserParamsDone() bool {
	if m.GetFullUserParamsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFullUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFullUserParamsMock.invocationsDone()
}

// MinimockGetFullUserParamsInspect logs each unmet expectation
func (m *UserMock) MinimockGetFullUserParamsInspect() {
	for _, e := range m.GetFullUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.GetFullUserParams at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFullUserParamsCounter := mm_atomic.LoadUint64(&m.afterGetFullUserParamsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFullUserParamsMock.defaultExpectation != nil && afterGetFullUserParamsCounter < 1 {
		if m.GetFullUserParamsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.GetFullUserParams at\n%s", m.GetFullUserParamsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.GetFullUserParams at\n%s with params: %#v", m.GetFullUserParamsMock.defaultExpectation.expectationOrigins.origin, *m.GetFullUserParamsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFullUserParams != nil && afterGetFullUserParamsCounter < 1 {
		m.t.Errorf("Expected call to UserMock.GetFullUserParams at\n%s", m.funcGetFullUserParamsOrigin)
	}

	if !m.GetFullUserParamsMock.invocationsDone() && afterGetFullUserParamsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.GetFullUserParams at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFullUserParamsMock.expectedInvocations), m.GetFullUserParamsMock.expectedInvocationsOrigin, afterGetFullUserParamsCounter)
	}
}

type mUserMockGetUser struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockGetUserExpectation
	expectations       []*UserMockGetUserExpectation

	callArgs []*UserMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockGetUserExpectation specifies expectation struct of the User.GetUser
type UserMockGetUserExpectation struct {
	mock               *UserMock
	params             *UserMockGetUserParams
	paramPtrs          *UserMockGetUserParamPtrs
	expectationOrigins UserMockGetUserExpectationOrigins
	results            *UserMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// UserMockGetUserParams contains parameters of the User.GetUser
type UserMockGetUserParams struct {
	ctx context.Context
	id  int64
}

// UserMockGetUserParamPtrs contains pointers to parameters of the User.GetUser
type UserMockGetUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserMockGetUserResults contains results of the User.GetUser
type UserMockGetUserResults struct {
	up1 *model.User
	err error
}

// UserMockGetUserOrigins contains origins of expectations of the User.GetUser
type UserMockGetUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mUserMockGetUser) Optional() *mUserMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for User.GetUser
func (mmGetUser *mUserMockGetUser) Expect(ctx context.Context, id int64) *mUserMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &UserMockGetUserParams{ctx, id}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for User.GetUser
func (mmGetUser *mUserMockGetUser) ExpectCtxParam1(ctx context.Context) *mUserMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectIdParam2 sets up expected param id for User.GetUser
func (mmGetUser *mUserMockGetUser) ExpectIdParam2(id int64) *mUserMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.id = &id
	mmGetUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the User.GetUser
func (mmGetUser *mUserMockGetUser) Inspect(f func(ctx context.Context, id int64)) *mUserMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for UserMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by User.GetUser
func (mmGetUser *mUserMockGetUser) Return(up1 *model.User, err error) *UserMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &UserMockGetUserResults{up1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the User.GetUser method
func (mmGetUser *mUserMockGetUser) Set(f func(ctx context.Context, id int64) (up1 *model.User, err error)) *UserMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the User.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the User.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the User.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mUserMockGetUser) When(ctx context.Context, id int64) *UserMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	expectation := &UserMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &UserMockGetUserParams{ctx, id},
		expectationOrigins: UserMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up User.GetUser return parameters for the expectation previously defined by the When method
func (e *UserMockGetUserExpectation) Then(up1 *model.User, err error) *UserMock {
	e.results = &UserMockGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times User.GetUser should be invoked
func (mmGetUser *mUserMockGetUser) Times(n uint64) *mUserMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of UserMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mUserMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_storage.User
func (mmGetUser *UserMock) GetUser(ctx context.Context, id int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, id)
	}

	mm_params := UserMockGetUserParams{ctx, id}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := UserMockGetUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("UserMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUser.t.Errorf("UserMock.GetUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("UserMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the UserMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, id)
	}
	mmGetUser.t.Fatalf("Unexpected call to UserMock.GetUser. %v %v", ctx, id)
	return
}

// GetUserAfterCounter returns a count of finished UserMock.GetUser invocations
func (mmGetUser *UserMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of UserMock.GetUser invocations
func (mmGetUser *UserMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to UserMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mUserMockGetUser) Calls() []*UserMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*UserMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *UserMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to UserMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mUserMockUpdateUser struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockUpdateUserExpectation
	expectations       []*UserMockUpdateUserExpectation

	callArgs []*UserMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockUpdateUserExpectation specifies expectation struct of the User.UpdateUser
type UserMockUpdateUserExpectation struct {
	mock               *UserMock
	params             *UserMockUpdateUserParams
	paramPtrs          *UserMockUpdateUserParamPtrs
	expectationOrigins UserMockUpdateUserExpectationOrigins
	results            *UserMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserMockUpdateUserParams contains parameters of the User.UpdateUser
type UserMockUpdateUserParams struct {
	ctx  context.Context
	id   int64
	user model.User
}

// UserMockUpdateUserParamPtrs contains pointers to parameters of the User.UpdateUser
type UserMockUpdateUserParamPtrs struct {
	ctx  *context.Context
	id   *int64
	user *model.User
}

// UserMockUpdateUserResults contains results of the User.UpdateUser
type UserMockUpdateUserResults struct {
	err error
}

// UserMockUpdateUserOrigins contains origins of expectations of the User.UpdateUser
type UserMockUpdateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originId   string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mUserMockUpdateUser) Optional() *mUserMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for User.UpdateUser
func (mmUpdateUser *mUserMockUpdateUser) Expect(ctx context.Context, id int64, user model.User) *mUserMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &UserMockUpdateUserParams{ctx, id, user}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for User.UpdateUser
func (mmUpdateUser *mUserMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mUserMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectIdParam2 sets up expected param id for User.UpdateUser
func (mmUpdateUser *mUserMockUpdateUser) ExpectIdParam2(id int64) *mUserMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.id = &id
	mmUpdateUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectUserParam3 sets up expected param user for User.UpdateUser
func (mmUpdateUser *mUserMockUpdateUser) ExpectUserParam3(user model.User) *mUserMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.user = &user
	mmUpdateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the User.UpdateUser
func (mmUpdateUser *mUserMockUpdateUser) Inspect(f func(ctx context.Context, id int64, user model.User)) *mUserMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for UserMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by User.UpdateUser
func (mmUpdateUser *mUserMockUpdateUser) Return(err error) *UserMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &UserMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the User.UpdateUser method
func (mmUpdateUser *mUserMockUpdateUser) Set(f func(ctx context.Context, id int64, user model.User) (err error)) *UserMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the User.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the User.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the User.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mUserMockUpdateUser) When(ctx context.Context, id int64, user model.User) *UserMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Set")
	}

	expectation := &UserMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &UserMockUpdateUserParams{ctx, id, user},
		expectationOrigins: UserMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up User.UpdateUser return parameters for the expectation previously defined by the When method
func (e *UserMockUpdateUserExpectation) Then(err error) *UserMock {
	e.results = &UserMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times User.UpdateUser should be invoked
func (mmUpdateUser *mUserMockUpdateUser) Times(n uint64) *mUserMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of UserMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mUserMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_storage.User
func (mmUpdateUser *UserMock) UpdateUser(ctx context.Context, id int64, user model.User) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, id, user)
	}

	mm_params := UserMockUpdateUserParams{ctx, id, user}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := UserMockUpdateUserParams{ctx, id, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("UserMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateUser.t.Errorf("UserMock.UpdateUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmUpdateUser.t.Errorf("UserMock.UpdateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("UserMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the UserMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, id, user)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to UserMock.UpdateUser. %v %v %v", ctx, id, user)
	return
}

// UpdateUserAfterCounter returns a count of finished UserMock.UpdateUser invocations
func (mmUpdateUser *UserMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of UserMock.UpdateUser invocations
func (mmUpdateUser *UserMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to UserMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mUserMockUpdateUser) Calls() []*UserMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*UserMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *UserMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to UserMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

type mUserMockUpdateUserParams struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockUpdateUserParamsExpectation
	expectations       []*UserMockUpdateUserParamsExpectation

	callArgs []*UserMockUpdateUserParamsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockUpdateUserParamsExpectation specifies expectation struct of the User.UpdateUserParams
type UserMockUpdateUserParamsExpectation struct {
	mock               *UserMock
	params             *UserMockUpdateUserParamsParams
	paramPtrs          *UserMockUpdateUserParamsParamPtrs
	expectationOrigins UserMockUpdateUserParamsExpectationOrigins
	results            *UserMockUpdateUserParamsResults
	returnOrigin       string
	Counter            uint64
}

// UserMockUpdateUserParamsParams contains parameters of the User.UpdateUserParams
type UserMockUpdateUserParamsParams struct {
	ctx    context.Context
	id     int64
	params model.UserParams
}

// UserMockUpdateUserParamsParamPtrs contains pointers to parameters of the User.UpdateUserParams
type UserMockUpdateUserParamsParamPtrs struct {
	ctx    *context.Context
	id     *int64
	params *model.UserParams
}

// UserMockUpdateUserParamsResults contains results of the User.UpdateUserParams
type UserMockUpdateUserParamsResults struct {
	err error
}

// UserMockUpdateUserParamsOrigins contains origins of expectations of the User.UpdateUserParams
type UserMockUpdateUserParamsExpectationOrigins struct {
	origin       string
	originCtx    string
	originId     string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUserParams *mUserMockUpdateUserParams) Optional() *mUserMockUpdateUserParams {
	mmUpdateUserParams.optional = true
	return mmUpdateUserParams
}

// Expect sets up expected params for User.UpdateUserParams
func (mmUpdateUserParams *mUserMockUpdateUserParams) Expect(ctx context.Context, id int64, params model.UserParams) *mUserMockUpdateUserParams {
	if mmUpdateUserParams.mock.funcUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Set")
	}

	if mmUpdateUserParams.defaultExpectation == nil {
		mmUpdateUserParams.defaultExpectation = &UserMockUpdateUserParamsExpectation{}
	}

	if mmUpdateUserParams.defaultExpectation.paramPtrs != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by ExpectParams functions")
	}

	mmUpdateUserParams.defaultExpectation.params = &UserMockUpdateUserParamsParams{ctx, id, params}
	mmUpdateUserParams.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUserParams.expectations {
		if minimock.Equal(e.params, mmUpdateUserParams.defaultExpectation.params) {
			mmUpdateUserParams.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUserParams.defaultExpectation.params)
		}
	}

	return mmUpdateUserParams
}

// ExpectCtxParam1 sets up expected param ctx for User.UpdateUserParams
func (mmUpdateUserParams *mUserMockUpdateUserParams) ExpectCtxParam1(ctx context.Context) *mUserMockUpdateUserParams {
	if mmUpdateUserParams.mock.funcUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Set")
	}

	if mmUpdateUserParams.defaultExpectation == nil {
		mmUpdateUserParams.defaultExpectation = &UserMockUpdateUserParamsExpectation{}
	}

	if mmUpdateUserParams.defaultExpectation.params != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Expect")
	}

	if mmUpdateUserParams.defaultExpectation.paramPtrs == nil {
		mmUpdateUserParams.defaultExpectation.paramPtrs = &UserMockUpdateUserParamsParamPtrs{}
	}
	mmUpdateUserParams.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUserParams.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUserParams
}

// ExpectIdParam2 sets up expected param id for User.UpdateUserParams
func (mmUpdateUserParams *mUserMockUpdateUserParams) ExpectIdParam2(id int64) *mUserMockUpdateUserParams {
	if mmUpdateUserParams.mock.funcUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Set")
	}

	if mmUpdateUserParams.defaultExpectation == nil {
		mmUpdateUserParams.defaultExpectation = &UserMockUpdateUserParamsExpectation{}
	}

	if mmUpdateUserParams.defaultExpectation.params != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Expect")
	}

	if mmUpdateUserParams.defaultExpectation.paramPtrs == nil {
		mmUpdateUserParams.defaultExpectation.paramPtrs = &UserMockUpdateUserParamsParamPtrs{}
	}
	mmUpdateUserParams.defaultExpectation.paramPtrs.id = &id
	mmUpdateUserParams.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateUserParams
}

// ExpectParamsParam3 sets up expected param params for User.UpdateUserParams
func (mmUpdateUserParams *mUserMockUpdateUserParams) ExpectParamsParam3(params model.UserParams) *mUserMockUpdateUserParams {
	if mmUpdateUserParams.mock.funcUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Set")
	}

	if mmUpdateUserParams.defaultExpectation == nil {
		mmUpdateUserParams.defaultExpectation = &UserMockUpdateUserParamsExpectation{}
	}

	if mmUpdateUserParams.defaultExpectation.params != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Expect")
	}

	if mmUpdateUserParams.defaultExpectation.paramPtrs == nil {
		mmUpdateUserParams.defaultExpectation.paramPtrs = &UserMockUpdateUserParamsParamPtrs{}
	}
	mmUpdateUserParams.defaultExpectation.paramPtrs.params = &params
	mmUpdateUserParams.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmUpdateUserParams
}

// Inspect accepts an inspector function that has same arguments as the User.UpdateUserParams
func (mmUpdateUserParams *mUserMockUpdateUserParams) Inspect(f func(ctx context.Context, id int64, params model.UserParams)) *mUserMockUpdateUserParams {
	if mmUpdateUserParams.mock.inspectFuncUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("Inspect function is already set for UserMock.UpdateUserParams")
	}

	mmUpdateUserParams.mock.inspectFuncUpdateUserParams = f

	return mmUpdateUserParams
}

// Return sets up results that will be returned by User.UpdateUserParams
func (mmUpdateUserParams *mUserMockUpdateUserParams) Return(err error) *UserMock {
	if mmUpdateUserParams.mock.funcUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Set")
	}

	if mmUpdateUserParams.defaultExpectation == nil {
		mmUpdateUserParams.defaultExpectation = &UserMockUpdateUserParamsExpectation{mock: mmUpdateUserParams.mock}
	}
	mmUpdateUserParams.defaultExpectation.results = &UserMockUpdateUserParamsResults{err}
	mmUpdateUserParams.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUserParams.mock
}

// Set uses given function f to mock the User.UpdateUserParams method
func (mmUpdateUserParams *mUserMockUpdateUserParams) Set(f func(ctx context.Context, id int64, params model.UserParams) (err error)) *UserMock {
	if mmUpdateUserParams.defaultExpectation != nil {
		mmUpdateUserParams.mock.t.Fatalf("Default expectation is already set for the User.UpdateUserParams method")
	}

	if len(mmUpdateUserParams.expectations) > 0 {
		mmUpdateUserParams.mock.t.Fatalf("Some expectations are already set for the User.UpdateUserParams method")
	}

	mmUpdateUserParams.mock.funcUpdateUserParams = f
	mmUpdateUserParams.mock.funcUpdateUserParamsOrigin = minimock.CallerInfo(1)
	return mmUpdateUserParams.mock
}

// When sets expectation for the User.UpdateUserParams which will trigger the result defined by the following
// Then helper
func (mmUpdateUserParams *mUserMockUpdateUserParams) When(ctx context.Context, id int64, params model.UserParams) *UserMockUpdateUserParamsExpectation {
	if mmUpdateUserParams.mock.funcUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Set")
	}

	expectation := &UserMockUpdateUserParamsExpectation{
		mock:               mmUpdateUserParams.mock,
		params:             &UserMockUpdateUserParamsParams{ctx, id, params},
		expectationOrigins: UserMockUpdateUserParamsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUserParams.expectations = append(mmUpdateUserParams.expectations, expectation)
	return expectation
}

// Then sets up User.UpdateUserParams return parameters for the expectation previously defined by the When method
func (e *UserMockUpdateUserParamsExpectation) Then(err error) *UserMock {
	e.results = &UserMockUpdateUserParamsResults{err}
	return e.mock
}

// Times sets number of times User.UpdateUserParams should be invoked
func (mmUpdateUserParams *mUserMockUpdateUserParams) Times(n uint64) *mUserMockUpdateUserParams {
	if n == 0 {
		mmUpdateUserParams.mock.t.Fatalf("Times of UserMock.UpdateUserParams mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUserParams.expectedInvocations, n)
	mmUpdateUserParams.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUserParams
}

func (mmUpdateUserParams *mUserMockUpdateUserParams) invocationsDone() bool {
	if len(mmUpdateUserParams.expectations) == 0 && mmUpdateUserParams.defaultExpectation == nil && mmUpdateUserParams.mock.funcUpdateUserParams == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUserParams.mock.afterUpdateUserParamsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUserParams.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUserParams implements mm_storage.User
func (mmUpdateUserParams *UserMock) UpdateUserParams(ctx context.Context, id int64, params model.UserParams) (err error) {
	mm_atomic.AddUint64(&mmUpdateUserParams.beforeUpdateUserParamsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUserParams.afterUpdateUserParamsCounter, 1)

	mmUpdateUserParams.t.Helper()

	if mmUpdateUserParams.inspectFuncUpdateUserParams != nil {
		mmUpdateUserParams.inspectFuncUpdateUserParams(ctx, id, params)
	}

	mm_params := UserMockUpdateUserParamsParams{ctx, id, params}

	// Record call args
	mmUpdateUserParams.UpdateUserParamsMock.mutex.Lock()
	mmUpdateUserParams.UpdateUserParamsMock.callArgs = append(mmUpdateUserParams.UpdateUserParamsMock.callArgs, &mm_params)
	mmUpdateUserParams.UpdateUserParamsMock.mutex.Unlock()

	for _, e := range mmUpdateUserParams.UpdateUserParamsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.paramPtrs

		mm_got := UserMockUpdateUserParamsParams{ctx, id, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUserParams.t.Errorf("UserMock.UpdateUserParams got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateUserParams.t.Errorf("UserMock.UpdateUserParams got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmUpdateUserParams.t.Errorf("UserMock.UpdateUserParams got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUserParams.t.Errorf("UserMock.UpdateUserParams got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUserParams.t.Fatal("No results are set for the UserMock.UpdateUserParams")
		}
		return (*mm_results).err
	}
	if mmUpdateUserParams.funcUpdateUserParams != nil {
		return mmUpdateUserParams.funcUpdateUserParams(ctx, id, params)
	}
	mmUpdateUserParams.t.Fatalf("Unexpected call to UserMock.UpdateUserParams. %v %v %v", ctx, id, params)
	return
}

// UpdateUserParamsAfterCounter returns a count of finished UserMock.UpdateUserParams invocations
func (mmUpdateUserParams *UserMock) UpdateUserParamsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserParams.afterUpdateUserParamsCounter)
}

// UpdateUserParamsBeforeCounter returns a count of UserMock.UpdateUserParams invocations
func (mmUpdateUserParams *UserMock) UpdateUserParamsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserParams.beforeUpdateUserParamsCounter)
}

// Calls returns a list of arguments used in each call to UserMock.UpdateUserParams.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUserParams *mUserMockUpdateUserParams) Calls() []*UserMockUpdateUserParamsParams {
	mmUpdateUserParams.mutex.RLock()

	argCopy := make([]*UserMockUpdateUserParamsParams, len(mmUpdateUserParams.callArgs))
	copy(argCopy, mmUpdateUserParams.callArgs)

	mmUpdateUserParams.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserParamsDone returns true if the count of the UpdateUserParams invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockUpdateUserParamsDone() bool {
	if m.UpdateUserParamsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserParamsMock.invocationsDone()
}

// MinimockUpdateUserParamsInspect logs each unmet expectation
func (m *UserMock) MinimockUpdateUserParamsInspect() {
	for _, e := range m.UpdateUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.UpdateUserParams at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserParamsCounter := mm_atomic.LoadUint64(&m.afterUpdateUserParamsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserParamsMock.defaultExpectation != nil && afterUpdateUserParamsCounter < 1 {
		if m.UpdateUserParamsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.UpdateUserParams at\n%s", m.UpdateUserParamsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.UpdateUserParams at\n%s with params: %#v", m.UpdateUserParamsMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserParamsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUserParams != nil && afterUpdateUserParamsCounter < 1 {
		m.t.Errorf("Expected call to UserMock.UpdateUserParams at\n%s", m.funcUpdateUserParamsOrigin)
	}

	if !m.UpdateUserParamsMock.invocationsDone() && afterUpdateUserParamsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.UpdateUserParams at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserParamsMock.expectedInvocations), m.UpdateUserParamsMock.expectedInvocationsOrigin, afterUpdateUserParamsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockCreateUserParamsInspect()

			m.MinimockGetFullUserParamsInspect()

			m.MinimockGetUserInspect()

			m.MinimockUpdateUserInspect()

			m.MinimockUpdateUserParamsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockCreateUserParamsDone() &&
		m.MinimockGetFullUserParamsDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockUpdateUserDone() &&
		m.MinimockUpdateUserParamsDone()
}
