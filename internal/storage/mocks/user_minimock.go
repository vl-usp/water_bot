// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/vl-usp/water_bot/internal/storage.User -o user_minimock.go -n UserMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/vl-usp/water_bot/internal/model"
)

// UserMock implements mm_storage.User
type UserMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, user model.User) (err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, user model.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserMockCreateUser

	funcCreateUserParams          func(ctx context.Context, params model.UserParams) (i1 int64, err error)
	funcCreateUserParamsOrigin    string
	inspectFuncCreateUserParams   func(ctx context.Context, params model.UserParams)
	afterCreateUserParamsCounter  uint64
	beforeCreateUserParamsCounter uint64
	CreateUserParamsMock          mUserMockCreateUserParams

	funcFillUserParams          func(ctx context.Context, params model.UserParams) (up1 *model.UserParams, err error)
	funcFillUserParamsOrigin    string
	inspectFuncFillUserParams   func(ctx context.Context, params model.UserParams)
	afterFillUserParamsCounter  uint64
	beforeFillUserParamsCounter uint64
	FillUserParamsMock          mUserMockFillUserParams

	funcGetFullUser          func(ctx context.Context, userID int64) (up1 *model.User, err error)
	funcGetFullUserOrigin    string
	inspectFuncGetFullUser   func(ctx context.Context, userID int64)
	afterGetFullUserCounter  uint64
	beforeGetFullUserCounter uint64
	GetFullUserMock          mUserMockGetFullUser

	funcGetUser          func(ctx context.Context, userID int64) (up1 *model.User, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, userID int64)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mUserMockGetUser

	funcGetUserParams          func(ctx context.Context, paramsID int64) (up1 *model.UserParams, err error)
	funcGetUserParamsOrigin    string
	inspectFuncGetUserParams   func(ctx context.Context, paramsID int64)
	afterGetUserParamsCounter  uint64
	beforeGetUserParamsCounter uint64
	GetUserParamsMock          mUserMockGetUserParams

	funcUpdateUser          func(ctx context.Context, userID int64, user model.User) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, userID int64, user model.User)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mUserMockUpdateUser

	funcUpdateUserParams          func(ctx context.Context, paramsID int64, params model.UserParams) (err error)
	funcUpdateUserParamsOrigin    string
	inspectFuncUpdateUserParams   func(ctx context.Context, paramsID int64, params model.UserParams)
	afterUpdateUserParamsCounter  uint64
	beforeUpdateUserParamsCounter uint64
	UpdateUserParamsMock          mUserMockUpdateUserParams
}

// NewUserMock returns a mock for mm_storage.User
func NewUserMock(t minimock.Tester) *UserMock {
	m := &UserMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mUserMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserMockCreateUserParams{}

	m.CreateUserParamsMock = mUserMockCreateUserParams{mock: m}
	m.CreateUserParamsMock.callArgs = []*UserMockCreateUserParamsParams{}

	m.FillUserParamsMock = mUserMockFillUserParams{mock: m}
	m.FillUserParamsMock.callArgs = []*UserMockFillUserParamsParams{}

	m.GetFullUserMock = mUserMockGetFullUser{mock: m}
	m.GetFullUserMock.callArgs = []*UserMockGetFullUserParams{}

	m.GetUserMock = mUserMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*UserMockGetUserParams{}

	m.GetUserParamsMock = mUserMockGetUserParams{mock: m}
	m.GetUserParamsMock.callArgs = []*UserMockGetUserParamsParams{}

	m.UpdateUserMock = mUserMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*UserMockUpdateUserParams{}

	m.UpdateUserParamsMock = mUserMockUpdateUserParams{mock: m}
	m.UpdateUserParamsMock.callArgs = []*UserMockUpdateUserParamsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserMockCreateUser struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockCreateUserExpectation
	expectations       []*UserMockCreateUserExpectation

	callArgs []*UserMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockCreateUserExpectation specifies expectation struct of the User.CreateUser
type UserMockCreateUserExpectation struct {
	mock               *UserMock
	params             *UserMockCreateUserParams
	paramPtrs          *UserMockCreateUserParamPtrs
	expectationOrigins UserMockCreateUserExpectationOrigins
	results            *UserMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserMockCreateUserParams contains parameters of the User.CreateUser
type UserMockCreateUserParams struct {
	ctx  context.Context
	user model.User
}

// UserMockCreateUserParamPtrs contains pointers to parameters of the User.CreateUser
type UserMockCreateUserParamPtrs struct {
	ctx  *context.Context
	user *model.User
}

// UserMockCreateUserResults contains results of the User.CreateUser
type UserMockCreateUserResults struct {
	err error
}

// UserMockCreateUserOrigins contains origins of expectations of the User.CreateUser
type UserMockCreateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserMockCreateUser) Optional() *mUserMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for User.CreateUser
func (mmCreateUser *mUserMockCreateUser) Expect(ctx context.Context, user model.User) *mUserMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &UserMockCreateUserParams{ctx, user}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for User.CreateUser
func (mmCreateUser *mUserMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectUserParam2 sets up expected param user for User.CreateUser
func (mmCreateUser *mUserMockCreateUser) ExpectUserParam2(user model.User) *mUserMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user
	mmCreateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the User.CreateUser
func (mmCreateUser *mUserMockCreateUser) Inspect(f func(ctx context.Context, user model.User)) *mUserMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by User.CreateUser
func (mmCreateUser *mUserMockCreateUser) Return(err error) *UserMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserMockCreateUserResults{err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the User.CreateUser method
func (mmCreateUser *mUserMockCreateUser) Set(f func(ctx context.Context, user model.User) (err error)) *UserMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the User.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the User.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the User.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserMockCreateUser) When(ctx context.Context, user model.User) *UserMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	expectation := &UserMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &UserMockCreateUserParams{ctx, user},
		expectationOrigins: UserMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up User.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserMockCreateUserExpectation) Then(err error) *UserMock {
	e.results = &UserMockCreateUserResults{err}
	return e.mock
}

// Times sets number of times User.CreateUser should be invoked
func (mmCreateUser *mUserMockCreateUser) Times(n uint64) *mUserMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of UserMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mUserMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_storage.User
func (mmCreateUser *UserMock) CreateUser(ctx context.Context, user model.User) (err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, user)
	}

	mm_params := UserMockCreateUserParams{ctx, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := UserMockCreateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("UserMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("UserMock.CreateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UserMock.CreateUser")
		}
		return (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserMock.CreateUser. %v %v", ctx, user)
	return
}

// CreateUserAfterCounter returns a count of finished UserMock.CreateUser invocations
func (mmCreateUser *UserMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserMock.CreateUser invocations
func (mmCreateUser *UserMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserMockCreateUser) Calls() []*UserMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to UserMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mUserMockCreateUserParams struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockCreateUserParamsExpectation
	expectations       []*UserMockCreateUserParamsExpectation

	callArgs []*UserMockCreateUserParamsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockCreateUserParamsExpectation specifies expectation struct of the User.CreateUserParams
type UserMockCreateUserParamsExpectation struct {
	mock               *UserMock
	params             *UserMockCreateUserParamsParams
	paramPtrs          *UserMockCreateUserParamsParamPtrs
	expectationOrigins UserMockCreateUserParamsExpectationOrigins
	results            *UserMockCreateUserParamsResults
	returnOrigin       string
	Counter            uint64
}

// UserMockCreateUserParamsParams contains parameters of the User.CreateUserParams
type UserMockCreateUserParamsParams struct {
	ctx    context.Context
	params model.UserParams
}

// UserMockCreateUserParamsParamPtrs contains pointers to parameters of the User.CreateUserParams
type UserMockCreateUserParamsParamPtrs struct {
	ctx    *context.Context
	params *model.UserParams
}

// UserMockCreateUserParamsResults contains results of the User.CreateUserParams
type UserMockCreateUserParamsResults struct {
	i1  int64
	err error
}

// UserMockCreateUserParamsOrigins contains origins of expectations of the User.CreateUserParams
type UserMockCreateUserParamsExpectationOrigins struct {
	origin       string
	originCtx    string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUserParams *mUserMockCreateUserParams) Optional() *mUserMockCreateUserParams {
	mmCreateUserParams.optional = true
	return mmCreateUserParams
}

// Expect sets up expected params for User.CreateUserParams
func (mmCreateUserParams *mUserMockCreateUserParams) Expect(ctx context.Context, params model.UserParams) *mUserMockCreateUserParams {
	if mmCreateUserParams.mock.funcCreateUserParams != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Set")
	}

	if mmCreateUserParams.defaultExpectation == nil {
		mmCreateUserParams.defaultExpectation = &UserMockCreateUserParamsExpectation{}
	}

	if mmCreateUserParams.defaultExpectation.paramPtrs != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by ExpectParams functions")
	}

	mmCreateUserParams.defaultExpectation.params = &UserMockCreateUserParamsParams{ctx, params}
	mmCreateUserParams.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUserParams.expectations {
		if minimock.Equal(e.params, mmCreateUserParams.defaultExpectation.params) {
			mmCreateUserParams.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUserParams.defaultExpectation.params)
		}
	}

	return mmCreateUserParams
}

// ExpectCtxParam1 sets up expected param ctx for User.CreateUserParams
func (mmCreateUserParams *mUserMockCreateUserParams) ExpectCtxParam1(ctx context.Context) *mUserMockCreateUserParams {
	if mmCreateUserParams.mock.funcCreateUserParams != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Set")
	}

	if mmCreateUserParams.defaultExpectation == nil {
		mmCreateUserParams.defaultExpectation = &UserMockCreateUserParamsExpectation{}
	}

	if mmCreateUserParams.defaultExpectation.params != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Expect")
	}

	if mmCreateUserParams.defaultExpectation.paramPtrs == nil {
		mmCreateUserParams.defaultExpectation.paramPtrs = &UserMockCreateUserParamsParamPtrs{}
	}
	mmCreateUserParams.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUserParams.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUserParams
}

// ExpectParamsParam2 sets up expected param params for User.CreateUserParams
func (mmCreateUserParams *mUserMockCreateUserParams) ExpectParamsParam2(params model.UserParams) *mUserMockCreateUserParams {
	if mmCreateUserParams.mock.funcCreateUserParams != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Set")
	}

	if mmCreateUserParams.defaultExpectation == nil {
		mmCreateUserParams.defaultExpectation = &UserMockCreateUserParamsExpectation{}
	}

	if mmCreateUserParams.defaultExpectation.params != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Expect")
	}

	if mmCreateUserParams.defaultExpectation.paramPtrs == nil {
		mmCreateUserParams.defaultExpectation.paramPtrs = &UserMockCreateUserParamsParamPtrs{}
	}
	mmCreateUserParams.defaultExpectation.paramPtrs.params = &params
	mmCreateUserParams.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmCreateUserParams
}

// Inspect accepts an inspector function that has same arguments as the User.CreateUserParams
func (mmCreateUserParams *mUserMockCreateUserParams) Inspect(f func(ctx context.Context, params model.UserParams)) *mUserMockCreateUserParams {
	if mmCreateUserParams.mock.inspectFuncCreateUserParams != nil {
		mmCreateUserParams.mock.t.Fatalf("Inspect function is already set for UserMock.CreateUserParams")
	}

	mmCreateUserParams.mock.inspectFuncCreateUserParams = f

	return mmCreateUserParams
}

// Return sets up results that will be returned by User.CreateUserParams
func (mmCreateUserParams *mUserMockCreateUserParams) Return(i1 int64, err error) *UserMock {
	if mmCreateUserParams.mock.funcCreateUserParams != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Set")
	}

	if mmCreateUserParams.defaultExpectation == nil {
		mmCreateUserParams.defaultExpectation = &UserMockCreateUserParamsExpectation{mock: mmCreateUserParams.mock}
	}
	mmCreateUserParams.defaultExpectation.results = &UserMockCreateUserParamsResults{i1, err}
	mmCreateUserParams.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUserParams.mock
}

// Set uses given function f to mock the User.CreateUserParams method
func (mmCreateUserParams *mUserMockCreateUserParams) Set(f func(ctx context.Context, params model.UserParams) (i1 int64, err error)) *UserMock {
	if mmCreateUserParams.defaultExpectation != nil {
		mmCreateUserParams.mock.t.Fatalf("Default expectation is already set for the User.CreateUserParams method")
	}

	if len(mmCreateUserParams.expectations) > 0 {
		mmCreateUserParams.mock.t.Fatalf("Some expectations are already set for the User.CreateUserParams method")
	}

	mmCreateUserParams.mock.funcCreateUserParams = f
	mmCreateUserParams.mock.funcCreateUserParamsOrigin = minimock.CallerInfo(1)
	return mmCreateUserParams.mock
}

// When sets expectation for the User.CreateUserParams which will trigger the result defined by the following
// Then helper
func (mmCreateUserParams *mUserMockCreateUserParams) When(ctx context.Context, params model.UserParams) *UserMockCreateUserParamsExpectation {
	if mmCreateUserParams.mock.funcCreateUserParams != nil {
		mmCreateUserParams.mock.t.Fatalf("UserMock.CreateUserParams mock is already set by Set")
	}

	expectation := &UserMockCreateUserParamsExpectation{
		mock:               mmCreateUserParams.mock,
		params:             &UserMockCreateUserParamsParams{ctx, params},
		expectationOrigins: UserMockCreateUserParamsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUserParams.expectations = append(mmCreateUserParams.expectations, expectation)
	return expectation
}

// Then sets up User.CreateUserParams return parameters for the expectation previously defined by the When method
func (e *UserMockCreateUserParamsExpectation) Then(i1 int64, err error) *UserMock {
	e.results = &UserMockCreateUserParamsResults{i1, err}
	return e.mock
}

// Times sets number of times User.CreateUserParams should be invoked
func (mmCreateUserParams *mUserMockCreateUserParams) Times(n uint64) *mUserMockCreateUserParams {
	if n == 0 {
		mmCreateUserParams.mock.t.Fatalf("Times of UserMock.CreateUserParams mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUserParams.expectedInvocations, n)
	mmCreateUserParams.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUserParams
}

func (mmCreateUserParams *mUserMockCreateUserParams) invocationsDone() bool {
	if len(mmCreateUserParams.expectations) == 0 && mmCreateUserParams.defaultExpectation == nil && mmCreateUserParams.mock.funcCreateUserParams == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUserParams.mock.afterCreateUserParamsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUserParams.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUserParams implements mm_storage.User
func (mmCreateUserParams *UserMock) CreateUserParams(ctx context.Context, params model.UserParams) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUserParams.beforeCreateUserParamsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUserParams.afterCreateUserParamsCounter, 1)

	mmCreateUserParams.t.Helper()

	if mmCreateUserParams.inspectFuncCreateUserParams != nil {
		mmCreateUserParams.inspectFuncCreateUserParams(ctx, params)
	}

	mm_params := UserMockCreateUserParamsParams{ctx, params}

	// Record call args
	mmCreateUserParams.CreateUserParamsMock.mutex.Lock()
	mmCreateUserParams.CreateUserParamsMock.callArgs = append(mmCreateUserParams.CreateUserParamsMock.callArgs, &mm_params)
	mmCreateUserParams.CreateUserParamsMock.mutex.Unlock()

	for _, e := range mmCreateUserParams.CreateUserParamsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUserParams.CreateUserParamsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUserParams.CreateUserParamsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUserParams.CreateUserParamsMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUserParams.CreateUserParamsMock.defaultExpectation.paramPtrs

		mm_got := UserMockCreateUserParamsParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUserParams.t.Errorf("UserMock.CreateUserParams got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUserParams.CreateUserParamsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmCreateUserParams.t.Errorf("UserMock.CreateUserParams got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUserParams.CreateUserParamsMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUserParams.t.Errorf("UserMock.CreateUserParams got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUserParams.CreateUserParamsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUserParams.CreateUserParamsMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUserParams.t.Fatal("No results are set for the UserMock.CreateUserParams")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUserParams.funcCreateUserParams != nil {
		return mmCreateUserParams.funcCreateUserParams(ctx, params)
	}
	mmCreateUserParams.t.Fatalf("Unexpected call to UserMock.CreateUserParams. %v %v", ctx, params)
	return
}

// CreateUserParamsAfterCounter returns a count of finished UserMock.CreateUserParams invocations
func (mmCreateUserParams *UserMock) CreateUserParamsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUserParams.afterCreateUserParamsCounter)
}

// CreateUserParamsBeforeCounter returns a count of UserMock.CreateUserParams invocations
func (mmCreateUserParams *UserMock) CreateUserParamsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUserParams.beforeCreateUserParamsCounter)
}

// Calls returns a list of arguments used in each call to UserMock.CreateUserParams.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUserParams *mUserMockCreateUserParams) Calls() []*UserMockCreateUserParamsParams {
	mmCreateUserParams.mutex.RLock()

	argCopy := make([]*UserMockCreateUserParamsParams, len(mmCreateUserParams.callArgs))
	copy(argCopy, mmCreateUserParams.callArgs)

	mmCreateUserParams.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserParamsDone returns true if the count of the CreateUserParams invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockCreateUserParamsDone() bool {
	if m.CreateUserParamsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserParamsMock.invocationsDone()
}

// MinimockCreateUserParamsInspect logs each unmet expectation
func (m *UserMock) MinimockCreateUserParamsInspect() {
	for _, e := range m.CreateUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.CreateUserParams at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserParamsCounter := mm_atomic.LoadUint64(&m.afterCreateUserParamsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserParamsMock.defaultExpectation != nil && afterCreateUserParamsCounter < 1 {
		if m.CreateUserParamsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.CreateUserParams at\n%s", m.CreateUserParamsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.CreateUserParams at\n%s with params: %#v", m.CreateUserParamsMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserParamsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUserParams != nil && afterCreateUserParamsCounter < 1 {
		m.t.Errorf("Expected call to UserMock.CreateUserParams at\n%s", m.funcCreateUserParamsOrigin)
	}

	if !m.CreateUserParamsMock.invocationsDone() && afterCreateUserParamsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.CreateUserParams at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserParamsMock.expectedInvocations), m.CreateUserParamsMock.expectedInvocationsOrigin, afterCreateUserParamsCounter)
	}
}

type mUserMockFillUserParams struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockFillUserParamsExpectation
	expectations       []*UserMockFillUserParamsExpectation

	callArgs []*UserMockFillUserParamsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockFillUserParamsExpectation specifies expectation struct of the User.FillUserParams
type UserMockFillUserParamsExpectation struct {
	mock               *UserMock
	params             *UserMockFillUserParamsParams
	paramPtrs          *UserMockFillUserParamsParamPtrs
	expectationOrigins UserMockFillUserParamsExpectationOrigins
	results            *UserMockFillUserParamsResults
	returnOrigin       string
	Counter            uint64
}

// UserMockFillUserParamsParams contains parameters of the User.FillUserParams
type UserMockFillUserParamsParams struct {
	ctx    context.Context
	params model.UserParams
}

// UserMockFillUserParamsParamPtrs contains pointers to parameters of the User.FillUserParams
type UserMockFillUserParamsParamPtrs struct {
	ctx    *context.Context
	params *model.UserParams
}

// UserMockFillUserParamsResults contains results of the User.FillUserParams
type UserMockFillUserParamsResults struct {
	up1 *model.UserParams
	err error
}

// UserMockFillUserParamsOrigins contains origins of expectations of the User.FillUserParams
type UserMockFillUserParamsExpectationOrigins struct {
	origin       string
	originCtx    string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFillUserParams *mUserMockFillUserParams) Optional() *mUserMockFillUserParams {
	mmFillUserParams.optional = true
	return mmFillUserParams
}

// Expect sets up expected params for User.FillUserParams
func (mmFillUserParams *mUserMockFillUserParams) Expect(ctx context.Context, params model.UserParams) *mUserMockFillUserParams {
	if mmFillUserParams.mock.funcFillUserParams != nil {
		mmFillUserParams.mock.t.Fatalf("UserMock.FillUserParams mock is already set by Set")
	}

	if mmFillUserParams.defaultExpectation == nil {
		mmFillUserParams.defaultExpectation = &UserMockFillUserParamsExpectation{}
	}

	if mmFillUserParams.defaultExpectation.paramPtrs != nil {
		mmFillUserParams.mock.t.Fatalf("UserMock.FillUserParams mock is already set by ExpectParams functions")
	}

	mmFillUserParams.defaultExpectation.params = &UserMockFillUserParamsParams{ctx, params}
	mmFillUserParams.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFillUserParams.expectations {
		if minimock.Equal(e.params, mmFillUserParams.defaultExpectation.params) {
			mmFillUserParams.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFillUserParams.defaultExpectation.params)
		}
	}

	return mmFillUserParams
}

// ExpectCtxParam1 sets up expected param ctx for User.FillUserParams
func (mmFillUserParams *mUserMockFillUserParams) ExpectCtxParam1(ctx context.Context) *mUserMockFillUserParams {
	if mmFillUserParams.mock.funcFillUserParams != nil {
		mmFillUserParams.mock.t.Fatalf("UserMock.FillUserParams mock is already set by Set")
	}

	if mmFillUserParams.defaultExpectation == nil {
		mmFillUserParams.defaultExpectation = &UserMockFillUserParamsExpectation{}
	}

	if mmFillUserParams.defaultExpectation.params != nil {
		mmFillUserParams.mock.t.Fatalf("UserMock.FillUserParams mock is already set by Expect")
	}

	if mmFillUserParams.defaultExpectation.paramPtrs == nil {
		mmFillUserParams.defaultExpectation.paramPtrs = &UserMockFillUserParamsParamPtrs{}
	}
	mmFillUserParams.defaultExpectation.paramPtrs.ctx = &ctx
	mmFillUserParams.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFillUserParams
}

// ExpectParamsParam2 sets up expected param params for User.FillUserParams
func (mmFillUserParams *mUserMockFillUserParams) ExpectParamsParam2(params model.UserParams) *mUserMockFillUserParams {
	if mmFillUserParams.mock.funcFillUserParams != nil {
		mmFillUserParams.mock.t.Fatalf("UserMock.FillUserParams mock is already set by Set")
	}

	if mmFillUserParams.defaultExpectation == nil {
		mmFillUserParams.defaultExpectation = &UserMockFillUserParamsExpectation{}
	}

	if mmFillUserParams.defaultExpectation.params != nil {
		mmFillUserParams.mock.t.Fatalf("UserMock.FillUserParams mock is already set by Expect")
	}

	if mmFillUserParams.defaultExpectation.paramPtrs == nil {
		mmFillUserParams.defaultExpectation.paramPtrs = &UserMockFillUserParamsParamPtrs{}
	}
	mmFillUserParams.defaultExpectation.paramPtrs.params = &params
	mmFillUserParams.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmFillUserParams
}

// Inspect accepts an inspector function that has same arguments as the User.FillUserParams
func (mmFillUserParams *mUserMockFillUserParams) Inspect(f func(ctx context.Context, params model.UserParams)) *mUserMockFillUserParams {
	if mmFillUserParams.mock.inspectFuncFillUserParams != nil {
		mmFillUserParams.mock.t.Fatalf("Inspect function is already set for UserMock.FillUserParams")
	}

	mmFillUserParams.mock.inspectFuncFillUserParams = f

	return mmFillUserParams
}

// Return sets up results that will be returned by User.FillUserParams
func (mmFillUserParams *mUserMockFillUserParams) Return(up1 *model.UserParams, err error) *UserMock {
	if mmFillUserParams.mock.funcFillUserParams != nil {
		mmFillUserParams.mock.t.Fatalf("UserMock.FillUserParams mock is already set by Set")
	}

	if mmFillUserParams.defaultExpectation == nil {
		mmFillUserParams.defaultExpectation = &UserMockFillUserParamsExpectation{mock: mmFillUserParams.mock}
	}
	mmFillUserParams.defaultExpectation.results = &UserMockFillUserParamsResults{up1, err}
	mmFillUserParams.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFillUserParams.mock
}

// Set uses given function f to mock the User.FillUserParams method
func (mmFillUserParams *mUserMockFillUserParams) Set(f func(ctx context.Context, params model.UserParams) (up1 *model.UserParams, err error)) *UserMock {
	if mmFillUserParams.defaultExpectation != nil {
		mmFillUserParams.mock.t.Fatalf("Default expectation is already set for the User.FillUserParams method")
	}

	if len(mmFillUserParams.expectations) > 0 {
		mmFillUserParams.mock.t.Fatalf("Some expectations are already set for the User.FillUserParams method")
	}

	mmFillUserParams.mock.funcFillUserParams = f
	mmFillUserParams.mock.funcFillUserParamsOrigin = minimock.CallerInfo(1)
	return mmFillUserParams.mock
}

// When sets expectation for the User.FillUserParams which will trigger the result defined by the following
// Then helper
func (mmFillUserParams *mUserMockFillUserParams) When(ctx context.Context, params model.UserParams) *UserMockFillUserParamsExpectation {
	if mmFillUserParams.mock.funcFillUserParams != nil {
		mmFillUserParams.mock.t.Fatalf("UserMock.FillUserParams mock is already set by Set")
	}

	expectation := &UserMockFillUserParamsExpectation{
		mock:               mmFillUserParams.mock,
		params:             &UserMockFillUserParamsParams{ctx, params},
		expectationOrigins: UserMockFillUserParamsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFillUserParams.expectations = append(mmFillUserParams.expectations, expectation)
	return expectation
}

// Then sets up User.FillUserParams return parameters for the expectation previously defined by the When method
func (e *UserMockFillUserParamsExpectation) Then(up1 *model.UserParams, err error) *UserMock {
	e.results = &UserMockFillUserParamsResults{up1, err}
	return e.mock
}

// Times sets number of times User.FillUserParams should be invoked
func (mmFillUserParams *mUserMockFillUserParams) Times(n uint64) *mUserMockFillUserParams {
	if n == 0 {
		mmFillUserParams.mock.t.Fatalf("Times of UserMock.FillUserParams mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFillUserParams.expectedInvocations, n)
	mmFillUserParams.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFillUserParams
}

func (mmFillUserParams *mUserMockFillUserParams) invocationsDone() bool {
	if len(mmFillUserParams.expectations) == 0 && mmFillUserParams.defaultExpectation == nil && mmFillUserParams.mock.funcFillUserParams == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFillUserParams.mock.afterFillUserParamsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFillUserParams.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FillUserParams implements mm_storage.User
func (mmFillUserParams *UserMock) FillUserParams(ctx context.Context, params model.UserParams) (up1 *model.UserParams, err error) {
	mm_atomic.AddUint64(&mmFillUserParams.beforeFillUserParamsCounter, 1)
	defer mm_atomic.AddUint64(&mmFillUserParams.afterFillUserParamsCounter, 1)

	mmFillUserParams.t.Helper()

	if mmFillUserParams.inspectFuncFillUserParams != nil {
		mmFillUserParams.inspectFuncFillUserParams(ctx, params)
	}

	mm_params := UserMockFillUserParamsParams{ctx, params}

	// Record call args
	mmFillUserParams.FillUserParamsMock.mutex.Lock()
	mmFillUserParams.FillUserParamsMock.callArgs = append(mmFillUserParams.FillUserParamsMock.callArgs, &mm_params)
	mmFillUserParams.FillUserParamsMock.mutex.Unlock()

	for _, e := range mmFillUserParams.FillUserParamsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmFillUserParams.FillUserParamsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFillUserParams.FillUserParamsMock.defaultExpectation.Counter, 1)
		mm_want := mmFillUserParams.FillUserParamsMock.defaultExpectation.params
		mm_want_ptrs := mmFillUserParams.FillUserParamsMock.defaultExpectation.paramPtrs

		mm_got := UserMockFillUserParamsParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFillUserParams.t.Errorf("UserMock.FillUserParams got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFillUserParams.FillUserParamsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmFillUserParams.t.Errorf("UserMock.FillUserParams got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFillUserParams.FillUserParamsMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFillUserParams.t.Errorf("UserMock.FillUserParams got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFillUserParams.FillUserParamsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFillUserParams.FillUserParamsMock.defaultExpectation.results
		if mm_results == nil {
			mmFillUserParams.t.Fatal("No results are set for the UserMock.FillUserParams")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmFillUserParams.funcFillUserParams != nil {
		return mmFillUserParams.funcFillUserParams(ctx, params)
	}
	mmFillUserParams.t.Fatalf("Unexpected call to UserMock.FillUserParams. %v %v", ctx, params)
	return
}

// FillUserParamsAfterCounter returns a count of finished UserMock.FillUserParams invocations
func (mmFillUserParams *UserMock) FillUserParamsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFillUserParams.afterFillUserParamsCounter)
}

// FillUserParamsBeforeCounter returns a count of UserMock.FillUserParams invocations
func (mmFillUserParams *UserMock) FillUserParamsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFillUserParams.beforeFillUserParamsCounter)
}

// Calls returns a list of arguments used in each call to UserMock.FillUserParams.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFillUserParams *mUserMockFillUserParams) Calls() []*UserMockFillUserParamsParams {
	mmFillUserParams.mutex.RLock()

	argCopy := make([]*UserMockFillUserParamsParams, len(mmFillUserParams.callArgs))
	copy(argCopy, mmFillUserParams.callArgs)

	mmFillUserParams.mutex.RUnlock()

	return argCopy
}

// MinimockFillUserParamsDone returns true if the count of the FillUserParams invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockFillUserParamsDone() bool {
	if m.FillUserParamsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FillUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FillUserParamsMock.invocationsDone()
}

// MinimockFillUserParamsInspect logs each unmet expectation
func (m *UserMock) MinimockFillUserParamsInspect() {
	for _, e := range m.FillUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.FillUserParams at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFillUserParamsCounter := mm_atomic.LoadUint64(&m.afterFillUserParamsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FillUserParamsMock.defaultExpectation != nil && afterFillUserParamsCounter < 1 {
		if m.FillUserParamsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.FillUserParams at\n%s", m.FillUserParamsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.FillUserParams at\n%s with params: %#v", m.FillUserParamsMock.defaultExpectation.expectationOrigins.origin, *m.FillUserParamsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFillUserParams != nil && afterFillUserParamsCounter < 1 {
		m.t.Errorf("Expected call to UserMock.FillUserParams at\n%s", m.funcFillUserParamsOrigin)
	}

	if !m.FillUserParamsMock.invocationsDone() && afterFillUserParamsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.FillUserParams at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FillUserParamsMock.expectedInvocations), m.FillUserParamsMock.expectedInvocationsOrigin, afterFillUserParamsCounter)
	}
}

type mUserMockGetFullUser struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockGetFullUserExpectation
	expectations       []*UserMockGetFullUserExpectation

	callArgs []*UserMockGetFullUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockGetFullUserExpectation specifies expectation struct of the User.GetFullUser
type UserMockGetFullUserExpectation struct {
	mock               *UserMock
	params             *UserMockGetFullUserParams
	paramPtrs          *UserMockGetFullUserParamPtrs
	expectationOrigins UserMockGetFullUserExpectationOrigins
	results            *UserMockGetFullUserResults
	returnOrigin       string
	Counter            uint64
}

// UserMockGetFullUserParams contains parameters of the User.GetFullUser
type UserMockGetFullUserParams struct {
	ctx    context.Context
	userID int64
}

// UserMockGetFullUserParamPtrs contains pointers to parameters of the User.GetFullUser
type UserMockGetFullUserParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// UserMockGetFullUserResults contains results of the User.GetFullUser
type UserMockGetFullUserResults struct {
	up1 *model.User
	err error
}

// UserMockGetFullUserOrigins contains origins of expectations of the User.GetFullUser
type UserMockGetFullUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFullUser *mUserMockGetFullUser) Optional() *mUserMockGetFullUser {
	mmGetFullUser.optional = true
	return mmGetFullUser
}

// Expect sets up expected params for User.GetFullUser
func (mmGetFullUser *mUserMockGetFullUser) Expect(ctx context.Context, userID int64) *mUserMockGetFullUser {
	if mmGetFullUser.mock.funcGetFullUser != nil {
		mmGetFullUser.mock.t.Fatalf("UserMock.GetFullUser mock is already set by Set")
	}

	if mmGetFullUser.defaultExpectation == nil {
		mmGetFullUser.defaultExpectation = &UserMockGetFullUserExpectation{}
	}

	if mmGetFullUser.defaultExpectation.paramPtrs != nil {
		mmGetFullUser.mock.t.Fatalf("UserMock.GetFullUser mock is already set by ExpectParams functions")
	}

	mmGetFullUser.defaultExpectation.params = &UserMockGetFullUserParams{ctx, userID}
	mmGetFullUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFullUser.expectations {
		if minimock.Equal(e.params, mmGetFullUser.defaultExpectation.params) {
			mmGetFullUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFullUser.defaultExpectation.params)
		}
	}

	return mmGetFullUser
}

// ExpectCtxParam1 sets up expected param ctx for User.GetFullUser
func (mmGetFullUser *mUserMockGetFullUser) ExpectCtxParam1(ctx context.Context) *mUserMockGetFullUser {
	if mmGetFullUser.mock.funcGetFullUser != nil {
		mmGetFullUser.mock.t.Fatalf("UserMock.GetFullUser mock is already set by Set")
	}

	if mmGetFullUser.defaultExpectation == nil {
		mmGetFullUser.defaultExpectation = &UserMockGetFullUserExpectation{}
	}

	if mmGetFullUser.defaultExpectation.params != nil {
		mmGetFullUser.mock.t.Fatalf("UserMock.GetFullUser mock is already set by Expect")
	}

	if mmGetFullUser.defaultExpectation.paramPtrs == nil {
		mmGetFullUser.defaultExpectation.paramPtrs = &UserMockGetFullUserParamPtrs{}
	}
	mmGetFullUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFullUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFullUser
}

// ExpectUserIDParam2 sets up expected param userID for User.GetFullUser
func (mmGetFullUser *mUserMockGetFullUser) ExpectUserIDParam2(userID int64) *mUserMockGetFullUser {
	if mmGetFullUser.mock.funcGetFullUser != nil {
		mmGetFullUser.mock.t.Fatalf("UserMock.GetFullUser mock is already set by Set")
	}

	if mmGetFullUser.defaultExpectation == nil {
		mmGetFullUser.defaultExpectation = &UserMockGetFullUserExpectation{}
	}

	if mmGetFullUser.defaultExpectation.params != nil {
		mmGetFullUser.mock.t.Fatalf("UserMock.GetFullUser mock is already set by Expect")
	}

	if mmGetFullUser.defaultExpectation.paramPtrs == nil {
		mmGetFullUser.defaultExpectation.paramPtrs = &UserMockGetFullUserParamPtrs{}
	}
	mmGetFullUser.defaultExpectation.paramPtrs.userID = &userID
	mmGetFullUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetFullUser
}

// Inspect accepts an inspector function that has same arguments as the User.GetFullUser
func (mmGetFullUser *mUserMockGetFullUser) Inspect(f func(ctx context.Context, userID int64)) *mUserMockGetFullUser {
	if mmGetFullUser.mock.inspectFuncGetFullUser != nil {
		mmGetFullUser.mock.t.Fatalf("Inspect function is already set for UserMock.GetFullUser")
	}

	mmGetFullUser.mock.inspectFuncGetFullUser = f

	return mmGetFullUser
}

// Return sets up results that will be returned by User.GetFullUser
func (mmGetFullUser *mUserMockGetFullUser) Return(up1 *model.User, err error) *UserMock {
	if mmGetFullUser.mock.funcGetFullUser != nil {
		mmGetFullUser.mock.t.Fatalf("UserMock.GetFullUser mock is already set by Set")
	}

	if mmGetFullUser.defaultExpectation == nil {
		mmGetFullUser.defaultExpectation = &UserMockGetFullUserExpectation{mock: mmGetFullUser.mock}
	}
	mmGetFullUser.defaultExpectation.results = &UserMockGetFullUserResults{up1, err}
	mmGetFullUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFullUser.mock
}

// Set uses given function f to mock the User.GetFullUser method
func (mmGetFullUser *mUserMockGetFullUser) Set(f func(ctx context.Context, userID int64) (up1 *model.User, err error)) *UserMock {
	if mmGetFullUser.defaultExpectation != nil {
		mmGetFullUser.mock.t.Fatalf("Default expectation is already set for the User.GetFullUser method")
	}

	if len(mmGetFullUser.expectations) > 0 {
		mmGetFullUser.mock.t.Fatalf("Some expectations are already set for the User.GetFullUser method")
	}

	mmGetFullUser.mock.funcGetFullUser = f
	mmGetFullUser.mock.funcGetFullUserOrigin = minimock.CallerInfo(1)
	return mmGetFullUser.mock
}

// When sets expectation for the User.GetFullUser which will trigger the result defined by the following
// Then helper
func (mmGetFullUser *mUserMockGetFullUser) When(ctx context.Context, userID int64) *UserMockGetFullUserExpectation {
	if mmGetFullUser.mock.funcGetFullUser != nil {
		mmGetFullUser.mock.t.Fatalf("UserMock.GetFullUser mock is already set by Set")
	}

	expectation := &UserMockGetFullUserExpectation{
		mock:               mmGetFullUser.mock,
		params:             &UserMockGetFullUserParams{ctx, userID},
		expectationOrigins: UserMockGetFullUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFullUser.expectations = append(mmGetFullUser.expectations, expectation)
	return expectation
}

// Then sets up User.GetFullUser return parameters for the expectation previously defined by the When method
func (e *UserMockGetFullUserExpectation) Then(up1 *model.User, err error) *UserMock {
	e.results = &UserMockGetFullUserResults{up1, err}
	return e.mock
}

// Times sets number of times User.GetFullUser should be invoked
func (mmGetFullUser *mUserMockGetFullUser) Times(n uint64) *mUserMockGetFullUser {
	if n == 0 {
		mmGetFullUser.mock.t.Fatalf("Times of UserMock.GetFullUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFullUser.expectedInvocations, n)
	mmGetFullUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFullUser
}

func (mmGetFullUser *mUserMockGetFullUser) invocationsDone() bool {
	if len(mmGetFullUser.expectations) == 0 && mmGetFullUser.defaultExpectation == nil && mmGetFullUser.mock.funcGetFullUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFullUser.mock.afterGetFullUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFullUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFullUser implements mm_storage.User
func (mmGetFullUser *UserMock) GetFullUser(ctx context.Context, userID int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetFullUser.beforeGetFullUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFullUser.afterGetFullUserCounter, 1)

	mmGetFullUser.t.Helper()

	if mmGetFullUser.inspectFuncGetFullUser != nil {
		mmGetFullUser.inspectFuncGetFullUser(ctx, userID)
	}

	mm_params := UserMockGetFullUserParams{ctx, userID}

	// Record call args
	mmGetFullUser.GetFullUserMock.mutex.Lock()
	mmGetFullUser.GetFullUserMock.callArgs = append(mmGetFullUser.GetFullUserMock.callArgs, &mm_params)
	mmGetFullUser.GetFullUserMock.mutex.Unlock()

	for _, e := range mmGetFullUser.GetFullUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetFullUser.GetFullUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFullUser.GetFullUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFullUser.GetFullUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetFullUser.GetFullUserMock.defaultExpectation.paramPtrs

		mm_got := UserMockGetFullUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFullUser.t.Errorf("UserMock.GetFullUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFullUser.GetFullUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetFullUser.t.Errorf("UserMock.GetFullUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFullUser.GetFullUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFullUser.t.Errorf("UserMock.GetFullUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFullUser.GetFullUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFullUser.GetFullUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFullUser.t.Fatal("No results are set for the UserMock.GetFullUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetFullUser.funcGetFullUser != nil {
		return mmGetFullUser.funcGetFullUser(ctx, userID)
	}
	mmGetFullUser.t.Fatalf("Unexpected call to UserMock.GetFullUser. %v %v", ctx, userID)
	return
}

// GetFullUserAfterCounter returns a count of finished UserMock.GetFullUser invocations
func (mmGetFullUser *UserMock) GetFullUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFullUser.afterGetFullUserCounter)
}

// GetFullUserBeforeCounter returns a count of UserMock.GetFullUser invocations
func (mmGetFullUser *UserMock) GetFullUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFullUser.beforeGetFullUserCounter)
}

// Calls returns a list of arguments used in each call to UserMock.GetFullUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFullUser *mUserMockGetFullUser) Calls() []*UserMockGetFullUserParams {
	mmGetFullUser.mutex.RLock()

	argCopy := make([]*UserMockGetFullUserParams, len(mmGetFullUser.callArgs))
	copy(argCopy, mmGetFullUser.callArgs)

	mmGetFullUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetFullUserDone returns true if the count of the GetFullUser invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockGetFullUserDone() bool {
	if m.GetFullUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFullUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFullUserMock.invocationsDone()
}

// MinimockGetFullUserInspect logs each unmet expectation
func (m *UserMock) MinimockGetFullUserInspect() {
	for _, e := range m.GetFullUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.GetFullUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFullUserCounter := mm_atomic.LoadUint64(&m.afterGetFullUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFullUserMock.defaultExpectation != nil && afterGetFullUserCounter < 1 {
		if m.GetFullUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.GetFullUser at\n%s", m.GetFullUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.GetFullUser at\n%s with params: %#v", m.GetFullUserMock.defaultExpectation.expectationOrigins.origin, *m.GetFullUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFullUser != nil && afterGetFullUserCounter < 1 {
		m.t.Errorf("Expected call to UserMock.GetFullUser at\n%s", m.funcGetFullUserOrigin)
	}

	if !m.GetFullUserMock.invocationsDone() && afterGetFullUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.GetFullUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFullUserMock.expectedInvocations), m.GetFullUserMock.expectedInvocationsOrigin, afterGetFullUserCounter)
	}
}

type mUserMockGetUser struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockGetUserExpectation
	expectations       []*UserMockGetUserExpectation

	callArgs []*UserMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockGetUserExpectation specifies expectation struct of the User.GetUser
type UserMockGetUserExpectation struct {
	mock               *UserMock
	params             *UserMockGetUserParams
	paramPtrs          *UserMockGetUserParamPtrs
	expectationOrigins UserMockGetUserExpectationOrigins
	results            *UserMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// UserMockGetUserParams contains parameters of the User.GetUser
type UserMockGetUserParams struct {
	ctx    context.Context
	userID int64
}

// UserMockGetUserParamPtrs contains pointers to parameters of the User.GetUser
type UserMockGetUserParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// UserMockGetUserResults contains results of the User.GetUser
type UserMockGetUserResults struct {
	up1 *model.User
	err error
}

// UserMockGetUserOrigins contains origins of expectations of the User.GetUser
type UserMockGetUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mUserMockGetUser) Optional() *mUserMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for User.GetUser
func (mmGetUser *mUserMockGetUser) Expect(ctx context.Context, userID int64) *mUserMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &UserMockGetUserParams{ctx, userID}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for User.GetUser
func (mmGetUser *mUserMockGetUser) ExpectCtxParam1(ctx context.Context) *mUserMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectUserIDParam2 sets up expected param userID for User.GetUser
func (mmGetUser *mUserMockGetUser) ExpectUserIDParam2(userID int64) *mUserMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.userID = &userID
	mmGetUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the User.GetUser
func (mmGetUser *mUserMockGetUser) Inspect(f func(ctx context.Context, userID int64)) *mUserMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for UserMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by User.GetUser
func (mmGetUser *mUserMockGetUser) Return(up1 *model.User, err error) *UserMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &UserMockGetUserResults{up1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the User.GetUser method
func (mmGetUser *mUserMockGetUser) Set(f func(ctx context.Context, userID int64) (up1 *model.User, err error)) *UserMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the User.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the User.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the User.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mUserMockGetUser) When(ctx context.Context, userID int64) *UserMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	expectation := &UserMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &UserMockGetUserParams{ctx, userID},
		expectationOrigins: UserMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up User.GetUser return parameters for the expectation previously defined by the When method
func (e *UserMockGetUserExpectation) Then(up1 *model.User, err error) *UserMock {
	e.results = &UserMockGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times User.GetUser should be invoked
func (mmGetUser *mUserMockGetUser) Times(n uint64) *mUserMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of UserMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mUserMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_storage.User
func (mmGetUser *UserMock) GetUser(ctx context.Context, userID int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, userID)
	}

	mm_params := UserMockGetUserParams{ctx, userID}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := UserMockGetUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("UserMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUser.t.Errorf("UserMock.GetUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("UserMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the UserMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, userID)
	}
	mmGetUser.t.Fatalf("Unexpected call to UserMock.GetUser. %v %v", ctx, userID)
	return
}

// GetUserAfterCounter returns a count of finished UserMock.GetUser invocations
func (mmGetUser *UserMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of UserMock.GetUser invocations
func (mmGetUser *UserMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to UserMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mUserMockGetUser) Calls() []*UserMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*UserMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *UserMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to UserMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mUserMockGetUserParams struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockGetUserParamsExpectation
	expectations       []*UserMockGetUserParamsExpectation

	callArgs []*UserMockGetUserParamsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockGetUserParamsExpectation specifies expectation struct of the User.GetUserParams
type UserMockGetUserParamsExpectation struct {
	mock               *UserMock
	params             *UserMockGetUserParamsParams
	paramPtrs          *UserMockGetUserParamsParamPtrs
	expectationOrigins UserMockGetUserParamsExpectationOrigins
	results            *UserMockGetUserParamsResults
	returnOrigin       string
	Counter            uint64
}

// UserMockGetUserParamsParams contains parameters of the User.GetUserParams
type UserMockGetUserParamsParams struct {
	ctx      context.Context
	paramsID int64
}

// UserMockGetUserParamsParamPtrs contains pointers to parameters of the User.GetUserParams
type UserMockGetUserParamsParamPtrs struct {
	ctx      *context.Context
	paramsID *int64
}

// UserMockGetUserParamsResults contains results of the User.GetUserParams
type UserMockGetUserParamsResults struct {
	up1 *model.UserParams
	err error
}

// UserMockGetUserParamsOrigins contains origins of expectations of the User.GetUserParams
type UserMockGetUserParamsExpectationOrigins struct {
	origin         string
	originCtx      string
	originParamsID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserParams *mUserMockGetUserParams) Optional() *mUserMockGetUserParams {
	mmGetUserParams.optional = true
	return mmGetUserParams
}

// Expect sets up expected params for User.GetUserParams
func (mmGetUserParams *mUserMockGetUserParams) Expect(ctx context.Context, paramsID int64) *mUserMockGetUserParams {
	if mmGetUserParams.mock.funcGetUserParams != nil {
		mmGetUserParams.mock.t.Fatalf("UserMock.GetUserParams mock is already set by Set")
	}

	if mmGetUserParams.defaultExpectation == nil {
		mmGetUserParams.defaultExpectation = &UserMockGetUserParamsExpectation{}
	}

	if mmGetUserParams.defaultExpectation.paramPtrs != nil {
		mmGetUserParams.mock.t.Fatalf("UserMock.GetUserParams mock is already set by ExpectParams functions")
	}

	mmGetUserParams.defaultExpectation.params = &UserMockGetUserParamsParams{ctx, paramsID}
	mmGetUserParams.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserParams.expectations {
		if minimock.Equal(e.params, mmGetUserParams.defaultExpectation.params) {
			mmGetUserParams.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserParams.defaultExpectation.params)
		}
	}

	return mmGetUserParams
}

// ExpectCtxParam1 sets up expected param ctx for User.GetUserParams
func (mmGetUserParams *mUserMockGetUserParams) ExpectCtxParam1(ctx context.Context) *mUserMockGetUserParams {
	if mmGetUserParams.mock.funcGetUserParams != nil {
		mmGetUserParams.mock.t.Fatalf("UserMock.GetUserParams mock is already set by Set")
	}

	if mmGetUserParams.defaultExpectation == nil {
		mmGetUserParams.defaultExpectation = &UserMockGetUserParamsExpectation{}
	}

	if mmGetUserParams.defaultExpectation.params != nil {
		mmGetUserParams.mock.t.Fatalf("UserMock.GetUserParams mock is already set by Expect")
	}

	if mmGetUserParams.defaultExpectation.paramPtrs == nil {
		mmGetUserParams.defaultExpectation.paramPtrs = &UserMockGetUserParamsParamPtrs{}
	}
	mmGetUserParams.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserParams.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserParams
}

// ExpectParamsIDParam2 sets up expected param paramsID for User.GetUserParams
func (mmGetUserParams *mUserMockGetUserParams) ExpectParamsIDParam2(paramsID int64) *mUserMockGetUserParams {
	if mmGetUserParams.mock.funcGetUserParams != nil {
		mmGetUserParams.mock.t.Fatalf("UserMock.GetUserParams mock is already set by Set")
	}

	if mmGetUserParams.defaultExpectation == nil {
		mmGetUserParams.defaultExpectation = &UserMockGetUserParamsExpectation{}
	}

	if mmGetUserParams.defaultExpectation.params != nil {
		mmGetUserParams.mock.t.Fatalf("UserMock.GetUserParams mock is already set by Expect")
	}

	if mmGetUserParams.defaultExpectation.paramPtrs == nil {
		mmGetUserParams.defaultExpectation.paramPtrs = &UserMockGetUserParamsParamPtrs{}
	}
	mmGetUserParams.defaultExpectation.paramPtrs.paramsID = &paramsID
	mmGetUserParams.defaultExpectation.expectationOrigins.originParamsID = minimock.CallerInfo(1)

	return mmGetUserParams
}

// Inspect accepts an inspector function that has same arguments as the User.GetUserParams
func (mmGetUserParams *mUserMockGetUserParams) Inspect(f func(ctx context.Context, paramsID int64)) *mUserMockGetUserParams {
	if mmGetUserParams.mock.inspectFuncGetUserParams != nil {
		mmGetUserParams.mock.t.Fatalf("Inspect function is already set for UserMock.GetUserParams")
	}

	mmGetUserParams.mock.inspectFuncGetUserParams = f

	return mmGetUserParams
}

// Return sets up results that will be returned by User.GetUserParams
func (mmGetUserParams *mUserMockGetUserParams) Return(up1 *model.UserParams, err error) *UserMock {
	if mmGetUserParams.mock.funcGetUserParams != nil {
		mmGetUserParams.mock.t.Fatalf("UserMock.GetUserParams mock is already set by Set")
	}

	if mmGetUserParams.defaultExpectation == nil {
		mmGetUserParams.defaultExpectation = &UserMockGetUserParamsExpectation{mock: mmGetUserParams.mock}
	}
	mmGetUserParams.defaultExpectation.results = &UserMockGetUserParamsResults{up1, err}
	mmGetUserParams.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserParams.mock
}

// Set uses given function f to mock the User.GetUserParams method
func (mmGetUserParams *mUserMockGetUserParams) Set(f func(ctx context.Context, paramsID int64) (up1 *model.UserParams, err error)) *UserMock {
	if mmGetUserParams.defaultExpectation != nil {
		mmGetUserParams.mock.t.Fatalf("Default expectation is already set for the User.GetUserParams method")
	}

	if len(mmGetUserParams.expectations) > 0 {
		mmGetUserParams.mock.t.Fatalf("Some expectations are already set for the User.GetUserParams method")
	}

	mmGetUserParams.mock.funcGetUserParams = f
	mmGetUserParams.mock.funcGetUserParamsOrigin = minimock.CallerInfo(1)
	return mmGetUserParams.mock
}

// When sets expectation for the User.GetUserParams which will trigger the result defined by the following
// Then helper
func (mmGetUserParams *mUserMockGetUserParams) When(ctx context.Context, paramsID int64) *UserMockGetUserParamsExpectation {
	if mmGetUserParams.mock.funcGetUserParams != nil {
		mmGetUserParams.mock.t.Fatalf("UserMock.GetUserParams mock is already set by Set")
	}

	expectation := &UserMockGetUserParamsExpectation{
		mock:               mmGetUserParams.mock,
		params:             &UserMockGetUserParamsParams{ctx, paramsID},
		expectationOrigins: UserMockGetUserParamsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserParams.expectations = append(mmGetUserParams.expectations, expectation)
	return expectation
}

// Then sets up User.GetUserParams return parameters for the expectation previously defined by the When method
func (e *UserMockGetUserParamsExpectation) Then(up1 *model.UserParams, err error) *UserMock {
	e.results = &UserMockGetUserParamsResults{up1, err}
	return e.mock
}

// Times sets number of times User.GetUserParams should be invoked
func (mmGetUserParams *mUserMockGetUserParams) Times(n uint64) *mUserMockGetUserParams {
	if n == 0 {
		mmGetUserParams.mock.t.Fatalf("Times of UserMock.GetUserParams mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserParams.expectedInvocations, n)
	mmGetUserParams.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserParams
}

func (mmGetUserParams *mUserMockGetUserParams) invocationsDone() bool {
	if len(mmGetUserParams.expectations) == 0 && mmGetUserParams.defaultExpectation == nil && mmGetUserParams.mock.funcGetUserParams == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserParams.mock.afterGetUserParamsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserParams.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserParams implements mm_storage.User
func (mmGetUserParams *UserMock) GetUserParams(ctx context.Context, paramsID int64) (up1 *model.UserParams, err error) {
	mm_atomic.AddUint64(&mmGetUserParams.beforeGetUserParamsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserParams.afterGetUserParamsCounter, 1)

	mmGetUserParams.t.Helper()

	if mmGetUserParams.inspectFuncGetUserParams != nil {
		mmGetUserParams.inspectFuncGetUserParams(ctx, paramsID)
	}

	mm_params := UserMockGetUserParamsParams{ctx, paramsID}

	// Record call args
	mmGetUserParams.GetUserParamsMock.mutex.Lock()
	mmGetUserParams.GetUserParamsMock.callArgs = append(mmGetUserParams.GetUserParamsMock.callArgs, &mm_params)
	mmGetUserParams.GetUserParamsMock.mutex.Unlock()

	for _, e := range mmGetUserParams.GetUserParamsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserParams.GetUserParamsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserParams.GetUserParamsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserParams.GetUserParamsMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserParams.GetUserParamsMock.defaultExpectation.paramPtrs

		mm_got := UserMockGetUserParamsParams{ctx, paramsID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserParams.t.Errorf("UserMock.GetUserParams got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserParams.GetUserParamsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.paramsID != nil && !minimock.Equal(*mm_want_ptrs.paramsID, mm_got.paramsID) {
				mmGetUserParams.t.Errorf("UserMock.GetUserParams got unexpected parameter paramsID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserParams.GetUserParamsMock.defaultExpectation.expectationOrigins.originParamsID, *mm_want_ptrs.paramsID, mm_got.paramsID, minimock.Diff(*mm_want_ptrs.paramsID, mm_got.paramsID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserParams.t.Errorf("UserMock.GetUserParams got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserParams.GetUserParamsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserParams.GetUserParamsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserParams.t.Fatal("No results are set for the UserMock.GetUserParams")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserParams.funcGetUserParams != nil {
		return mmGetUserParams.funcGetUserParams(ctx, paramsID)
	}
	mmGetUserParams.t.Fatalf("Unexpected call to UserMock.GetUserParams. %v %v", ctx, paramsID)
	return
}

// GetUserParamsAfterCounter returns a count of finished UserMock.GetUserParams invocations
func (mmGetUserParams *UserMock) GetUserParamsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserParams.afterGetUserParamsCounter)
}

// GetUserParamsBeforeCounter returns a count of UserMock.GetUserParams invocations
func (mmGetUserParams *UserMock) GetUserParamsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserParams.beforeGetUserParamsCounter)
}

// Calls returns a list of arguments used in each call to UserMock.GetUserParams.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserParams *mUserMockGetUserParams) Calls() []*UserMockGetUserParamsParams {
	mmGetUserParams.mutex.RLock()

	argCopy := make([]*UserMockGetUserParamsParams, len(mmGetUserParams.callArgs))
	copy(argCopy, mmGetUserParams.callArgs)

	mmGetUserParams.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserParamsDone returns true if the count of the GetUserParams invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockGetUserParamsDone() bool {
	if m.GetUserParamsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserParamsMock.invocationsDone()
}

// MinimockGetUserParamsInspect logs each unmet expectation
func (m *UserMock) MinimockGetUserParamsInspect() {
	for _, e := range m.GetUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.GetUserParams at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserParamsCounter := mm_atomic.LoadUint64(&m.afterGetUserParamsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserParamsMock.defaultExpectation != nil && afterGetUserParamsCounter < 1 {
		if m.GetUserParamsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.GetUserParams at\n%s", m.GetUserParamsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.GetUserParams at\n%s with params: %#v", m.GetUserParamsMock.defaultExpectation.expectationOrigins.origin, *m.GetUserParamsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserParams != nil && afterGetUserParamsCounter < 1 {
		m.t.Errorf("Expected call to UserMock.GetUserParams at\n%s", m.funcGetUserParamsOrigin)
	}

	if !m.GetUserParamsMock.invocationsDone() && afterGetUserParamsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.GetUserParams at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserParamsMock.expectedInvocations), m.GetUserParamsMock.expectedInvocationsOrigin, afterGetUserParamsCounter)
	}
}

type mUserMockUpdateUser struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockUpdateUserExpectation
	expectations       []*UserMockUpdateUserExpectation

	callArgs []*UserMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockUpdateUserExpectation specifies expectation struct of the User.UpdateUser
type UserMockUpdateUserExpectation struct {
	mock               *UserMock
	params             *UserMockUpdateUserParams
	paramPtrs          *UserMockUpdateUserParamPtrs
	expectationOrigins UserMockUpdateUserExpectationOrigins
	results            *UserMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserMockUpdateUserParams contains parameters of the User.UpdateUser
type UserMockUpdateUserParams struct {
	ctx    context.Context
	userID int64
	user   model.User
}

// UserMockUpdateUserParamPtrs contains pointers to parameters of the User.UpdateUser
type UserMockUpdateUserParamPtrs struct {
	ctx    *context.Context
	userID *int64
	user   *model.User
}

// UserMockUpdateUserResults contains results of the User.UpdateUser
type UserMockUpdateUserResults struct {
	err error
}

// UserMockUpdateUserOrigins contains origins of expectations of the User.UpdateUser
type UserMockUpdateUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originUser   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mUserMockUpdateUser) Optional() *mUserMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for User.UpdateUser
func (mmUpdateUser *mUserMockUpdateUser) Expect(ctx context.Context, userID int64, user model.User) *mUserMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &UserMockUpdateUserParams{ctx, userID, user}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for User.UpdateUser
func (mmUpdateUser *mUserMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mUserMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectUserIDParam2 sets up expected param userID for User.UpdateUser
func (mmUpdateUser *mUserMockUpdateUser) ExpectUserIDParam2(userID int64) *mUserMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.userID = &userID
	mmUpdateUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectUserParam3 sets up expected param user for User.UpdateUser
func (mmUpdateUser *mUserMockUpdateUser) ExpectUserParam3(user model.User) *mUserMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.user = &user
	mmUpdateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the User.UpdateUser
func (mmUpdateUser *mUserMockUpdateUser) Inspect(f func(ctx context.Context, userID int64, user model.User)) *mUserMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for UserMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by User.UpdateUser
func (mmUpdateUser *mUserMockUpdateUser) Return(err error) *UserMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &UserMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the User.UpdateUser method
func (mmUpdateUser *mUserMockUpdateUser) Set(f func(ctx context.Context, userID int64, user model.User) (err error)) *UserMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the User.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the User.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the User.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mUserMockUpdateUser) When(ctx context.Context, userID int64, user model.User) *UserMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserMock.UpdateUser mock is already set by Set")
	}

	expectation := &UserMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &UserMockUpdateUserParams{ctx, userID, user},
		expectationOrigins: UserMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up User.UpdateUser return parameters for the expectation previously defined by the When method
func (e *UserMockUpdateUserExpectation) Then(err error) *UserMock {
	e.results = &UserMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times User.UpdateUser should be invoked
func (mmUpdateUser *mUserMockUpdateUser) Times(n uint64) *mUserMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of UserMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mUserMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_storage.User
func (mmUpdateUser *UserMock) UpdateUser(ctx context.Context, userID int64, user model.User) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, userID, user)
	}

	mm_params := UserMockUpdateUserParams{ctx, userID, user}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := UserMockUpdateUserParams{ctx, userID, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("UserMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUpdateUser.t.Errorf("UserMock.UpdateUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmUpdateUser.t.Errorf("UserMock.UpdateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("UserMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the UserMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, userID, user)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to UserMock.UpdateUser. %v %v %v", ctx, userID, user)
	return
}

// UpdateUserAfterCounter returns a count of finished UserMock.UpdateUser invocations
func (mmUpdateUser *UserMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of UserMock.UpdateUser invocations
func (mmUpdateUser *UserMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to UserMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mUserMockUpdateUser) Calls() []*UserMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*UserMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *UserMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to UserMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

type mUserMockUpdateUserParams struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockUpdateUserParamsExpectation
	expectations       []*UserMockUpdateUserParamsExpectation

	callArgs []*UserMockUpdateUserParamsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockUpdateUserParamsExpectation specifies expectation struct of the User.UpdateUserParams
type UserMockUpdateUserParamsExpectation struct {
	mock               *UserMock
	params             *UserMockUpdateUserParamsParams
	paramPtrs          *UserMockUpdateUserParamsParamPtrs
	expectationOrigins UserMockUpdateUserParamsExpectationOrigins
	results            *UserMockUpdateUserParamsResults
	returnOrigin       string
	Counter            uint64
}

// UserMockUpdateUserParamsParams contains parameters of the User.UpdateUserParams
type UserMockUpdateUserParamsParams struct {
	ctx      context.Context
	paramsID int64
	params   model.UserParams
}

// UserMockUpdateUserParamsParamPtrs contains pointers to parameters of the User.UpdateUserParams
type UserMockUpdateUserParamsParamPtrs struct {
	ctx      *context.Context
	paramsID *int64
	params   *model.UserParams
}

// UserMockUpdateUserParamsResults contains results of the User.UpdateUserParams
type UserMockUpdateUserParamsResults struct {
	err error
}

// UserMockUpdateUserParamsOrigins contains origins of expectations of the User.UpdateUserParams
type UserMockUpdateUserParamsExpectationOrigins struct {
	origin         string
	originCtx      string
	originParamsID string
	originParams   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUserParams *mUserMockUpdateUserParams) Optional() *mUserMockUpdateUserParams {
	mmUpdateUserParams.optional = true
	return mmUpdateUserParams
}

// Expect sets up expected params for User.UpdateUserParams
func (mmUpdateUserParams *mUserMockUpdateUserParams) Expect(ctx context.Context, paramsID int64, params model.UserParams) *mUserMockUpdateUserParams {
	if mmUpdateUserParams.mock.funcUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Set")
	}

	if mmUpdateUserParams.defaultExpectation == nil {
		mmUpdateUserParams.defaultExpectation = &UserMockUpdateUserParamsExpectation{}
	}

	if mmUpdateUserParams.defaultExpectation.paramPtrs != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by ExpectParams functions")
	}

	mmUpdateUserParams.defaultExpectation.params = &UserMockUpdateUserParamsParams{ctx, paramsID, params}
	mmUpdateUserParams.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUserParams.expectations {
		if minimock.Equal(e.params, mmUpdateUserParams.defaultExpectation.params) {
			mmUpdateUserParams.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUserParams.defaultExpectation.params)
		}
	}

	return mmUpdateUserParams
}

// ExpectCtxParam1 sets up expected param ctx for User.UpdateUserParams
func (mmUpdateUserParams *mUserMockUpdateUserParams) ExpectCtxParam1(ctx context.Context) *mUserMockUpdateUserParams {
	if mmUpdateUserParams.mock.funcUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Set")
	}

	if mmUpdateUserParams.defaultExpectation == nil {
		mmUpdateUserParams.defaultExpectation = &UserMockUpdateUserParamsExpectation{}
	}

	if mmUpdateUserParams.defaultExpectation.params != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Expect")
	}

	if mmUpdateUserParams.defaultExpectation.paramPtrs == nil {
		mmUpdateUserParams.defaultExpectation.paramPtrs = &UserMockUpdateUserParamsParamPtrs{}
	}
	mmUpdateUserParams.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUserParams.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUserParams
}

// ExpectParamsIDParam2 sets up expected param paramsID for User.UpdateUserParams
func (mmUpdateUserParams *mUserMockUpdateUserParams) ExpectParamsIDParam2(paramsID int64) *mUserMockUpdateUserParams {
	if mmUpdateUserParams.mock.funcUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Set")
	}

	if mmUpdateUserParams.defaultExpectation == nil {
		mmUpdateUserParams.defaultExpectation = &UserMockUpdateUserParamsExpectation{}
	}

	if mmUpdateUserParams.defaultExpectation.params != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Expect")
	}

	if mmUpdateUserParams.defaultExpectation.paramPtrs == nil {
		mmUpdateUserParams.defaultExpectation.paramPtrs = &UserMockUpdateUserParamsParamPtrs{}
	}
	mmUpdateUserParams.defaultExpectation.paramPtrs.paramsID = &paramsID
	mmUpdateUserParams.defaultExpectation.expectationOrigins.originParamsID = minimock.CallerInfo(1)

	return mmUpdateUserParams
}

// ExpectParamsParam3 sets up expected param params for User.UpdateUserParams
func (mmUpdateUserParams *mUserMockUpdateUserParams) ExpectParamsParam3(params model.UserParams) *mUserMockUpdateUserParams {
	if mmUpdateUserParams.mock.funcUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Set")
	}

	if mmUpdateUserParams.defaultExpectation == nil {
		mmUpdateUserParams.defaultExpectation = &UserMockUpdateUserParamsExpectation{}
	}

	if mmUpdateUserParams.defaultExpectation.params != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Expect")
	}

	if mmUpdateUserParams.defaultExpectation.paramPtrs == nil {
		mmUpdateUserParams.defaultExpectation.paramPtrs = &UserMockUpdateUserParamsParamPtrs{}
	}
	mmUpdateUserParams.defaultExpectation.paramPtrs.params = &params
	mmUpdateUserParams.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmUpdateUserParams
}

// Inspect accepts an inspector function that has same arguments as the User.UpdateUserParams
func (mmUpdateUserParams *mUserMockUpdateUserParams) Inspect(f func(ctx context.Context, paramsID int64, params model.UserParams)) *mUserMockUpdateUserParams {
	if mmUpdateUserParams.mock.inspectFuncUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("Inspect function is already set for UserMock.UpdateUserParams")
	}

	mmUpdateUserParams.mock.inspectFuncUpdateUserParams = f

	return mmUpdateUserParams
}

// Return sets up results that will be returned by User.UpdateUserParams
func (mmUpdateUserParams *mUserMockUpdateUserParams) Return(err error) *UserMock {
	if mmUpdateUserParams.mock.funcUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Set")
	}

	if mmUpdateUserParams.defaultExpectation == nil {
		mmUpdateUserParams.defaultExpectation = &UserMockUpdateUserParamsExpectation{mock: mmUpdateUserParams.mock}
	}
	mmUpdateUserParams.defaultExpectation.results = &UserMockUpdateUserParamsResults{err}
	mmUpdateUserParams.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUserParams.mock
}

// Set uses given function f to mock the User.UpdateUserParams method
func (mmUpdateUserParams *mUserMockUpdateUserParams) Set(f func(ctx context.Context, paramsID int64, params model.UserParams) (err error)) *UserMock {
	if mmUpdateUserParams.defaultExpectation != nil {
		mmUpdateUserParams.mock.t.Fatalf("Default expectation is already set for the User.UpdateUserParams method")
	}

	if len(mmUpdateUserParams.expectations) > 0 {
		mmUpdateUserParams.mock.t.Fatalf("Some expectations are already set for the User.UpdateUserParams method")
	}

	mmUpdateUserParams.mock.funcUpdateUserParams = f
	mmUpdateUserParams.mock.funcUpdateUserParamsOrigin = minimock.CallerInfo(1)
	return mmUpdateUserParams.mock
}

// When sets expectation for the User.UpdateUserParams which will trigger the result defined by the following
// Then helper
func (mmUpdateUserParams *mUserMockUpdateUserParams) When(ctx context.Context, paramsID int64, params model.UserParams) *UserMockUpdateUserParamsExpectation {
	if mmUpdateUserParams.mock.funcUpdateUserParams != nil {
		mmUpdateUserParams.mock.t.Fatalf("UserMock.UpdateUserParams mock is already set by Set")
	}

	expectation := &UserMockUpdateUserParamsExpectation{
		mock:               mmUpdateUserParams.mock,
		params:             &UserMockUpdateUserParamsParams{ctx, paramsID, params},
		expectationOrigins: UserMockUpdateUserParamsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUserParams.expectations = append(mmUpdateUserParams.expectations, expectation)
	return expectation
}

// Then sets up User.UpdateUserParams return parameters for the expectation previously defined by the When method
func (e *UserMockUpdateUserParamsExpectation) Then(err error) *UserMock {
	e.results = &UserMockUpdateUserParamsResults{err}
	return e.mock
}

// Times sets number of times User.UpdateUserParams should be invoked
func (mmUpdateUserParams *mUserMockUpdateUserParams) Times(n uint64) *mUserMockUpdateUserParams {
	if n == 0 {
		mmUpdateUserParams.mock.t.Fatalf("Times of UserMock.UpdateUserParams mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUserParams.expectedInvocations, n)
	mmUpdateUserParams.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUserParams
}

func (mmUpdateUserParams *mUserMockUpdateUserParams) invocationsDone() bool {
	if len(mmUpdateUserParams.expectations) == 0 && mmUpdateUserParams.defaultExpectation == nil && mmUpdateUserParams.mock.funcUpdateUserParams == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUserParams.mock.afterUpdateUserParamsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUserParams.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUserParams implements mm_storage.User
func (mmUpdateUserParams *UserMock) UpdateUserParams(ctx context.Context, paramsID int64, params model.UserParams) (err error) {
	mm_atomic.AddUint64(&mmUpdateUserParams.beforeUpdateUserParamsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUserParams.afterUpdateUserParamsCounter, 1)

	mmUpdateUserParams.t.Helper()

	if mmUpdateUserParams.inspectFuncUpdateUserParams != nil {
		mmUpdateUserParams.inspectFuncUpdateUserParams(ctx, paramsID, params)
	}

	mm_params := UserMockUpdateUserParamsParams{ctx, paramsID, params}

	// Record call args
	mmUpdateUserParams.UpdateUserParamsMock.mutex.Lock()
	mmUpdateUserParams.UpdateUserParamsMock.callArgs = append(mmUpdateUserParams.UpdateUserParamsMock.callArgs, &mm_params)
	mmUpdateUserParams.UpdateUserParamsMock.mutex.Unlock()

	for _, e := range mmUpdateUserParams.UpdateUserParamsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.paramPtrs

		mm_got := UserMockUpdateUserParamsParams{ctx, paramsID, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUserParams.t.Errorf("UserMock.UpdateUserParams got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.paramsID != nil && !minimock.Equal(*mm_want_ptrs.paramsID, mm_got.paramsID) {
				mmUpdateUserParams.t.Errorf("UserMock.UpdateUserParams got unexpected parameter paramsID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.expectationOrigins.originParamsID, *mm_want_ptrs.paramsID, mm_got.paramsID, minimock.Diff(*mm_want_ptrs.paramsID, mm_got.paramsID))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmUpdateUserParams.t.Errorf("UserMock.UpdateUserParams got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUserParams.t.Errorf("UserMock.UpdateUserParams got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUserParams.UpdateUserParamsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUserParams.t.Fatal("No results are set for the UserMock.UpdateUserParams")
		}
		return (*mm_results).err
	}
	if mmUpdateUserParams.funcUpdateUserParams != nil {
		return mmUpdateUserParams.funcUpdateUserParams(ctx, paramsID, params)
	}
	mmUpdateUserParams.t.Fatalf("Unexpected call to UserMock.UpdateUserParams. %v %v %v", ctx, paramsID, params)
	return
}

// UpdateUserParamsAfterCounter returns a count of finished UserMock.UpdateUserParams invocations
func (mmUpdateUserParams *UserMock) UpdateUserParamsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserParams.afterUpdateUserParamsCounter)
}

// UpdateUserParamsBeforeCounter returns a count of UserMock.UpdateUserParams invocations
func (mmUpdateUserParams *UserMock) UpdateUserParamsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserParams.beforeUpdateUserParamsCounter)
}

// Calls returns a list of arguments used in each call to UserMock.UpdateUserParams.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUserParams *mUserMockUpdateUserParams) Calls() []*UserMockUpdateUserParamsParams {
	mmUpdateUserParams.mutex.RLock()

	argCopy := make([]*UserMockUpdateUserParamsParams, len(mmUpdateUserParams.callArgs))
	copy(argCopy, mmUpdateUserParams.callArgs)

	mmUpdateUserParams.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserParamsDone returns true if the count of the UpdateUserParams invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockUpdateUserParamsDone() bool {
	if m.UpdateUserParamsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserParamsMock.invocationsDone()
}

// MinimockUpdateUserParamsInspect logs each unmet expectation
func (m *UserMock) MinimockUpdateUserParamsInspect() {
	for _, e := range m.UpdateUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.UpdateUserParams at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserParamsCounter := mm_atomic.LoadUint64(&m.afterUpdateUserParamsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserParamsMock.defaultExpectation != nil && afterUpdateUserParamsCounter < 1 {
		if m.UpdateUserParamsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.UpdateUserParams at\n%s", m.UpdateUserParamsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.UpdateUserParams at\n%s with params: %#v", m.UpdateUserParamsMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserParamsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUserParams != nil && afterUpdateUserParamsCounter < 1 {
		m.t.Errorf("Expected call to UserMock.UpdateUserParams at\n%s", m.funcUpdateUserParamsOrigin)
	}

	if !m.UpdateUserParamsMock.invocationsDone() && afterUpdateUserParamsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.UpdateUserParams at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserParamsMock.expectedInvocations), m.UpdateUserParamsMock.expectedInvocationsOrigin, afterUpdateUserParamsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockCreateUserParamsInspect()

			m.MinimockFillUserParamsInspect()

			m.MinimockGetFullUserInspect()

			m.MinimockGetUserInspect()

			m.MinimockGetUserParamsInspect()

			m.MinimockUpdateUserInspect()

			m.MinimockUpdateUserParamsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockCreateUserParamsDone() &&
		m.MinimockFillUserParamsDone() &&
		m.MinimockGetFullUserDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockGetUserParamsDone() &&
		m.MinimockUpdateUserDone() &&
		m.MinimockUpdateUserParamsDone()
}
