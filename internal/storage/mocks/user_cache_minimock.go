// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/vl-usp/water_bot/internal/storage.UserCache -o user_cache_minimock.go -n UserCacheMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/vl-usp/water_bot/internal/model"
)

// UserCacheMock implements mm_storage.UserCache
type UserCacheMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetUserParams          func(ctx context.Context, userID int64) (up1 *model.UserParams, err error)
	funcGetUserParamsOrigin    string
	inspectFuncGetUserParams   func(ctx context.Context, userID int64)
	afterGetUserParamsCounter  uint64
	beforeGetUserParamsCounter uint64
	GetUserParamsMock          mUserCacheMockGetUserParams

	funcSaveUserParam          func(ctx context.Context, userID int64, field string, value interface{}) (err error)
	funcSaveUserParamOrigin    string
	inspectFuncSaveUserParam   func(ctx context.Context, userID int64, field string, value interface{})
	afterSaveUserParamCounter  uint64
	beforeSaveUserParamCounter uint64
	SaveUserParamMock          mUserCacheMockSaveUserParam
}

// NewUserCacheMock returns a mock for mm_storage.UserCache
func NewUserCacheMock(t minimock.Tester) *UserCacheMock {
	m := &UserCacheMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetUserParamsMock = mUserCacheMockGetUserParams{mock: m}
	m.GetUserParamsMock.callArgs = []*UserCacheMockGetUserParamsParams{}

	m.SaveUserParamMock = mUserCacheMockSaveUserParam{mock: m}
	m.SaveUserParamMock.callArgs = []*UserCacheMockSaveUserParamParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserCacheMockGetUserParams struct {
	optional           bool
	mock               *UserCacheMock
	defaultExpectation *UserCacheMockGetUserParamsExpectation
	expectations       []*UserCacheMockGetUserParamsExpectation

	callArgs []*UserCacheMockGetUserParamsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheMockGetUserParamsExpectation specifies expectation struct of the UserCache.GetUserParams
type UserCacheMockGetUserParamsExpectation struct {
	mock               *UserCacheMock
	params             *UserCacheMockGetUserParamsParams
	paramPtrs          *UserCacheMockGetUserParamsParamPtrs
	expectationOrigins UserCacheMockGetUserParamsExpectationOrigins
	results            *UserCacheMockGetUserParamsResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheMockGetUserParamsParams contains parameters of the UserCache.GetUserParams
type UserCacheMockGetUserParamsParams struct {
	ctx    context.Context
	userID int64
}

// UserCacheMockGetUserParamsParamPtrs contains pointers to parameters of the UserCache.GetUserParams
type UserCacheMockGetUserParamsParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// UserCacheMockGetUserParamsResults contains results of the UserCache.GetUserParams
type UserCacheMockGetUserParamsResults struct {
	up1 *model.UserParams
	err error
}

// UserCacheMockGetUserParamsOrigins contains origins of expectations of the UserCache.GetUserParams
type UserCacheMockGetUserParamsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserParams *mUserCacheMockGetUserParams) Optional() *mUserCacheMockGetUserParams {
	mmGetUserParams.optional = true
	return mmGetUserParams
}

// Expect sets up expected params for UserCache.GetUserParams
func (mmGetUserParams *mUserCacheMockGetUserParams) Expect(ctx context.Context, userID int64) *mUserCacheMockGetUserParams {
	if mmGetUserParams.mock.funcGetUserParams != nil {
		mmGetUserParams.mock.t.Fatalf("UserCacheMock.GetUserParams mock is already set by Set")
	}

	if mmGetUserParams.defaultExpectation == nil {
		mmGetUserParams.defaultExpectation = &UserCacheMockGetUserParamsExpectation{}
	}

	if mmGetUserParams.defaultExpectation.paramPtrs != nil {
		mmGetUserParams.mock.t.Fatalf("UserCacheMock.GetUserParams mock is already set by ExpectParams functions")
	}

	mmGetUserParams.defaultExpectation.params = &UserCacheMockGetUserParamsParams{ctx, userID}
	mmGetUserParams.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserParams.expectations {
		if minimock.Equal(e.params, mmGetUserParams.defaultExpectation.params) {
			mmGetUserParams.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserParams.defaultExpectation.params)
		}
	}

	return mmGetUserParams
}

// ExpectCtxParam1 sets up expected param ctx for UserCache.GetUserParams
func (mmGetUserParams *mUserCacheMockGetUserParams) ExpectCtxParam1(ctx context.Context) *mUserCacheMockGetUserParams {
	if mmGetUserParams.mock.funcGetUserParams != nil {
		mmGetUserParams.mock.t.Fatalf("UserCacheMock.GetUserParams mock is already set by Set")
	}

	if mmGetUserParams.defaultExpectation == nil {
		mmGetUserParams.defaultExpectation = &UserCacheMockGetUserParamsExpectation{}
	}

	if mmGetUserParams.defaultExpectation.params != nil {
		mmGetUserParams.mock.t.Fatalf("UserCacheMock.GetUserParams mock is already set by Expect")
	}

	if mmGetUserParams.defaultExpectation.paramPtrs == nil {
		mmGetUserParams.defaultExpectation.paramPtrs = &UserCacheMockGetUserParamsParamPtrs{}
	}
	mmGetUserParams.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserParams.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserParams
}

// ExpectUserIDParam2 sets up expected param userID for UserCache.GetUserParams
func (mmGetUserParams *mUserCacheMockGetUserParams) ExpectUserIDParam2(userID int64) *mUserCacheMockGetUserParams {
	if mmGetUserParams.mock.funcGetUserParams != nil {
		mmGetUserParams.mock.t.Fatalf("UserCacheMock.GetUserParams mock is already set by Set")
	}

	if mmGetUserParams.defaultExpectation == nil {
		mmGetUserParams.defaultExpectation = &UserCacheMockGetUserParamsExpectation{}
	}

	if mmGetUserParams.defaultExpectation.params != nil {
		mmGetUserParams.mock.t.Fatalf("UserCacheMock.GetUserParams mock is already set by Expect")
	}

	if mmGetUserParams.defaultExpectation.paramPtrs == nil {
		mmGetUserParams.defaultExpectation.paramPtrs = &UserCacheMockGetUserParamsParamPtrs{}
	}
	mmGetUserParams.defaultExpectation.paramPtrs.userID = &userID
	mmGetUserParams.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetUserParams
}

// Inspect accepts an inspector function that has same arguments as the UserCache.GetUserParams
func (mmGetUserParams *mUserCacheMockGetUserParams) Inspect(f func(ctx context.Context, userID int64)) *mUserCacheMockGetUserParams {
	if mmGetUserParams.mock.inspectFuncGetUserParams != nil {
		mmGetUserParams.mock.t.Fatalf("Inspect function is already set for UserCacheMock.GetUserParams")
	}

	mmGetUserParams.mock.inspectFuncGetUserParams = f

	return mmGetUserParams
}

// Return sets up results that will be returned by UserCache.GetUserParams
func (mmGetUserParams *mUserCacheMockGetUserParams) Return(up1 *model.UserParams, err error) *UserCacheMock {
	if mmGetUserParams.mock.funcGetUserParams != nil {
		mmGetUserParams.mock.t.Fatalf("UserCacheMock.GetUserParams mock is already set by Set")
	}

	if mmGetUserParams.defaultExpectation == nil {
		mmGetUserParams.defaultExpectation = &UserCacheMockGetUserParamsExpectation{mock: mmGetUserParams.mock}
	}
	mmGetUserParams.defaultExpectation.results = &UserCacheMockGetUserParamsResults{up1, err}
	mmGetUserParams.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserParams.mock
}

// Set uses given function f to mock the UserCache.GetUserParams method
func (mmGetUserParams *mUserCacheMockGetUserParams) Set(f func(ctx context.Context, userID int64) (up1 *model.UserParams, err error)) *UserCacheMock {
	if mmGetUserParams.defaultExpectation != nil {
		mmGetUserParams.mock.t.Fatalf("Default expectation is already set for the UserCache.GetUserParams method")
	}

	if len(mmGetUserParams.expectations) > 0 {
		mmGetUserParams.mock.t.Fatalf("Some expectations are already set for the UserCache.GetUserParams method")
	}

	mmGetUserParams.mock.funcGetUserParams = f
	mmGetUserParams.mock.funcGetUserParamsOrigin = minimock.CallerInfo(1)
	return mmGetUserParams.mock
}

// When sets expectation for the UserCache.GetUserParams which will trigger the result defined by the following
// Then helper
func (mmGetUserParams *mUserCacheMockGetUserParams) When(ctx context.Context, userID int64) *UserCacheMockGetUserParamsExpectation {
	if mmGetUserParams.mock.funcGetUserParams != nil {
		mmGetUserParams.mock.t.Fatalf("UserCacheMock.GetUserParams mock is already set by Set")
	}

	expectation := &UserCacheMockGetUserParamsExpectation{
		mock:               mmGetUserParams.mock,
		params:             &UserCacheMockGetUserParamsParams{ctx, userID},
		expectationOrigins: UserCacheMockGetUserParamsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserParams.expectations = append(mmGetUserParams.expectations, expectation)
	return expectation
}

// Then sets up UserCache.GetUserParams return parameters for the expectation previously defined by the When method
func (e *UserCacheMockGetUserParamsExpectation) Then(up1 *model.UserParams, err error) *UserCacheMock {
	e.results = &UserCacheMockGetUserParamsResults{up1, err}
	return e.mock
}

// Times sets number of times UserCache.GetUserParams should be invoked
func (mmGetUserParams *mUserCacheMockGetUserParams) Times(n uint64) *mUserCacheMockGetUserParams {
	if n == 0 {
		mmGetUserParams.mock.t.Fatalf("Times of UserCacheMock.GetUserParams mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserParams.expectedInvocations, n)
	mmGetUserParams.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserParams
}

func (mmGetUserParams *mUserCacheMockGetUserParams) invocationsDone() bool {
	if len(mmGetUserParams.expectations) == 0 && mmGetUserParams.defaultExpectation == nil && mmGetUserParams.mock.funcGetUserParams == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserParams.mock.afterGetUserParamsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserParams.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserParams implements mm_storage.UserCache
func (mmGetUserParams *UserCacheMock) GetUserParams(ctx context.Context, userID int64) (up1 *model.UserParams, err error) {
	mm_atomic.AddUint64(&mmGetUserParams.beforeGetUserParamsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserParams.afterGetUserParamsCounter, 1)

	mmGetUserParams.t.Helper()

	if mmGetUserParams.inspectFuncGetUserParams != nil {
		mmGetUserParams.inspectFuncGetUserParams(ctx, userID)
	}

	mm_params := UserCacheMockGetUserParamsParams{ctx, userID}

	// Record call args
	mmGetUserParams.GetUserParamsMock.mutex.Lock()
	mmGetUserParams.GetUserParamsMock.callArgs = append(mmGetUserParams.GetUserParamsMock.callArgs, &mm_params)
	mmGetUserParams.GetUserParamsMock.mutex.Unlock()

	for _, e := range mmGetUserParams.GetUserParamsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserParams.GetUserParamsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserParams.GetUserParamsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserParams.GetUserParamsMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserParams.GetUserParamsMock.defaultExpectation.paramPtrs

		mm_got := UserCacheMockGetUserParamsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserParams.t.Errorf("UserCacheMock.GetUserParams got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserParams.GetUserParamsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUserParams.t.Errorf("UserCacheMock.GetUserParams got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserParams.GetUserParamsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserParams.t.Errorf("UserCacheMock.GetUserParams got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserParams.GetUserParamsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserParams.GetUserParamsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserParams.t.Fatal("No results are set for the UserCacheMock.GetUserParams")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserParams.funcGetUserParams != nil {
		return mmGetUserParams.funcGetUserParams(ctx, userID)
	}
	mmGetUserParams.t.Fatalf("Unexpected call to UserCacheMock.GetUserParams. %v %v", ctx, userID)
	return
}

// GetUserParamsAfterCounter returns a count of finished UserCacheMock.GetUserParams invocations
func (mmGetUserParams *UserCacheMock) GetUserParamsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserParams.afterGetUserParamsCounter)
}

// GetUserParamsBeforeCounter returns a count of UserCacheMock.GetUserParams invocations
func (mmGetUserParams *UserCacheMock) GetUserParamsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserParams.beforeGetUserParamsCounter)
}

// Calls returns a list of arguments used in each call to UserCacheMock.GetUserParams.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserParams *mUserCacheMockGetUserParams) Calls() []*UserCacheMockGetUserParamsParams {
	mmGetUserParams.mutex.RLock()

	argCopy := make([]*UserCacheMockGetUserParamsParams, len(mmGetUserParams.callArgs))
	copy(argCopy, mmGetUserParams.callArgs)

	mmGetUserParams.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserParamsDone returns true if the count of the GetUserParams invocations corresponds
// the number of defined expectations
func (m *UserCacheMock) MinimockGetUserParamsDone() bool {
	if m.GetUserParamsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserParamsMock.invocationsDone()
}

// MinimockGetUserParamsInspect logs each unmet expectation
func (m *UserCacheMock) MinimockGetUserParamsInspect() {
	for _, e := range m.GetUserParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheMock.GetUserParams at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserParamsCounter := mm_atomic.LoadUint64(&m.afterGetUserParamsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserParamsMock.defaultExpectation != nil && afterGetUserParamsCounter < 1 {
		if m.GetUserParamsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheMock.GetUserParams at\n%s", m.GetUserParamsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheMock.GetUserParams at\n%s with params: %#v", m.GetUserParamsMock.defaultExpectation.expectationOrigins.origin, *m.GetUserParamsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserParams != nil && afterGetUserParamsCounter < 1 {
		m.t.Errorf("Expected call to UserCacheMock.GetUserParams at\n%s", m.funcGetUserParamsOrigin)
	}

	if !m.GetUserParamsMock.invocationsDone() && afterGetUserParamsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheMock.GetUserParams at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserParamsMock.expectedInvocations), m.GetUserParamsMock.expectedInvocationsOrigin, afterGetUserParamsCounter)
	}
}

type mUserCacheMockSaveUserParam struct {
	optional           bool
	mock               *UserCacheMock
	defaultExpectation *UserCacheMockSaveUserParamExpectation
	expectations       []*UserCacheMockSaveUserParamExpectation

	callArgs []*UserCacheMockSaveUserParamParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheMockSaveUserParamExpectation specifies expectation struct of the UserCache.SaveUserParam
type UserCacheMockSaveUserParamExpectation struct {
	mock               *UserCacheMock
	params             *UserCacheMockSaveUserParamParams
	paramPtrs          *UserCacheMockSaveUserParamParamPtrs
	expectationOrigins UserCacheMockSaveUserParamExpectationOrigins
	results            *UserCacheMockSaveUserParamResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheMockSaveUserParamParams contains parameters of the UserCache.SaveUserParam
type UserCacheMockSaveUserParamParams struct {
	ctx    context.Context
	userID int64
	field  string
	value  interface{}
}

// UserCacheMockSaveUserParamParamPtrs contains pointers to parameters of the UserCache.SaveUserParam
type UserCacheMockSaveUserParamParamPtrs struct {
	ctx    *context.Context
	userID *int64
	field  *string
	value  *interface{}
}

// UserCacheMockSaveUserParamResults contains results of the UserCache.SaveUserParam
type UserCacheMockSaveUserParamResults struct {
	err error
}

// UserCacheMockSaveUserParamOrigins contains origins of expectations of the UserCache.SaveUserParam
type UserCacheMockSaveUserParamExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originField  string
	originValue  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveUserParam *mUserCacheMockSaveUserParam) Optional() *mUserCacheMockSaveUserParam {
	mmSaveUserParam.optional = true
	return mmSaveUserParam
}

// Expect sets up expected params for UserCache.SaveUserParam
func (mmSaveUserParam *mUserCacheMockSaveUserParam) Expect(ctx context.Context, userID int64, field string, value interface{}) *mUserCacheMockSaveUserParam {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserCacheMock.SaveUserParam mock is already set by Set")
	}

	if mmSaveUserParam.defaultExpectation == nil {
		mmSaveUserParam.defaultExpectation = &UserCacheMockSaveUserParamExpectation{}
	}

	if mmSaveUserParam.defaultExpectation.paramPtrs != nil {
		mmSaveUserParam.mock.t.Fatalf("UserCacheMock.SaveUserParam mock is already set by ExpectParams functions")
	}

	mmSaveUserParam.defaultExpectation.params = &UserCacheMockSaveUserParamParams{ctx, userID, field, value}
	mmSaveUserParam.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveUserParam.expectations {
		if minimock.Equal(e.params, mmSaveUserParam.defaultExpectation.params) {
			mmSaveUserParam.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveUserParam.defaultExpectation.params)
		}
	}

	return mmSaveUserParam
}

// ExpectCtxParam1 sets up expected param ctx for UserCache.SaveUserParam
func (mmSaveUserParam *mUserCacheMockSaveUserParam) ExpectCtxParam1(ctx context.Context) *mUserCacheMockSaveUserParam {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserCacheMock.SaveUserParam mock is already set by Set")
	}

	if mmSaveUserParam.defaultExpectation == nil {
		mmSaveUserParam.defaultExpectation = &UserCacheMockSaveUserParamExpectation{}
	}

	if mmSaveUserParam.defaultExpectation.params != nil {
		mmSaveUserParam.mock.t.Fatalf("UserCacheMock.SaveUserParam mock is already set by Expect")
	}

	if mmSaveUserParam.defaultExpectation.paramPtrs == nil {
		mmSaveUserParam.defaultExpectation.paramPtrs = &UserCacheMockSaveUserParamParamPtrs{}
	}
	mmSaveUserParam.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveUserParam.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveUserParam
}

// ExpectUserIDParam2 sets up expected param userID for UserCache.SaveUserParam
func (mmSaveUserParam *mUserCacheMockSaveUserParam) ExpectUserIDParam2(userID int64) *mUserCacheMockSaveUserParam {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserCacheMock.SaveUserParam mock is already set by Set")
	}

	if mmSaveUserParam.defaultExpectation == nil {
		mmSaveUserParam.defaultExpectation = &UserCacheMockSaveUserParamExpectation{}
	}

	if mmSaveUserParam.defaultExpectation.params != nil {
		mmSaveUserParam.mock.t.Fatalf("UserCacheMock.SaveUserParam mock is already set by Expect")
	}

	if mmSaveUserParam.defaultExpectation.paramPtrs == nil {
		mmSaveUserParam.defaultExpectation.paramPtrs = &UserCacheMockSaveUserParamParamPtrs{}
	}
	mmSaveUserParam.defaultExpectation.paramPtrs.userID = &userID
	mmSaveUserParam.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmSaveUserParam
}

// ExpectFieldParam3 sets up expected param field for UserCache.SaveUserParam
func (mmSaveUserParam *mUserCacheMockSaveUserParam) ExpectFieldParam3(field string) *mUserCacheMockSaveUserParam {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserCacheMock.SaveUserParam mock is already set by Set")
	}

	if mmSaveUserParam.defaultExpectation == nil {
		mmSaveUserParam.defaultExpectation = &UserCacheMockSaveUserParamExpectation{}
	}

	if mmSaveUserParam.defaultExpectation.params != nil {
		mmSaveUserParam.mock.t.Fatalf("UserCacheMock.SaveUserParam mock is already set by Expect")
	}

	if mmSaveUserParam.defaultExpectation.paramPtrs == nil {
		mmSaveUserParam.defaultExpectation.paramPtrs = &UserCacheMockSaveUserParamParamPtrs{}
	}
	mmSaveUserParam.defaultExpectation.paramPtrs.field = &field
	mmSaveUserParam.defaultExpectation.expectationOrigins.originField = minimock.CallerInfo(1)

	return mmSaveUserParam
}

// ExpectValueParam4 sets up expected param value for UserCache.SaveUserParam
func (mmSaveUserParam *mUserCacheMockSaveUserParam) ExpectValueParam4(value interface{}) *mUserCacheMockSaveUserParam {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserCacheMock.SaveUserParam mock is already set by Set")
	}

	if mmSaveUserParam.defaultExpectation == nil {
		mmSaveUserParam.defaultExpectation = &UserCacheMockSaveUserParamExpectation{}
	}

	if mmSaveUserParam.defaultExpectation.params != nil {
		mmSaveUserParam.mock.t.Fatalf("UserCacheMock.SaveUserParam mock is already set by Expect")
	}

	if mmSaveUserParam.defaultExpectation.paramPtrs == nil {
		mmSaveUserParam.defaultExpectation.paramPtrs = &UserCacheMockSaveUserParamParamPtrs{}
	}
	mmSaveUserParam.defaultExpectation.paramPtrs.value = &value
	mmSaveUserParam.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSaveUserParam
}

// Inspect accepts an inspector function that has same arguments as the UserCache.SaveUserParam
func (mmSaveUserParam *mUserCacheMockSaveUserParam) Inspect(f func(ctx context.Context, userID int64, field string, value interface{})) *mUserCacheMockSaveUserParam {
	if mmSaveUserParam.mock.inspectFuncSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("Inspect function is already set for UserCacheMock.SaveUserParam")
	}

	mmSaveUserParam.mock.inspectFuncSaveUserParam = f

	return mmSaveUserParam
}

// Return sets up results that will be returned by UserCache.SaveUserParam
func (mmSaveUserParam *mUserCacheMockSaveUserParam) Return(err error) *UserCacheMock {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserCacheMock.SaveUserParam mock is already set by Set")
	}

	if mmSaveUserParam.defaultExpectation == nil {
		mmSaveUserParam.defaultExpectation = &UserCacheMockSaveUserParamExpectation{mock: mmSaveUserParam.mock}
	}
	mmSaveUserParam.defaultExpectation.results = &UserCacheMockSaveUserParamResults{err}
	mmSaveUserParam.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveUserParam.mock
}

// Set uses given function f to mock the UserCache.SaveUserParam method
func (mmSaveUserParam *mUserCacheMockSaveUserParam) Set(f func(ctx context.Context, userID int64, field string, value interface{}) (err error)) *UserCacheMock {
	if mmSaveUserParam.defaultExpectation != nil {
		mmSaveUserParam.mock.t.Fatalf("Default expectation is already set for the UserCache.SaveUserParam method")
	}

	if len(mmSaveUserParam.expectations) > 0 {
		mmSaveUserParam.mock.t.Fatalf("Some expectations are already set for the UserCache.SaveUserParam method")
	}

	mmSaveUserParam.mock.funcSaveUserParam = f
	mmSaveUserParam.mock.funcSaveUserParamOrigin = minimock.CallerInfo(1)
	return mmSaveUserParam.mock
}

// When sets expectation for the UserCache.SaveUserParam which will trigger the result defined by the following
// Then helper
func (mmSaveUserParam *mUserCacheMockSaveUserParam) When(ctx context.Context, userID int64, field string, value interface{}) *UserCacheMockSaveUserParamExpectation {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserCacheMock.SaveUserParam mock is already set by Set")
	}

	expectation := &UserCacheMockSaveUserParamExpectation{
		mock:               mmSaveUserParam.mock,
		params:             &UserCacheMockSaveUserParamParams{ctx, userID, field, value},
		expectationOrigins: UserCacheMockSaveUserParamExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveUserParam.expectations = append(mmSaveUserParam.expectations, expectation)
	return expectation
}

// Then sets up UserCache.SaveUserParam return parameters for the expectation previously defined by the When method
func (e *UserCacheMockSaveUserParamExpectation) Then(err error) *UserCacheMock {
	e.results = &UserCacheMockSaveUserParamResults{err}
	return e.mock
}

// Times sets number of times UserCache.SaveUserParam should be invoked
func (mmSaveUserParam *mUserCacheMockSaveUserParam) Times(n uint64) *mUserCacheMockSaveUserParam {
	if n == 0 {
		mmSaveUserParam.mock.t.Fatalf("Times of UserCacheMock.SaveUserParam mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveUserParam.expectedInvocations, n)
	mmSaveUserParam.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveUserParam
}

func (mmSaveUserParam *mUserCacheMockSaveUserParam) invocationsDone() bool {
	if len(mmSaveUserParam.expectations) == 0 && mmSaveUserParam.defaultExpectation == nil && mmSaveUserParam.mock.funcSaveUserParam == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveUserParam.mock.afterSaveUserParamCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveUserParam.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveUserParam implements mm_storage.UserCache
func (mmSaveUserParam *UserCacheMock) SaveUserParam(ctx context.Context, userID int64, field string, value interface{}) (err error) {
	mm_atomic.AddUint64(&mmSaveUserParam.beforeSaveUserParamCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveUserParam.afterSaveUserParamCounter, 1)

	mmSaveUserParam.t.Helper()

	if mmSaveUserParam.inspectFuncSaveUserParam != nil {
		mmSaveUserParam.inspectFuncSaveUserParam(ctx, userID, field, value)
	}

	mm_params := UserCacheMockSaveUserParamParams{ctx, userID, field, value}

	// Record call args
	mmSaveUserParam.SaveUserParamMock.mutex.Lock()
	mmSaveUserParam.SaveUserParamMock.callArgs = append(mmSaveUserParam.SaveUserParamMock.callArgs, &mm_params)
	mmSaveUserParam.SaveUserParamMock.mutex.Unlock()

	for _, e := range mmSaveUserParam.SaveUserParamMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveUserParam.SaveUserParamMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveUserParam.SaveUserParamMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveUserParam.SaveUserParamMock.defaultExpectation.params
		mm_want_ptrs := mmSaveUserParam.SaveUserParamMock.defaultExpectation.paramPtrs

		mm_got := UserCacheMockSaveUserParamParams{ctx, userID, field, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveUserParam.t.Errorf("UserCacheMock.SaveUserParam got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveUserParam.SaveUserParamMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmSaveUserParam.t.Errorf("UserCacheMock.SaveUserParam got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveUserParam.SaveUserParamMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.field != nil && !minimock.Equal(*mm_want_ptrs.field, mm_got.field) {
				mmSaveUserParam.t.Errorf("UserCacheMock.SaveUserParam got unexpected parameter field, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveUserParam.SaveUserParamMock.defaultExpectation.expectationOrigins.originField, *mm_want_ptrs.field, mm_got.field, minimock.Diff(*mm_want_ptrs.field, mm_got.field))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSaveUserParam.t.Errorf("UserCacheMock.SaveUserParam got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveUserParam.SaveUserParamMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveUserParam.t.Errorf("UserCacheMock.SaveUserParam got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveUserParam.SaveUserParamMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveUserParam.SaveUserParamMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveUserParam.t.Fatal("No results are set for the UserCacheMock.SaveUserParam")
		}
		return (*mm_results).err
	}
	if mmSaveUserParam.funcSaveUserParam != nil {
		return mmSaveUserParam.funcSaveUserParam(ctx, userID, field, value)
	}
	mmSaveUserParam.t.Fatalf("Unexpected call to UserCacheMock.SaveUserParam. %v %v %v %v", ctx, userID, field, value)
	return
}

// SaveUserParamAfterCounter returns a count of finished UserCacheMock.SaveUserParam invocations
func (mmSaveUserParam *UserCacheMock) SaveUserParamAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUserParam.afterSaveUserParamCounter)
}

// SaveUserParamBeforeCounter returns a count of UserCacheMock.SaveUserParam invocations
func (mmSaveUserParam *UserCacheMock) SaveUserParamBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUserParam.beforeSaveUserParamCounter)
}

// Calls returns a list of arguments used in each call to UserCacheMock.SaveUserParam.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveUserParam *mUserCacheMockSaveUserParam) Calls() []*UserCacheMockSaveUserParamParams {
	mmSaveUserParam.mutex.RLock()

	argCopy := make([]*UserCacheMockSaveUserParamParams, len(mmSaveUserParam.callArgs))
	copy(argCopy, mmSaveUserParam.callArgs)

	mmSaveUserParam.mutex.RUnlock()

	return argCopy
}

// MinimockSaveUserParamDone returns true if the count of the SaveUserParam invocations corresponds
// the number of defined expectations
func (m *UserCacheMock) MinimockSaveUserParamDone() bool {
	if m.SaveUserParamMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveUserParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveUserParamMock.invocationsDone()
}

// MinimockSaveUserParamInspect logs each unmet expectation
func (m *UserCacheMock) MinimockSaveUserParamInspect() {
	for _, e := range m.SaveUserParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheMock.SaveUserParam at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveUserParamCounter := mm_atomic.LoadUint64(&m.afterSaveUserParamCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserParamMock.defaultExpectation != nil && afterSaveUserParamCounter < 1 {
		if m.SaveUserParamMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheMock.SaveUserParam at\n%s", m.SaveUserParamMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheMock.SaveUserParam at\n%s with params: %#v", m.SaveUserParamMock.defaultExpectation.expectationOrigins.origin, *m.SaveUserParamMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUserParam != nil && afterSaveUserParamCounter < 1 {
		m.t.Errorf("Expected call to UserCacheMock.SaveUserParam at\n%s", m.funcSaveUserParamOrigin)
	}

	if !m.SaveUserParamMock.invocationsDone() && afterSaveUserParamCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheMock.SaveUserParam at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveUserParamMock.expectedInvocations), m.SaveUserParamMock.expectedInvocationsOrigin, afterSaveUserParamCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserCacheMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetUserParamsInspect()

			m.MinimockSaveUserParamInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserCacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserCacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetUserParamsDone() &&
		m.MinimockSaveUserParamDone()
}
