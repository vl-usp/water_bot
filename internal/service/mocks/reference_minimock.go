// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/vl-usp/water_bot/internal/service.Reference -o reference_minimock.go -n ReferenceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/vl-usp/water_bot/internal/model"
)

// ReferenceMock implements mm_service.Reference
type ReferenceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClimateList          func(ctx context.Context) (ca1 []model.Climate, err error)
	funcClimateListOrigin    string
	inspectFuncClimateList   func(ctx context.Context)
	afterClimateListCounter  uint64
	beforeClimateListCounter uint64
	ClimateListMock          mReferenceMockClimateList

	funcPhysicalActivityList          func(ctx context.Context) (pa1 []model.PhysicalActivity, err error)
	funcPhysicalActivityListOrigin    string
	inspectFuncPhysicalActivityList   func(ctx context.Context)
	afterPhysicalActivityListCounter  uint64
	beforePhysicalActivityListCounter uint64
	PhysicalActivityListMock          mReferenceMockPhysicalActivityList

	funcSexList          func(ctx context.Context) (sa1 []model.Sex, err error)
	funcSexListOrigin    string
	inspectFuncSexList   func(ctx context.Context)
	afterSexListCounter  uint64
	beforeSexListCounter uint64
	SexListMock          mReferenceMockSexList

	funcTimezoneList          func(ctx context.Context) (ta1 []model.Timezone, err error)
	funcTimezoneListOrigin    string
	inspectFuncTimezoneList   func(ctx context.Context)
	afterTimezoneListCounter  uint64
	beforeTimezoneListCounter uint64
	TimezoneListMock          mReferenceMockTimezoneList
}

// NewReferenceMock returns a mock for mm_service.Reference
func NewReferenceMock(t minimock.Tester) *ReferenceMock {
	m := &ReferenceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ClimateListMock = mReferenceMockClimateList{mock: m}
	m.ClimateListMock.callArgs = []*ReferenceMockClimateListParams{}

	m.PhysicalActivityListMock = mReferenceMockPhysicalActivityList{mock: m}
	m.PhysicalActivityListMock.callArgs = []*ReferenceMockPhysicalActivityListParams{}

	m.SexListMock = mReferenceMockSexList{mock: m}
	m.SexListMock.callArgs = []*ReferenceMockSexListParams{}

	m.TimezoneListMock = mReferenceMockTimezoneList{mock: m}
	m.TimezoneListMock.callArgs = []*ReferenceMockTimezoneListParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mReferenceMockClimateList struct {
	optional           bool
	mock               *ReferenceMock
	defaultExpectation *ReferenceMockClimateListExpectation
	expectations       []*ReferenceMockClimateListExpectation

	callArgs []*ReferenceMockClimateListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReferenceMockClimateListExpectation specifies expectation struct of the Reference.ClimateList
type ReferenceMockClimateListExpectation struct {
	mock               *ReferenceMock
	params             *ReferenceMockClimateListParams
	paramPtrs          *ReferenceMockClimateListParamPtrs
	expectationOrigins ReferenceMockClimateListExpectationOrigins
	results            *ReferenceMockClimateListResults
	returnOrigin       string
	Counter            uint64
}

// ReferenceMockClimateListParams contains parameters of the Reference.ClimateList
type ReferenceMockClimateListParams struct {
	ctx context.Context
}

// ReferenceMockClimateListParamPtrs contains pointers to parameters of the Reference.ClimateList
type ReferenceMockClimateListParamPtrs struct {
	ctx *context.Context
}

// ReferenceMockClimateListResults contains results of the Reference.ClimateList
type ReferenceMockClimateListResults struct {
	ca1 []model.Climate
	err error
}

// ReferenceMockClimateListOrigins contains origins of expectations of the Reference.ClimateList
type ReferenceMockClimateListExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClimateList *mReferenceMockClimateList) Optional() *mReferenceMockClimateList {
	mmClimateList.optional = true
	return mmClimateList
}

// Expect sets up expected params for Reference.ClimateList
func (mmClimateList *mReferenceMockClimateList) Expect(ctx context.Context) *mReferenceMockClimateList {
	if mmClimateList.mock.funcClimateList != nil {
		mmClimateList.mock.t.Fatalf("ReferenceMock.ClimateList mock is already set by Set")
	}

	if mmClimateList.defaultExpectation == nil {
		mmClimateList.defaultExpectation = &ReferenceMockClimateListExpectation{}
	}

	if mmClimateList.defaultExpectation.paramPtrs != nil {
		mmClimateList.mock.t.Fatalf("ReferenceMock.ClimateList mock is already set by ExpectParams functions")
	}

	mmClimateList.defaultExpectation.params = &ReferenceMockClimateListParams{ctx}
	mmClimateList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClimateList.expectations {
		if minimock.Equal(e.params, mmClimateList.defaultExpectation.params) {
			mmClimateList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClimateList.defaultExpectation.params)
		}
	}

	return mmClimateList
}

// ExpectCtxParam1 sets up expected param ctx for Reference.ClimateList
func (mmClimateList *mReferenceMockClimateList) ExpectCtxParam1(ctx context.Context) *mReferenceMockClimateList {
	if mmClimateList.mock.funcClimateList != nil {
		mmClimateList.mock.t.Fatalf("ReferenceMock.ClimateList mock is already set by Set")
	}

	if mmClimateList.defaultExpectation == nil {
		mmClimateList.defaultExpectation = &ReferenceMockClimateListExpectation{}
	}

	if mmClimateList.defaultExpectation.params != nil {
		mmClimateList.mock.t.Fatalf("ReferenceMock.ClimateList mock is already set by Expect")
	}

	if mmClimateList.defaultExpectation.paramPtrs == nil {
		mmClimateList.defaultExpectation.paramPtrs = &ReferenceMockClimateListParamPtrs{}
	}
	mmClimateList.defaultExpectation.paramPtrs.ctx = &ctx
	mmClimateList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmClimateList
}

// Inspect accepts an inspector function that has same arguments as the Reference.ClimateList
func (mmClimateList *mReferenceMockClimateList) Inspect(f func(ctx context.Context)) *mReferenceMockClimateList {
	if mmClimateList.mock.inspectFuncClimateList != nil {
		mmClimateList.mock.t.Fatalf("Inspect function is already set for ReferenceMock.ClimateList")
	}

	mmClimateList.mock.inspectFuncClimateList = f

	return mmClimateList
}

// Return sets up results that will be returned by Reference.ClimateList
func (mmClimateList *mReferenceMockClimateList) Return(ca1 []model.Climate, err error) *ReferenceMock {
	if mmClimateList.mock.funcClimateList != nil {
		mmClimateList.mock.t.Fatalf("ReferenceMock.ClimateList mock is already set by Set")
	}

	if mmClimateList.defaultExpectation == nil {
		mmClimateList.defaultExpectation = &ReferenceMockClimateListExpectation{mock: mmClimateList.mock}
	}
	mmClimateList.defaultExpectation.results = &ReferenceMockClimateListResults{ca1, err}
	mmClimateList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClimateList.mock
}

// Set uses given function f to mock the Reference.ClimateList method
func (mmClimateList *mReferenceMockClimateList) Set(f func(ctx context.Context) (ca1 []model.Climate, err error)) *ReferenceMock {
	if mmClimateList.defaultExpectation != nil {
		mmClimateList.mock.t.Fatalf("Default expectation is already set for the Reference.ClimateList method")
	}

	if len(mmClimateList.expectations) > 0 {
		mmClimateList.mock.t.Fatalf("Some expectations are already set for the Reference.ClimateList method")
	}

	mmClimateList.mock.funcClimateList = f
	mmClimateList.mock.funcClimateListOrigin = minimock.CallerInfo(1)
	return mmClimateList.mock
}

// When sets expectation for the Reference.ClimateList which will trigger the result defined by the following
// Then helper
func (mmClimateList *mReferenceMockClimateList) When(ctx context.Context) *ReferenceMockClimateListExpectation {
	if mmClimateList.mock.funcClimateList != nil {
		mmClimateList.mock.t.Fatalf("ReferenceMock.ClimateList mock is already set by Set")
	}

	expectation := &ReferenceMockClimateListExpectation{
		mock:               mmClimateList.mock,
		params:             &ReferenceMockClimateListParams{ctx},
		expectationOrigins: ReferenceMockClimateListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClimateList.expectations = append(mmClimateList.expectations, expectation)
	return expectation
}

// Then sets up Reference.ClimateList return parameters for the expectation previously defined by the When method
func (e *ReferenceMockClimateListExpectation) Then(ca1 []model.Climate, err error) *ReferenceMock {
	e.results = &ReferenceMockClimateListResults{ca1, err}
	return e.mock
}

// Times sets number of times Reference.ClimateList should be invoked
func (mmClimateList *mReferenceMockClimateList) Times(n uint64) *mReferenceMockClimateList {
	if n == 0 {
		mmClimateList.mock.t.Fatalf("Times of ReferenceMock.ClimateList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClimateList.expectedInvocations, n)
	mmClimateList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClimateList
}

func (mmClimateList *mReferenceMockClimateList) invocationsDone() bool {
	if len(mmClimateList.expectations) == 0 && mmClimateList.defaultExpectation == nil && mmClimateList.mock.funcClimateList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClimateList.mock.afterClimateListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClimateList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClimateList implements mm_service.Reference
func (mmClimateList *ReferenceMock) ClimateList(ctx context.Context) (ca1 []model.Climate, err error) {
	mm_atomic.AddUint64(&mmClimateList.beforeClimateListCounter, 1)
	defer mm_atomic.AddUint64(&mmClimateList.afterClimateListCounter, 1)

	mmClimateList.t.Helper()

	if mmClimateList.inspectFuncClimateList != nil {
		mmClimateList.inspectFuncClimateList(ctx)
	}

	mm_params := ReferenceMockClimateListParams{ctx}

	// Record call args
	mmClimateList.ClimateListMock.mutex.Lock()
	mmClimateList.ClimateListMock.callArgs = append(mmClimateList.ClimateListMock.callArgs, &mm_params)
	mmClimateList.ClimateListMock.mutex.Unlock()

	for _, e := range mmClimateList.ClimateListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmClimateList.ClimateListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClimateList.ClimateListMock.defaultExpectation.Counter, 1)
		mm_want := mmClimateList.ClimateListMock.defaultExpectation.params
		mm_want_ptrs := mmClimateList.ClimateListMock.defaultExpectation.paramPtrs

		mm_got := ReferenceMockClimateListParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClimateList.t.Errorf("ReferenceMock.ClimateList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClimateList.ClimateListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClimateList.t.Errorf("ReferenceMock.ClimateList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClimateList.ClimateListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClimateList.ClimateListMock.defaultExpectation.results
		if mm_results == nil {
			mmClimateList.t.Fatal("No results are set for the ReferenceMock.ClimateList")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmClimateList.funcClimateList != nil {
		return mmClimateList.funcClimateList(ctx)
	}
	mmClimateList.t.Fatalf("Unexpected call to ReferenceMock.ClimateList. %v", ctx)
	return
}

// ClimateListAfterCounter returns a count of finished ReferenceMock.ClimateList invocations
func (mmClimateList *ReferenceMock) ClimateListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClimateList.afterClimateListCounter)
}

// ClimateListBeforeCounter returns a count of ReferenceMock.ClimateList invocations
func (mmClimateList *ReferenceMock) ClimateListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClimateList.beforeClimateListCounter)
}

// Calls returns a list of arguments used in each call to ReferenceMock.ClimateList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClimateList *mReferenceMockClimateList) Calls() []*ReferenceMockClimateListParams {
	mmClimateList.mutex.RLock()

	argCopy := make([]*ReferenceMockClimateListParams, len(mmClimateList.callArgs))
	copy(argCopy, mmClimateList.callArgs)

	mmClimateList.mutex.RUnlock()

	return argCopy
}

// MinimockClimateListDone returns true if the count of the ClimateList invocations corresponds
// the number of defined expectations
func (m *ReferenceMock) MinimockClimateListDone() bool {
	if m.ClimateListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClimateListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClimateListMock.invocationsDone()
}

// MinimockClimateListInspect logs each unmet expectation
func (m *ReferenceMock) MinimockClimateListInspect() {
	for _, e := range m.ClimateListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReferenceMock.ClimateList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClimateListCounter := mm_atomic.LoadUint64(&m.afterClimateListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClimateListMock.defaultExpectation != nil && afterClimateListCounter < 1 {
		if m.ClimateListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReferenceMock.ClimateList at\n%s", m.ClimateListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReferenceMock.ClimateList at\n%s with params: %#v", m.ClimateListMock.defaultExpectation.expectationOrigins.origin, *m.ClimateListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClimateList != nil && afterClimateListCounter < 1 {
		m.t.Errorf("Expected call to ReferenceMock.ClimateList at\n%s", m.funcClimateListOrigin)
	}

	if !m.ClimateListMock.invocationsDone() && afterClimateListCounter > 0 {
		m.t.Errorf("Expected %d calls to ReferenceMock.ClimateList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClimateListMock.expectedInvocations), m.ClimateListMock.expectedInvocationsOrigin, afterClimateListCounter)
	}
}

type mReferenceMockPhysicalActivityList struct {
	optional           bool
	mock               *ReferenceMock
	defaultExpectation *ReferenceMockPhysicalActivityListExpectation
	expectations       []*ReferenceMockPhysicalActivityListExpectation

	callArgs []*ReferenceMockPhysicalActivityListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReferenceMockPhysicalActivityListExpectation specifies expectation struct of the Reference.PhysicalActivityList
type ReferenceMockPhysicalActivityListExpectation struct {
	mock               *ReferenceMock
	params             *ReferenceMockPhysicalActivityListParams
	paramPtrs          *ReferenceMockPhysicalActivityListParamPtrs
	expectationOrigins ReferenceMockPhysicalActivityListExpectationOrigins
	results            *ReferenceMockPhysicalActivityListResults
	returnOrigin       string
	Counter            uint64
}

// ReferenceMockPhysicalActivityListParams contains parameters of the Reference.PhysicalActivityList
type ReferenceMockPhysicalActivityListParams struct {
	ctx context.Context
}

// ReferenceMockPhysicalActivityListParamPtrs contains pointers to parameters of the Reference.PhysicalActivityList
type ReferenceMockPhysicalActivityListParamPtrs struct {
	ctx *context.Context
}

// ReferenceMockPhysicalActivityListResults contains results of the Reference.PhysicalActivityList
type ReferenceMockPhysicalActivityListResults struct {
	pa1 []model.PhysicalActivity
	err error
}

// ReferenceMockPhysicalActivityListOrigins contains origins of expectations of the Reference.PhysicalActivityList
type ReferenceMockPhysicalActivityListExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPhysicalActivityList *mReferenceMockPhysicalActivityList) Optional() *mReferenceMockPhysicalActivityList {
	mmPhysicalActivityList.optional = true
	return mmPhysicalActivityList
}

// Expect sets up expected params for Reference.PhysicalActivityList
func (mmPhysicalActivityList *mReferenceMockPhysicalActivityList) Expect(ctx context.Context) *mReferenceMockPhysicalActivityList {
	if mmPhysicalActivityList.mock.funcPhysicalActivityList != nil {
		mmPhysicalActivityList.mock.t.Fatalf("ReferenceMock.PhysicalActivityList mock is already set by Set")
	}

	if mmPhysicalActivityList.defaultExpectation == nil {
		mmPhysicalActivityList.defaultExpectation = &ReferenceMockPhysicalActivityListExpectation{}
	}

	if mmPhysicalActivityList.defaultExpectation.paramPtrs != nil {
		mmPhysicalActivityList.mock.t.Fatalf("ReferenceMock.PhysicalActivityList mock is already set by ExpectParams functions")
	}

	mmPhysicalActivityList.defaultExpectation.params = &ReferenceMockPhysicalActivityListParams{ctx}
	mmPhysicalActivityList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPhysicalActivityList.expectations {
		if minimock.Equal(e.params, mmPhysicalActivityList.defaultExpectation.params) {
			mmPhysicalActivityList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPhysicalActivityList.defaultExpectation.params)
		}
	}

	return mmPhysicalActivityList
}

// ExpectCtxParam1 sets up expected param ctx for Reference.PhysicalActivityList
func (mmPhysicalActivityList *mReferenceMockPhysicalActivityList) ExpectCtxParam1(ctx context.Context) *mReferenceMockPhysicalActivityList {
	if mmPhysicalActivityList.mock.funcPhysicalActivityList != nil {
		mmPhysicalActivityList.mock.t.Fatalf("ReferenceMock.PhysicalActivityList mock is already set by Set")
	}

	if mmPhysicalActivityList.defaultExpectation == nil {
		mmPhysicalActivityList.defaultExpectation = &ReferenceMockPhysicalActivityListExpectation{}
	}

	if mmPhysicalActivityList.defaultExpectation.params != nil {
		mmPhysicalActivityList.mock.t.Fatalf("ReferenceMock.PhysicalActivityList mock is already set by Expect")
	}

	if mmPhysicalActivityList.defaultExpectation.paramPtrs == nil {
		mmPhysicalActivityList.defaultExpectation.paramPtrs = &ReferenceMockPhysicalActivityListParamPtrs{}
	}
	mmPhysicalActivityList.defaultExpectation.paramPtrs.ctx = &ctx
	mmPhysicalActivityList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPhysicalActivityList
}

// Inspect accepts an inspector function that has same arguments as the Reference.PhysicalActivityList
func (mmPhysicalActivityList *mReferenceMockPhysicalActivityList) Inspect(f func(ctx context.Context)) *mReferenceMockPhysicalActivityList {
	if mmPhysicalActivityList.mock.inspectFuncPhysicalActivityList != nil {
		mmPhysicalActivityList.mock.t.Fatalf("Inspect function is already set for ReferenceMock.PhysicalActivityList")
	}

	mmPhysicalActivityList.mock.inspectFuncPhysicalActivityList = f

	return mmPhysicalActivityList
}

// Return sets up results that will be returned by Reference.PhysicalActivityList
func (mmPhysicalActivityList *mReferenceMockPhysicalActivityList) Return(pa1 []model.PhysicalActivity, err error) *ReferenceMock {
	if mmPhysicalActivityList.mock.funcPhysicalActivityList != nil {
		mmPhysicalActivityList.mock.t.Fatalf("ReferenceMock.PhysicalActivityList mock is already set by Set")
	}

	if mmPhysicalActivityList.defaultExpectation == nil {
		mmPhysicalActivityList.defaultExpectation = &ReferenceMockPhysicalActivityListExpectation{mock: mmPhysicalActivityList.mock}
	}
	mmPhysicalActivityList.defaultExpectation.results = &ReferenceMockPhysicalActivityListResults{pa1, err}
	mmPhysicalActivityList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPhysicalActivityList.mock
}

// Set uses given function f to mock the Reference.PhysicalActivityList method
func (mmPhysicalActivityList *mReferenceMockPhysicalActivityList) Set(f func(ctx context.Context) (pa1 []model.PhysicalActivity, err error)) *ReferenceMock {
	if mmPhysicalActivityList.defaultExpectation != nil {
		mmPhysicalActivityList.mock.t.Fatalf("Default expectation is already set for the Reference.PhysicalActivityList method")
	}

	if len(mmPhysicalActivityList.expectations) > 0 {
		mmPhysicalActivityList.mock.t.Fatalf("Some expectations are already set for the Reference.PhysicalActivityList method")
	}

	mmPhysicalActivityList.mock.funcPhysicalActivityList = f
	mmPhysicalActivityList.mock.funcPhysicalActivityListOrigin = minimock.CallerInfo(1)
	return mmPhysicalActivityList.mock
}

// When sets expectation for the Reference.PhysicalActivityList which will trigger the result defined by the following
// Then helper
func (mmPhysicalActivityList *mReferenceMockPhysicalActivityList) When(ctx context.Context) *ReferenceMockPhysicalActivityListExpectation {
	if mmPhysicalActivityList.mock.funcPhysicalActivityList != nil {
		mmPhysicalActivityList.mock.t.Fatalf("ReferenceMock.PhysicalActivityList mock is already set by Set")
	}

	expectation := &ReferenceMockPhysicalActivityListExpectation{
		mock:               mmPhysicalActivityList.mock,
		params:             &ReferenceMockPhysicalActivityListParams{ctx},
		expectationOrigins: ReferenceMockPhysicalActivityListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPhysicalActivityList.expectations = append(mmPhysicalActivityList.expectations, expectation)
	return expectation
}

// Then sets up Reference.PhysicalActivityList return parameters for the expectation previously defined by the When method
func (e *ReferenceMockPhysicalActivityListExpectation) Then(pa1 []model.PhysicalActivity, err error) *ReferenceMock {
	e.results = &ReferenceMockPhysicalActivityListResults{pa1, err}
	return e.mock
}

// Times sets number of times Reference.PhysicalActivityList should be invoked
func (mmPhysicalActivityList *mReferenceMockPhysicalActivityList) Times(n uint64) *mReferenceMockPhysicalActivityList {
	if n == 0 {
		mmPhysicalActivityList.mock.t.Fatalf("Times of ReferenceMock.PhysicalActivityList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPhysicalActivityList.expectedInvocations, n)
	mmPhysicalActivityList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPhysicalActivityList
}

func (mmPhysicalActivityList *mReferenceMockPhysicalActivityList) invocationsDone() bool {
	if len(mmPhysicalActivityList.expectations) == 0 && mmPhysicalActivityList.defaultExpectation == nil && mmPhysicalActivityList.mock.funcPhysicalActivityList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPhysicalActivityList.mock.afterPhysicalActivityListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPhysicalActivityList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PhysicalActivityList implements mm_service.Reference
func (mmPhysicalActivityList *ReferenceMock) PhysicalActivityList(ctx context.Context) (pa1 []model.PhysicalActivity, err error) {
	mm_atomic.AddUint64(&mmPhysicalActivityList.beforePhysicalActivityListCounter, 1)
	defer mm_atomic.AddUint64(&mmPhysicalActivityList.afterPhysicalActivityListCounter, 1)

	mmPhysicalActivityList.t.Helper()

	if mmPhysicalActivityList.inspectFuncPhysicalActivityList != nil {
		mmPhysicalActivityList.inspectFuncPhysicalActivityList(ctx)
	}

	mm_params := ReferenceMockPhysicalActivityListParams{ctx}

	// Record call args
	mmPhysicalActivityList.PhysicalActivityListMock.mutex.Lock()
	mmPhysicalActivityList.PhysicalActivityListMock.callArgs = append(mmPhysicalActivityList.PhysicalActivityListMock.callArgs, &mm_params)
	mmPhysicalActivityList.PhysicalActivityListMock.mutex.Unlock()

	for _, e := range mmPhysicalActivityList.PhysicalActivityListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmPhysicalActivityList.PhysicalActivityListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPhysicalActivityList.PhysicalActivityListMock.defaultExpectation.Counter, 1)
		mm_want := mmPhysicalActivityList.PhysicalActivityListMock.defaultExpectation.params
		mm_want_ptrs := mmPhysicalActivityList.PhysicalActivityListMock.defaultExpectation.paramPtrs

		mm_got := ReferenceMockPhysicalActivityListParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPhysicalActivityList.t.Errorf("ReferenceMock.PhysicalActivityList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPhysicalActivityList.PhysicalActivityListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPhysicalActivityList.t.Errorf("ReferenceMock.PhysicalActivityList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPhysicalActivityList.PhysicalActivityListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPhysicalActivityList.PhysicalActivityListMock.defaultExpectation.results
		if mm_results == nil {
			mmPhysicalActivityList.t.Fatal("No results are set for the ReferenceMock.PhysicalActivityList")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmPhysicalActivityList.funcPhysicalActivityList != nil {
		return mmPhysicalActivityList.funcPhysicalActivityList(ctx)
	}
	mmPhysicalActivityList.t.Fatalf("Unexpected call to ReferenceMock.PhysicalActivityList. %v", ctx)
	return
}

// PhysicalActivityListAfterCounter returns a count of finished ReferenceMock.PhysicalActivityList invocations
func (mmPhysicalActivityList *ReferenceMock) PhysicalActivityListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPhysicalActivityList.afterPhysicalActivityListCounter)
}

// PhysicalActivityListBeforeCounter returns a count of ReferenceMock.PhysicalActivityList invocations
func (mmPhysicalActivityList *ReferenceMock) PhysicalActivityListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPhysicalActivityList.beforePhysicalActivityListCounter)
}

// Calls returns a list of arguments used in each call to ReferenceMock.PhysicalActivityList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPhysicalActivityList *mReferenceMockPhysicalActivityList) Calls() []*ReferenceMockPhysicalActivityListParams {
	mmPhysicalActivityList.mutex.RLock()

	argCopy := make([]*ReferenceMockPhysicalActivityListParams, len(mmPhysicalActivityList.callArgs))
	copy(argCopy, mmPhysicalActivityList.callArgs)

	mmPhysicalActivityList.mutex.RUnlock()

	return argCopy
}

// MinimockPhysicalActivityListDone returns true if the count of the PhysicalActivityList invocations corresponds
// the number of defined expectations
func (m *ReferenceMock) MinimockPhysicalActivityListDone() bool {
	if m.PhysicalActivityListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PhysicalActivityListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PhysicalActivityListMock.invocationsDone()
}

// MinimockPhysicalActivityListInspect logs each unmet expectation
func (m *ReferenceMock) MinimockPhysicalActivityListInspect() {
	for _, e := range m.PhysicalActivityListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReferenceMock.PhysicalActivityList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPhysicalActivityListCounter := mm_atomic.LoadUint64(&m.afterPhysicalActivityListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PhysicalActivityListMock.defaultExpectation != nil && afterPhysicalActivityListCounter < 1 {
		if m.PhysicalActivityListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReferenceMock.PhysicalActivityList at\n%s", m.PhysicalActivityListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReferenceMock.PhysicalActivityList at\n%s with params: %#v", m.PhysicalActivityListMock.defaultExpectation.expectationOrigins.origin, *m.PhysicalActivityListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPhysicalActivityList != nil && afterPhysicalActivityListCounter < 1 {
		m.t.Errorf("Expected call to ReferenceMock.PhysicalActivityList at\n%s", m.funcPhysicalActivityListOrigin)
	}

	if !m.PhysicalActivityListMock.invocationsDone() && afterPhysicalActivityListCounter > 0 {
		m.t.Errorf("Expected %d calls to ReferenceMock.PhysicalActivityList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PhysicalActivityListMock.expectedInvocations), m.PhysicalActivityListMock.expectedInvocationsOrigin, afterPhysicalActivityListCounter)
	}
}

type mReferenceMockSexList struct {
	optional           bool
	mock               *ReferenceMock
	defaultExpectation *ReferenceMockSexListExpectation
	expectations       []*ReferenceMockSexListExpectation

	callArgs []*ReferenceMockSexListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReferenceMockSexListExpectation specifies expectation struct of the Reference.SexList
type ReferenceMockSexListExpectation struct {
	mock               *ReferenceMock
	params             *ReferenceMockSexListParams
	paramPtrs          *ReferenceMockSexListParamPtrs
	expectationOrigins ReferenceMockSexListExpectationOrigins
	results            *ReferenceMockSexListResults
	returnOrigin       string
	Counter            uint64
}

// ReferenceMockSexListParams contains parameters of the Reference.SexList
type ReferenceMockSexListParams struct {
	ctx context.Context
}

// ReferenceMockSexListParamPtrs contains pointers to parameters of the Reference.SexList
type ReferenceMockSexListParamPtrs struct {
	ctx *context.Context
}

// ReferenceMockSexListResults contains results of the Reference.SexList
type ReferenceMockSexListResults struct {
	sa1 []model.Sex
	err error
}

// ReferenceMockSexListOrigins contains origins of expectations of the Reference.SexList
type ReferenceMockSexListExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSexList *mReferenceMockSexList) Optional() *mReferenceMockSexList {
	mmSexList.optional = true
	return mmSexList
}

// Expect sets up expected params for Reference.SexList
func (mmSexList *mReferenceMockSexList) Expect(ctx context.Context) *mReferenceMockSexList {
	if mmSexList.mock.funcSexList != nil {
		mmSexList.mock.t.Fatalf("ReferenceMock.SexList mock is already set by Set")
	}

	if mmSexList.defaultExpectation == nil {
		mmSexList.defaultExpectation = &ReferenceMockSexListExpectation{}
	}

	if mmSexList.defaultExpectation.paramPtrs != nil {
		mmSexList.mock.t.Fatalf("ReferenceMock.SexList mock is already set by ExpectParams functions")
	}

	mmSexList.defaultExpectation.params = &ReferenceMockSexListParams{ctx}
	mmSexList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSexList.expectations {
		if minimock.Equal(e.params, mmSexList.defaultExpectation.params) {
			mmSexList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSexList.defaultExpectation.params)
		}
	}

	return mmSexList
}

// ExpectCtxParam1 sets up expected param ctx for Reference.SexList
func (mmSexList *mReferenceMockSexList) ExpectCtxParam1(ctx context.Context) *mReferenceMockSexList {
	if mmSexList.mock.funcSexList != nil {
		mmSexList.mock.t.Fatalf("ReferenceMock.SexList mock is already set by Set")
	}

	if mmSexList.defaultExpectation == nil {
		mmSexList.defaultExpectation = &ReferenceMockSexListExpectation{}
	}

	if mmSexList.defaultExpectation.params != nil {
		mmSexList.mock.t.Fatalf("ReferenceMock.SexList mock is already set by Expect")
	}

	if mmSexList.defaultExpectation.paramPtrs == nil {
		mmSexList.defaultExpectation.paramPtrs = &ReferenceMockSexListParamPtrs{}
	}
	mmSexList.defaultExpectation.paramPtrs.ctx = &ctx
	mmSexList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSexList
}

// Inspect accepts an inspector function that has same arguments as the Reference.SexList
func (mmSexList *mReferenceMockSexList) Inspect(f func(ctx context.Context)) *mReferenceMockSexList {
	if mmSexList.mock.inspectFuncSexList != nil {
		mmSexList.mock.t.Fatalf("Inspect function is already set for ReferenceMock.SexList")
	}

	mmSexList.mock.inspectFuncSexList = f

	return mmSexList
}

// Return sets up results that will be returned by Reference.SexList
func (mmSexList *mReferenceMockSexList) Return(sa1 []model.Sex, err error) *ReferenceMock {
	if mmSexList.mock.funcSexList != nil {
		mmSexList.mock.t.Fatalf("ReferenceMock.SexList mock is already set by Set")
	}

	if mmSexList.defaultExpectation == nil {
		mmSexList.defaultExpectation = &ReferenceMockSexListExpectation{mock: mmSexList.mock}
	}
	mmSexList.defaultExpectation.results = &ReferenceMockSexListResults{sa1, err}
	mmSexList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSexList.mock
}

// Set uses given function f to mock the Reference.SexList method
func (mmSexList *mReferenceMockSexList) Set(f func(ctx context.Context) (sa1 []model.Sex, err error)) *ReferenceMock {
	if mmSexList.defaultExpectation != nil {
		mmSexList.mock.t.Fatalf("Default expectation is already set for the Reference.SexList method")
	}

	if len(mmSexList.expectations) > 0 {
		mmSexList.mock.t.Fatalf("Some expectations are already set for the Reference.SexList method")
	}

	mmSexList.mock.funcSexList = f
	mmSexList.mock.funcSexListOrigin = minimock.CallerInfo(1)
	return mmSexList.mock
}

// When sets expectation for the Reference.SexList which will trigger the result defined by the following
// Then helper
func (mmSexList *mReferenceMockSexList) When(ctx context.Context) *ReferenceMockSexListExpectation {
	if mmSexList.mock.funcSexList != nil {
		mmSexList.mock.t.Fatalf("ReferenceMock.SexList mock is already set by Set")
	}

	expectation := &ReferenceMockSexListExpectation{
		mock:               mmSexList.mock,
		params:             &ReferenceMockSexListParams{ctx},
		expectationOrigins: ReferenceMockSexListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSexList.expectations = append(mmSexList.expectations, expectation)
	return expectation
}

// Then sets up Reference.SexList return parameters for the expectation previously defined by the When method
func (e *ReferenceMockSexListExpectation) Then(sa1 []model.Sex, err error) *ReferenceMock {
	e.results = &ReferenceMockSexListResults{sa1, err}
	return e.mock
}

// Times sets number of times Reference.SexList should be invoked
func (mmSexList *mReferenceMockSexList) Times(n uint64) *mReferenceMockSexList {
	if n == 0 {
		mmSexList.mock.t.Fatalf("Times of ReferenceMock.SexList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSexList.expectedInvocations, n)
	mmSexList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSexList
}

func (mmSexList *mReferenceMockSexList) invocationsDone() bool {
	if len(mmSexList.expectations) == 0 && mmSexList.defaultExpectation == nil && mmSexList.mock.funcSexList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSexList.mock.afterSexListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSexList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SexList implements mm_service.Reference
func (mmSexList *ReferenceMock) SexList(ctx context.Context) (sa1 []model.Sex, err error) {
	mm_atomic.AddUint64(&mmSexList.beforeSexListCounter, 1)
	defer mm_atomic.AddUint64(&mmSexList.afterSexListCounter, 1)

	mmSexList.t.Helper()

	if mmSexList.inspectFuncSexList != nil {
		mmSexList.inspectFuncSexList(ctx)
	}

	mm_params := ReferenceMockSexListParams{ctx}

	// Record call args
	mmSexList.SexListMock.mutex.Lock()
	mmSexList.SexListMock.callArgs = append(mmSexList.SexListMock.callArgs, &mm_params)
	mmSexList.SexListMock.mutex.Unlock()

	for _, e := range mmSexList.SexListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmSexList.SexListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSexList.SexListMock.defaultExpectation.Counter, 1)
		mm_want := mmSexList.SexListMock.defaultExpectation.params
		mm_want_ptrs := mmSexList.SexListMock.defaultExpectation.paramPtrs

		mm_got := ReferenceMockSexListParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSexList.t.Errorf("ReferenceMock.SexList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSexList.SexListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSexList.t.Errorf("ReferenceMock.SexList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSexList.SexListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSexList.SexListMock.defaultExpectation.results
		if mm_results == nil {
			mmSexList.t.Fatal("No results are set for the ReferenceMock.SexList")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmSexList.funcSexList != nil {
		return mmSexList.funcSexList(ctx)
	}
	mmSexList.t.Fatalf("Unexpected call to ReferenceMock.SexList. %v", ctx)
	return
}

// SexListAfterCounter returns a count of finished ReferenceMock.SexList invocations
func (mmSexList *ReferenceMock) SexListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSexList.afterSexListCounter)
}

// SexListBeforeCounter returns a count of ReferenceMock.SexList invocations
func (mmSexList *ReferenceMock) SexListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSexList.beforeSexListCounter)
}

// Calls returns a list of arguments used in each call to ReferenceMock.SexList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSexList *mReferenceMockSexList) Calls() []*ReferenceMockSexListParams {
	mmSexList.mutex.RLock()

	argCopy := make([]*ReferenceMockSexListParams, len(mmSexList.callArgs))
	copy(argCopy, mmSexList.callArgs)

	mmSexList.mutex.RUnlock()

	return argCopy
}

// MinimockSexListDone returns true if the count of the SexList invocations corresponds
// the number of defined expectations
func (m *ReferenceMock) MinimockSexListDone() bool {
	if m.SexListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SexListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SexListMock.invocationsDone()
}

// MinimockSexListInspect logs each unmet expectation
func (m *ReferenceMock) MinimockSexListInspect() {
	for _, e := range m.SexListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReferenceMock.SexList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSexListCounter := mm_atomic.LoadUint64(&m.afterSexListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SexListMock.defaultExpectation != nil && afterSexListCounter < 1 {
		if m.SexListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReferenceMock.SexList at\n%s", m.SexListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReferenceMock.SexList at\n%s with params: %#v", m.SexListMock.defaultExpectation.expectationOrigins.origin, *m.SexListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSexList != nil && afterSexListCounter < 1 {
		m.t.Errorf("Expected call to ReferenceMock.SexList at\n%s", m.funcSexListOrigin)
	}

	if !m.SexListMock.invocationsDone() && afterSexListCounter > 0 {
		m.t.Errorf("Expected %d calls to ReferenceMock.SexList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SexListMock.expectedInvocations), m.SexListMock.expectedInvocationsOrigin, afterSexListCounter)
	}
}

type mReferenceMockTimezoneList struct {
	optional           bool
	mock               *ReferenceMock
	defaultExpectation *ReferenceMockTimezoneListExpectation
	expectations       []*ReferenceMockTimezoneListExpectation

	callArgs []*ReferenceMockTimezoneListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReferenceMockTimezoneListExpectation specifies expectation struct of the Reference.TimezoneList
type ReferenceMockTimezoneListExpectation struct {
	mock               *ReferenceMock
	params             *ReferenceMockTimezoneListParams
	paramPtrs          *ReferenceMockTimezoneListParamPtrs
	expectationOrigins ReferenceMockTimezoneListExpectationOrigins
	results            *ReferenceMockTimezoneListResults
	returnOrigin       string
	Counter            uint64
}

// ReferenceMockTimezoneListParams contains parameters of the Reference.TimezoneList
type ReferenceMockTimezoneListParams struct {
	ctx context.Context
}

// ReferenceMockTimezoneListParamPtrs contains pointers to parameters of the Reference.TimezoneList
type ReferenceMockTimezoneListParamPtrs struct {
	ctx *context.Context
}

// ReferenceMockTimezoneListResults contains results of the Reference.TimezoneList
type ReferenceMockTimezoneListResults struct {
	ta1 []model.Timezone
	err error
}

// ReferenceMockTimezoneListOrigins contains origins of expectations of the Reference.TimezoneList
type ReferenceMockTimezoneListExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTimezoneList *mReferenceMockTimezoneList) Optional() *mReferenceMockTimezoneList {
	mmTimezoneList.optional = true
	return mmTimezoneList
}

// Expect sets up expected params for Reference.TimezoneList
func (mmTimezoneList *mReferenceMockTimezoneList) Expect(ctx context.Context) *mReferenceMockTimezoneList {
	if mmTimezoneList.mock.funcTimezoneList != nil {
		mmTimezoneList.mock.t.Fatalf("ReferenceMock.TimezoneList mock is already set by Set")
	}

	if mmTimezoneList.defaultExpectation == nil {
		mmTimezoneList.defaultExpectation = &ReferenceMockTimezoneListExpectation{}
	}

	if mmTimezoneList.defaultExpectation.paramPtrs != nil {
		mmTimezoneList.mock.t.Fatalf("ReferenceMock.TimezoneList mock is already set by ExpectParams functions")
	}

	mmTimezoneList.defaultExpectation.params = &ReferenceMockTimezoneListParams{ctx}
	mmTimezoneList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTimezoneList.expectations {
		if minimock.Equal(e.params, mmTimezoneList.defaultExpectation.params) {
			mmTimezoneList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTimezoneList.defaultExpectation.params)
		}
	}

	return mmTimezoneList
}

// ExpectCtxParam1 sets up expected param ctx for Reference.TimezoneList
func (mmTimezoneList *mReferenceMockTimezoneList) ExpectCtxParam1(ctx context.Context) *mReferenceMockTimezoneList {
	if mmTimezoneList.mock.funcTimezoneList != nil {
		mmTimezoneList.mock.t.Fatalf("ReferenceMock.TimezoneList mock is already set by Set")
	}

	if mmTimezoneList.defaultExpectation == nil {
		mmTimezoneList.defaultExpectation = &ReferenceMockTimezoneListExpectation{}
	}

	if mmTimezoneList.defaultExpectation.params != nil {
		mmTimezoneList.mock.t.Fatalf("ReferenceMock.TimezoneList mock is already set by Expect")
	}

	if mmTimezoneList.defaultExpectation.paramPtrs == nil {
		mmTimezoneList.defaultExpectation.paramPtrs = &ReferenceMockTimezoneListParamPtrs{}
	}
	mmTimezoneList.defaultExpectation.paramPtrs.ctx = &ctx
	mmTimezoneList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTimezoneList
}

// Inspect accepts an inspector function that has same arguments as the Reference.TimezoneList
func (mmTimezoneList *mReferenceMockTimezoneList) Inspect(f func(ctx context.Context)) *mReferenceMockTimezoneList {
	if mmTimezoneList.mock.inspectFuncTimezoneList != nil {
		mmTimezoneList.mock.t.Fatalf("Inspect function is already set for ReferenceMock.TimezoneList")
	}

	mmTimezoneList.mock.inspectFuncTimezoneList = f

	return mmTimezoneList
}

// Return sets up results that will be returned by Reference.TimezoneList
func (mmTimezoneList *mReferenceMockTimezoneList) Return(ta1 []model.Timezone, err error) *ReferenceMock {
	if mmTimezoneList.mock.funcTimezoneList != nil {
		mmTimezoneList.mock.t.Fatalf("ReferenceMock.TimezoneList mock is already set by Set")
	}

	if mmTimezoneList.defaultExpectation == nil {
		mmTimezoneList.defaultExpectation = &ReferenceMockTimezoneListExpectation{mock: mmTimezoneList.mock}
	}
	mmTimezoneList.defaultExpectation.results = &ReferenceMockTimezoneListResults{ta1, err}
	mmTimezoneList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTimezoneList.mock
}

// Set uses given function f to mock the Reference.TimezoneList method
func (mmTimezoneList *mReferenceMockTimezoneList) Set(f func(ctx context.Context) (ta1 []model.Timezone, err error)) *ReferenceMock {
	if mmTimezoneList.defaultExpectation != nil {
		mmTimezoneList.mock.t.Fatalf("Default expectation is already set for the Reference.TimezoneList method")
	}

	if len(mmTimezoneList.expectations) > 0 {
		mmTimezoneList.mock.t.Fatalf("Some expectations are already set for the Reference.TimezoneList method")
	}

	mmTimezoneList.mock.funcTimezoneList = f
	mmTimezoneList.mock.funcTimezoneListOrigin = minimock.CallerInfo(1)
	return mmTimezoneList.mock
}

// When sets expectation for the Reference.TimezoneList which will trigger the result defined by the following
// Then helper
func (mmTimezoneList *mReferenceMockTimezoneList) When(ctx context.Context) *ReferenceMockTimezoneListExpectation {
	if mmTimezoneList.mock.funcTimezoneList != nil {
		mmTimezoneList.mock.t.Fatalf("ReferenceMock.TimezoneList mock is already set by Set")
	}

	expectation := &ReferenceMockTimezoneListExpectation{
		mock:               mmTimezoneList.mock,
		params:             &ReferenceMockTimezoneListParams{ctx},
		expectationOrigins: ReferenceMockTimezoneListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTimezoneList.expectations = append(mmTimezoneList.expectations, expectation)
	return expectation
}

// Then sets up Reference.TimezoneList return parameters for the expectation previously defined by the When method
func (e *ReferenceMockTimezoneListExpectation) Then(ta1 []model.Timezone, err error) *ReferenceMock {
	e.results = &ReferenceMockTimezoneListResults{ta1, err}
	return e.mock
}

// Times sets number of times Reference.TimezoneList should be invoked
func (mmTimezoneList *mReferenceMockTimezoneList) Times(n uint64) *mReferenceMockTimezoneList {
	if n == 0 {
		mmTimezoneList.mock.t.Fatalf("Times of ReferenceMock.TimezoneList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTimezoneList.expectedInvocations, n)
	mmTimezoneList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTimezoneList
}

func (mmTimezoneList *mReferenceMockTimezoneList) invocationsDone() bool {
	if len(mmTimezoneList.expectations) == 0 && mmTimezoneList.defaultExpectation == nil && mmTimezoneList.mock.funcTimezoneList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTimezoneList.mock.afterTimezoneListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTimezoneList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TimezoneList implements mm_service.Reference
func (mmTimezoneList *ReferenceMock) TimezoneList(ctx context.Context) (ta1 []model.Timezone, err error) {
	mm_atomic.AddUint64(&mmTimezoneList.beforeTimezoneListCounter, 1)
	defer mm_atomic.AddUint64(&mmTimezoneList.afterTimezoneListCounter, 1)

	mmTimezoneList.t.Helper()

	if mmTimezoneList.inspectFuncTimezoneList != nil {
		mmTimezoneList.inspectFuncTimezoneList(ctx)
	}

	mm_params := ReferenceMockTimezoneListParams{ctx}

	// Record call args
	mmTimezoneList.TimezoneListMock.mutex.Lock()
	mmTimezoneList.TimezoneListMock.callArgs = append(mmTimezoneList.TimezoneListMock.callArgs, &mm_params)
	mmTimezoneList.TimezoneListMock.mutex.Unlock()

	for _, e := range mmTimezoneList.TimezoneListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmTimezoneList.TimezoneListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTimezoneList.TimezoneListMock.defaultExpectation.Counter, 1)
		mm_want := mmTimezoneList.TimezoneListMock.defaultExpectation.params
		mm_want_ptrs := mmTimezoneList.TimezoneListMock.defaultExpectation.paramPtrs

		mm_got := ReferenceMockTimezoneListParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTimezoneList.t.Errorf("ReferenceMock.TimezoneList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTimezoneList.TimezoneListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTimezoneList.t.Errorf("ReferenceMock.TimezoneList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTimezoneList.TimezoneListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTimezoneList.TimezoneListMock.defaultExpectation.results
		if mm_results == nil {
			mmTimezoneList.t.Fatal("No results are set for the ReferenceMock.TimezoneList")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmTimezoneList.funcTimezoneList != nil {
		return mmTimezoneList.funcTimezoneList(ctx)
	}
	mmTimezoneList.t.Fatalf("Unexpected call to ReferenceMock.TimezoneList. %v", ctx)
	return
}

// TimezoneListAfterCounter returns a count of finished ReferenceMock.TimezoneList invocations
func (mmTimezoneList *ReferenceMock) TimezoneListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTimezoneList.afterTimezoneListCounter)
}

// TimezoneListBeforeCounter returns a count of ReferenceMock.TimezoneList invocations
func (mmTimezoneList *ReferenceMock) TimezoneListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTimezoneList.beforeTimezoneListCounter)
}

// Calls returns a list of arguments used in each call to ReferenceMock.TimezoneList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTimezoneList *mReferenceMockTimezoneList) Calls() []*ReferenceMockTimezoneListParams {
	mmTimezoneList.mutex.RLock()

	argCopy := make([]*ReferenceMockTimezoneListParams, len(mmTimezoneList.callArgs))
	copy(argCopy, mmTimezoneList.callArgs)

	mmTimezoneList.mutex.RUnlock()

	return argCopy
}

// MinimockTimezoneListDone returns true if the count of the TimezoneList invocations corresponds
// the number of defined expectations
func (m *ReferenceMock) MinimockTimezoneListDone() bool {
	if m.TimezoneListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TimezoneListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TimezoneListMock.invocationsDone()
}

// MinimockTimezoneListInspect logs each unmet expectation
func (m *ReferenceMock) MinimockTimezoneListInspect() {
	for _, e := range m.TimezoneListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReferenceMock.TimezoneList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTimezoneListCounter := mm_atomic.LoadUint64(&m.afterTimezoneListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TimezoneListMock.defaultExpectation != nil && afterTimezoneListCounter < 1 {
		if m.TimezoneListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReferenceMock.TimezoneList at\n%s", m.TimezoneListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReferenceMock.TimezoneList at\n%s with params: %#v", m.TimezoneListMock.defaultExpectation.expectationOrigins.origin, *m.TimezoneListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTimezoneList != nil && afterTimezoneListCounter < 1 {
		m.t.Errorf("Expected call to ReferenceMock.TimezoneList at\n%s", m.funcTimezoneListOrigin)
	}

	if !m.TimezoneListMock.invocationsDone() && afterTimezoneListCounter > 0 {
		m.t.Errorf("Expected %d calls to ReferenceMock.TimezoneList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TimezoneListMock.expectedInvocations), m.TimezoneListMock.expectedInvocationsOrigin, afterTimezoneListCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReferenceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockClimateListInspect()

			m.MinimockPhysicalActivityListInspect()

			m.MinimockSexListInspect()

			m.MinimockTimezoneListInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReferenceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ReferenceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockClimateListDone() &&
		m.MinimockPhysicalActivityListDone() &&
		m.MinimockSexListDone() &&
		m.MinimockTimezoneListDone()
}
