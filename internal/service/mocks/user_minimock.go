// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/vl-usp/water_bot/internal/service.User -o user_minimock.go -n UserMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/vl-usp/water_bot/internal/model"
)

// UserMock implements mm_service.User
type UserMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, user model.User) (i1 int64, err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, user model.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserMockCreateUser

	funcGetUser          func(ctx context.Context, userID int64) (up1 *model.User, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, userID int64)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mUserMockGetUser

	funcSaveUserParam          func(ctx context.Context, userID int64, field string, value interface{}) (err error)
	funcSaveUserParamOrigin    string
	inspectFuncSaveUserParam   func(ctx context.Context, userID int64, field string, value interface{})
	afterSaveUserParamCounter  uint64
	beforeSaveUserParamCounter uint64
	SaveUserParamMock          mUserMockSaveUserParam

	funcUpdateUserFromCache          func(ctx context.Context, userID int64) (err error)
	funcUpdateUserFromCacheOrigin    string
	inspectFuncUpdateUserFromCache   func(ctx context.Context, userID int64)
	afterUpdateUserFromCacheCounter  uint64
	beforeUpdateUserFromCacheCounter uint64
	UpdateUserFromCacheMock          mUserMockUpdateUserFromCache
}

// NewUserMock returns a mock for mm_service.User
func NewUserMock(t minimock.Tester) *UserMock {
	m := &UserMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mUserMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserMockCreateUserParams{}

	m.GetUserMock = mUserMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*UserMockGetUserParams{}

	m.SaveUserParamMock = mUserMockSaveUserParam{mock: m}
	m.SaveUserParamMock.callArgs = []*UserMockSaveUserParamParams{}

	m.UpdateUserFromCacheMock = mUserMockUpdateUserFromCache{mock: m}
	m.UpdateUserFromCacheMock.callArgs = []*UserMockUpdateUserFromCacheParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserMockCreateUser struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockCreateUserExpectation
	expectations       []*UserMockCreateUserExpectation

	callArgs []*UserMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockCreateUserExpectation specifies expectation struct of the User.CreateUser
type UserMockCreateUserExpectation struct {
	mock               *UserMock
	params             *UserMockCreateUserParams
	paramPtrs          *UserMockCreateUserParamPtrs
	expectationOrigins UserMockCreateUserExpectationOrigins
	results            *UserMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserMockCreateUserParams contains parameters of the User.CreateUser
type UserMockCreateUserParams struct {
	ctx  context.Context
	user model.User
}

// UserMockCreateUserParamPtrs contains pointers to parameters of the User.CreateUser
type UserMockCreateUserParamPtrs struct {
	ctx  *context.Context
	user *model.User
}

// UserMockCreateUserResults contains results of the User.CreateUser
type UserMockCreateUserResults struct {
	i1  int64
	err error
}

// UserMockCreateUserOrigins contains origins of expectations of the User.CreateUser
type UserMockCreateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserMockCreateUser) Optional() *mUserMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for User.CreateUser
func (mmCreateUser *mUserMockCreateUser) Expect(ctx context.Context, user model.User) *mUserMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &UserMockCreateUserParams{ctx, user}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for User.CreateUser
func (mmCreateUser *mUserMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectUserParam2 sets up expected param user for User.CreateUser
func (mmCreateUser *mUserMockCreateUser) ExpectUserParam2(user model.User) *mUserMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user
	mmCreateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the User.CreateUser
func (mmCreateUser *mUserMockCreateUser) Inspect(f func(ctx context.Context, user model.User)) *mUserMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by User.CreateUser
func (mmCreateUser *mUserMockCreateUser) Return(i1 int64, err error) *UserMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserMockCreateUserResults{i1, err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the User.CreateUser method
func (mmCreateUser *mUserMockCreateUser) Set(f func(ctx context.Context, user model.User) (i1 int64, err error)) *UserMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the User.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the User.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the User.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserMockCreateUser) When(ctx context.Context, user model.User) *UserMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserMock.CreateUser mock is already set by Set")
	}

	expectation := &UserMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &UserMockCreateUserParams{ctx, user},
		expectationOrigins: UserMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up User.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserMockCreateUserExpectation) Then(i1 int64, err error) *UserMock {
	e.results = &UserMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times User.CreateUser should be invoked
func (mmCreateUser *mUserMockCreateUser) Times(n uint64) *mUserMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of UserMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mUserMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_service.User
func (mmCreateUser *UserMock) CreateUser(ctx context.Context, user model.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, user)
	}

	mm_params := UserMockCreateUserParams{ctx, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := UserMockCreateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("UserMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("UserMock.CreateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UserMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserMock.CreateUser. %v %v", ctx, user)
	return
}

// CreateUserAfterCounter returns a count of finished UserMock.CreateUser invocations
func (mmCreateUser *UserMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserMock.CreateUser invocations
func (mmCreateUser *UserMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserMockCreateUser) Calls() []*UserMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to UserMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mUserMockGetUser struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockGetUserExpectation
	expectations       []*UserMockGetUserExpectation

	callArgs []*UserMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockGetUserExpectation specifies expectation struct of the User.GetUser
type UserMockGetUserExpectation struct {
	mock               *UserMock
	params             *UserMockGetUserParams
	paramPtrs          *UserMockGetUserParamPtrs
	expectationOrigins UserMockGetUserExpectationOrigins
	results            *UserMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// UserMockGetUserParams contains parameters of the User.GetUser
type UserMockGetUserParams struct {
	ctx    context.Context
	userID int64
}

// UserMockGetUserParamPtrs contains pointers to parameters of the User.GetUser
type UserMockGetUserParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// UserMockGetUserResults contains results of the User.GetUser
type UserMockGetUserResults struct {
	up1 *model.User
	err error
}

// UserMockGetUserOrigins contains origins of expectations of the User.GetUser
type UserMockGetUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mUserMockGetUser) Optional() *mUserMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for User.GetUser
func (mmGetUser *mUserMockGetUser) Expect(ctx context.Context, userID int64) *mUserMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &UserMockGetUserParams{ctx, userID}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for User.GetUser
func (mmGetUser *mUserMockGetUser) ExpectCtxParam1(ctx context.Context) *mUserMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectUserIDParam2 sets up expected param userID for User.GetUser
func (mmGetUser *mUserMockGetUser) ExpectUserIDParam2(userID int64) *mUserMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.userID = &userID
	mmGetUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the User.GetUser
func (mmGetUser *mUserMockGetUser) Inspect(f func(ctx context.Context, userID int64)) *mUserMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for UserMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by User.GetUser
func (mmGetUser *mUserMockGetUser) Return(up1 *model.User, err error) *UserMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &UserMockGetUserResults{up1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the User.GetUser method
func (mmGetUser *mUserMockGetUser) Set(f func(ctx context.Context, userID int64) (up1 *model.User, err error)) *UserMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the User.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the User.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the User.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mUserMockGetUser) When(ctx context.Context, userID int64) *UserMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserMock.GetUser mock is already set by Set")
	}

	expectation := &UserMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &UserMockGetUserParams{ctx, userID},
		expectationOrigins: UserMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up User.GetUser return parameters for the expectation previously defined by the When method
func (e *UserMockGetUserExpectation) Then(up1 *model.User, err error) *UserMock {
	e.results = &UserMockGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times User.GetUser should be invoked
func (mmGetUser *mUserMockGetUser) Times(n uint64) *mUserMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of UserMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mUserMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_service.User
func (mmGetUser *UserMock) GetUser(ctx context.Context, userID int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, userID)
	}

	mm_params := UserMockGetUserParams{ctx, userID}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := UserMockGetUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("UserMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUser.t.Errorf("UserMock.GetUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("UserMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the UserMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, userID)
	}
	mmGetUser.t.Fatalf("Unexpected call to UserMock.GetUser. %v %v", ctx, userID)
	return
}

// GetUserAfterCounter returns a count of finished UserMock.GetUser invocations
func (mmGetUser *UserMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of UserMock.GetUser invocations
func (mmGetUser *UserMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to UserMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mUserMockGetUser) Calls() []*UserMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*UserMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *UserMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to UserMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mUserMockSaveUserParam struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockSaveUserParamExpectation
	expectations       []*UserMockSaveUserParamExpectation

	callArgs []*UserMockSaveUserParamParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockSaveUserParamExpectation specifies expectation struct of the User.SaveUserParam
type UserMockSaveUserParamExpectation struct {
	mock               *UserMock
	params             *UserMockSaveUserParamParams
	paramPtrs          *UserMockSaveUserParamParamPtrs
	expectationOrigins UserMockSaveUserParamExpectationOrigins
	results            *UserMockSaveUserParamResults
	returnOrigin       string
	Counter            uint64
}

// UserMockSaveUserParamParams contains parameters of the User.SaveUserParam
type UserMockSaveUserParamParams struct {
	ctx    context.Context
	userID int64
	field  string
	value  interface{}
}

// UserMockSaveUserParamParamPtrs contains pointers to parameters of the User.SaveUserParam
type UserMockSaveUserParamParamPtrs struct {
	ctx    *context.Context
	userID *int64
	field  *string
	value  *interface{}
}

// UserMockSaveUserParamResults contains results of the User.SaveUserParam
type UserMockSaveUserParamResults struct {
	err error
}

// UserMockSaveUserParamOrigins contains origins of expectations of the User.SaveUserParam
type UserMockSaveUserParamExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originField  string
	originValue  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveUserParam *mUserMockSaveUserParam) Optional() *mUserMockSaveUserParam {
	mmSaveUserParam.optional = true
	return mmSaveUserParam
}

// Expect sets up expected params for User.SaveUserParam
func (mmSaveUserParam *mUserMockSaveUserParam) Expect(ctx context.Context, userID int64, field string, value interface{}) *mUserMockSaveUserParam {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserMock.SaveUserParam mock is already set by Set")
	}

	if mmSaveUserParam.defaultExpectation == nil {
		mmSaveUserParam.defaultExpectation = &UserMockSaveUserParamExpectation{}
	}

	if mmSaveUserParam.defaultExpectation.paramPtrs != nil {
		mmSaveUserParam.mock.t.Fatalf("UserMock.SaveUserParam mock is already set by ExpectParams functions")
	}

	mmSaveUserParam.defaultExpectation.params = &UserMockSaveUserParamParams{ctx, userID, field, value}
	mmSaveUserParam.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveUserParam.expectations {
		if minimock.Equal(e.params, mmSaveUserParam.defaultExpectation.params) {
			mmSaveUserParam.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveUserParam.defaultExpectation.params)
		}
	}

	return mmSaveUserParam
}

// ExpectCtxParam1 sets up expected param ctx for User.SaveUserParam
func (mmSaveUserParam *mUserMockSaveUserParam) ExpectCtxParam1(ctx context.Context) *mUserMockSaveUserParam {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserMock.SaveUserParam mock is already set by Set")
	}

	if mmSaveUserParam.defaultExpectation == nil {
		mmSaveUserParam.defaultExpectation = &UserMockSaveUserParamExpectation{}
	}

	if mmSaveUserParam.defaultExpectation.params != nil {
		mmSaveUserParam.mock.t.Fatalf("UserMock.SaveUserParam mock is already set by Expect")
	}

	if mmSaveUserParam.defaultExpectation.paramPtrs == nil {
		mmSaveUserParam.defaultExpectation.paramPtrs = &UserMockSaveUserParamParamPtrs{}
	}
	mmSaveUserParam.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveUserParam.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveUserParam
}

// ExpectUserIDParam2 sets up expected param userID for User.SaveUserParam
func (mmSaveUserParam *mUserMockSaveUserParam) ExpectUserIDParam2(userID int64) *mUserMockSaveUserParam {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserMock.SaveUserParam mock is already set by Set")
	}

	if mmSaveUserParam.defaultExpectation == nil {
		mmSaveUserParam.defaultExpectation = &UserMockSaveUserParamExpectation{}
	}

	if mmSaveUserParam.defaultExpectation.params != nil {
		mmSaveUserParam.mock.t.Fatalf("UserMock.SaveUserParam mock is already set by Expect")
	}

	if mmSaveUserParam.defaultExpectation.paramPtrs == nil {
		mmSaveUserParam.defaultExpectation.paramPtrs = &UserMockSaveUserParamParamPtrs{}
	}
	mmSaveUserParam.defaultExpectation.paramPtrs.userID = &userID
	mmSaveUserParam.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmSaveUserParam
}

// ExpectFieldParam3 sets up expected param field for User.SaveUserParam
func (mmSaveUserParam *mUserMockSaveUserParam) ExpectFieldParam3(field string) *mUserMockSaveUserParam {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserMock.SaveUserParam mock is already set by Set")
	}

	if mmSaveUserParam.defaultExpectation == nil {
		mmSaveUserParam.defaultExpectation = &UserMockSaveUserParamExpectation{}
	}

	if mmSaveUserParam.defaultExpectation.params != nil {
		mmSaveUserParam.mock.t.Fatalf("UserMock.SaveUserParam mock is already set by Expect")
	}

	if mmSaveUserParam.defaultExpectation.paramPtrs == nil {
		mmSaveUserParam.defaultExpectation.paramPtrs = &UserMockSaveUserParamParamPtrs{}
	}
	mmSaveUserParam.defaultExpectation.paramPtrs.field = &field
	mmSaveUserParam.defaultExpectation.expectationOrigins.originField = minimock.CallerInfo(1)

	return mmSaveUserParam
}

// ExpectValueParam4 sets up expected param value for User.SaveUserParam
func (mmSaveUserParam *mUserMockSaveUserParam) ExpectValueParam4(value interface{}) *mUserMockSaveUserParam {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserMock.SaveUserParam mock is already set by Set")
	}

	if mmSaveUserParam.defaultExpectation == nil {
		mmSaveUserParam.defaultExpectation = &UserMockSaveUserParamExpectation{}
	}

	if mmSaveUserParam.defaultExpectation.params != nil {
		mmSaveUserParam.mock.t.Fatalf("UserMock.SaveUserParam mock is already set by Expect")
	}

	if mmSaveUserParam.defaultExpectation.paramPtrs == nil {
		mmSaveUserParam.defaultExpectation.paramPtrs = &UserMockSaveUserParamParamPtrs{}
	}
	mmSaveUserParam.defaultExpectation.paramPtrs.value = &value
	mmSaveUserParam.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSaveUserParam
}

// Inspect accepts an inspector function that has same arguments as the User.SaveUserParam
func (mmSaveUserParam *mUserMockSaveUserParam) Inspect(f func(ctx context.Context, userID int64, field string, value interface{})) *mUserMockSaveUserParam {
	if mmSaveUserParam.mock.inspectFuncSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("Inspect function is already set for UserMock.SaveUserParam")
	}

	mmSaveUserParam.mock.inspectFuncSaveUserParam = f

	return mmSaveUserParam
}

// Return sets up results that will be returned by User.SaveUserParam
func (mmSaveUserParam *mUserMockSaveUserParam) Return(err error) *UserMock {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserMock.SaveUserParam mock is already set by Set")
	}

	if mmSaveUserParam.defaultExpectation == nil {
		mmSaveUserParam.defaultExpectation = &UserMockSaveUserParamExpectation{mock: mmSaveUserParam.mock}
	}
	mmSaveUserParam.defaultExpectation.results = &UserMockSaveUserParamResults{err}
	mmSaveUserParam.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveUserParam.mock
}

// Set uses given function f to mock the User.SaveUserParam method
func (mmSaveUserParam *mUserMockSaveUserParam) Set(f func(ctx context.Context, userID int64, field string, value interface{}) (err error)) *UserMock {
	if mmSaveUserParam.defaultExpectation != nil {
		mmSaveUserParam.mock.t.Fatalf("Default expectation is already set for the User.SaveUserParam method")
	}

	if len(mmSaveUserParam.expectations) > 0 {
		mmSaveUserParam.mock.t.Fatalf("Some expectations are already set for the User.SaveUserParam method")
	}

	mmSaveUserParam.mock.funcSaveUserParam = f
	mmSaveUserParam.mock.funcSaveUserParamOrigin = minimock.CallerInfo(1)
	return mmSaveUserParam.mock
}

// When sets expectation for the User.SaveUserParam which will trigger the result defined by the following
// Then helper
func (mmSaveUserParam *mUserMockSaveUserParam) When(ctx context.Context, userID int64, field string, value interface{}) *UserMockSaveUserParamExpectation {
	if mmSaveUserParam.mock.funcSaveUserParam != nil {
		mmSaveUserParam.mock.t.Fatalf("UserMock.SaveUserParam mock is already set by Set")
	}

	expectation := &UserMockSaveUserParamExpectation{
		mock:               mmSaveUserParam.mock,
		params:             &UserMockSaveUserParamParams{ctx, userID, field, value},
		expectationOrigins: UserMockSaveUserParamExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveUserParam.expectations = append(mmSaveUserParam.expectations, expectation)
	return expectation
}

// Then sets up User.SaveUserParam return parameters for the expectation previously defined by the When method
func (e *UserMockSaveUserParamExpectation) Then(err error) *UserMock {
	e.results = &UserMockSaveUserParamResults{err}
	return e.mock
}

// Times sets number of times User.SaveUserParam should be invoked
func (mmSaveUserParam *mUserMockSaveUserParam) Times(n uint64) *mUserMockSaveUserParam {
	if n == 0 {
		mmSaveUserParam.mock.t.Fatalf("Times of UserMock.SaveUserParam mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveUserParam.expectedInvocations, n)
	mmSaveUserParam.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveUserParam
}

func (mmSaveUserParam *mUserMockSaveUserParam) invocationsDone() bool {
	if len(mmSaveUserParam.expectations) == 0 && mmSaveUserParam.defaultExpectation == nil && mmSaveUserParam.mock.funcSaveUserParam == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveUserParam.mock.afterSaveUserParamCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveUserParam.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveUserParam implements mm_service.User
func (mmSaveUserParam *UserMock) SaveUserParam(ctx context.Context, userID int64, field string, value interface{}) (err error) {
	mm_atomic.AddUint64(&mmSaveUserParam.beforeSaveUserParamCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveUserParam.afterSaveUserParamCounter, 1)

	mmSaveUserParam.t.Helper()

	if mmSaveUserParam.inspectFuncSaveUserParam != nil {
		mmSaveUserParam.inspectFuncSaveUserParam(ctx, userID, field, value)
	}

	mm_params := UserMockSaveUserParamParams{ctx, userID, field, value}

	// Record call args
	mmSaveUserParam.SaveUserParamMock.mutex.Lock()
	mmSaveUserParam.SaveUserParamMock.callArgs = append(mmSaveUserParam.SaveUserParamMock.callArgs, &mm_params)
	mmSaveUserParam.SaveUserParamMock.mutex.Unlock()

	for _, e := range mmSaveUserParam.SaveUserParamMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveUserParam.SaveUserParamMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveUserParam.SaveUserParamMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveUserParam.SaveUserParamMock.defaultExpectation.params
		mm_want_ptrs := mmSaveUserParam.SaveUserParamMock.defaultExpectation.paramPtrs

		mm_got := UserMockSaveUserParamParams{ctx, userID, field, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveUserParam.t.Errorf("UserMock.SaveUserParam got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveUserParam.SaveUserParamMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmSaveUserParam.t.Errorf("UserMock.SaveUserParam got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveUserParam.SaveUserParamMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.field != nil && !minimock.Equal(*mm_want_ptrs.field, mm_got.field) {
				mmSaveUserParam.t.Errorf("UserMock.SaveUserParam got unexpected parameter field, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveUserParam.SaveUserParamMock.defaultExpectation.expectationOrigins.originField, *mm_want_ptrs.field, mm_got.field, minimock.Diff(*mm_want_ptrs.field, mm_got.field))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSaveUserParam.t.Errorf("UserMock.SaveUserParam got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveUserParam.SaveUserParamMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveUserParam.t.Errorf("UserMock.SaveUserParam got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveUserParam.SaveUserParamMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveUserParam.SaveUserParamMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveUserParam.t.Fatal("No results are set for the UserMock.SaveUserParam")
		}
		return (*mm_results).err
	}
	if mmSaveUserParam.funcSaveUserParam != nil {
		return mmSaveUserParam.funcSaveUserParam(ctx, userID, field, value)
	}
	mmSaveUserParam.t.Fatalf("Unexpected call to UserMock.SaveUserParam. %v %v %v %v", ctx, userID, field, value)
	return
}

// SaveUserParamAfterCounter returns a count of finished UserMock.SaveUserParam invocations
func (mmSaveUserParam *UserMock) SaveUserParamAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUserParam.afterSaveUserParamCounter)
}

// SaveUserParamBeforeCounter returns a count of UserMock.SaveUserParam invocations
func (mmSaveUserParam *UserMock) SaveUserParamBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUserParam.beforeSaveUserParamCounter)
}

// Calls returns a list of arguments used in each call to UserMock.SaveUserParam.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveUserParam *mUserMockSaveUserParam) Calls() []*UserMockSaveUserParamParams {
	mmSaveUserParam.mutex.RLock()

	argCopy := make([]*UserMockSaveUserParamParams, len(mmSaveUserParam.callArgs))
	copy(argCopy, mmSaveUserParam.callArgs)

	mmSaveUserParam.mutex.RUnlock()

	return argCopy
}

// MinimockSaveUserParamDone returns true if the count of the SaveUserParam invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockSaveUserParamDone() bool {
	if m.SaveUserParamMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveUserParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveUserParamMock.invocationsDone()
}

// MinimockSaveUserParamInspect logs each unmet expectation
func (m *UserMock) MinimockSaveUserParamInspect() {
	for _, e := range m.SaveUserParamMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.SaveUserParam at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveUserParamCounter := mm_atomic.LoadUint64(&m.afterSaveUserParamCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserParamMock.defaultExpectation != nil && afterSaveUserParamCounter < 1 {
		if m.SaveUserParamMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.SaveUserParam at\n%s", m.SaveUserParamMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.SaveUserParam at\n%s with params: %#v", m.SaveUserParamMock.defaultExpectation.expectationOrigins.origin, *m.SaveUserParamMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUserParam != nil && afterSaveUserParamCounter < 1 {
		m.t.Errorf("Expected call to UserMock.SaveUserParam at\n%s", m.funcSaveUserParamOrigin)
	}

	if !m.SaveUserParamMock.invocationsDone() && afterSaveUserParamCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.SaveUserParam at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveUserParamMock.expectedInvocations), m.SaveUserParamMock.expectedInvocationsOrigin, afterSaveUserParamCounter)
	}
}

type mUserMockUpdateUserFromCache struct {
	optional           bool
	mock               *UserMock
	defaultExpectation *UserMockUpdateUserFromCacheExpectation
	expectations       []*UserMockUpdateUserFromCacheExpectation

	callArgs []*UserMockUpdateUserFromCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserMockUpdateUserFromCacheExpectation specifies expectation struct of the User.UpdateUserFromCache
type UserMockUpdateUserFromCacheExpectation struct {
	mock               *UserMock
	params             *UserMockUpdateUserFromCacheParams
	paramPtrs          *UserMockUpdateUserFromCacheParamPtrs
	expectationOrigins UserMockUpdateUserFromCacheExpectationOrigins
	results            *UserMockUpdateUserFromCacheResults
	returnOrigin       string
	Counter            uint64
}

// UserMockUpdateUserFromCacheParams contains parameters of the User.UpdateUserFromCache
type UserMockUpdateUserFromCacheParams struct {
	ctx    context.Context
	userID int64
}

// UserMockUpdateUserFromCacheParamPtrs contains pointers to parameters of the User.UpdateUserFromCache
type UserMockUpdateUserFromCacheParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// UserMockUpdateUserFromCacheResults contains results of the User.UpdateUserFromCache
type UserMockUpdateUserFromCacheResults struct {
	err error
}

// UserMockUpdateUserFromCacheOrigins contains origins of expectations of the User.UpdateUserFromCache
type UserMockUpdateUserFromCacheExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUserFromCache *mUserMockUpdateUserFromCache) Optional() *mUserMockUpdateUserFromCache {
	mmUpdateUserFromCache.optional = true
	return mmUpdateUserFromCache
}

// Expect sets up expected params for User.UpdateUserFromCache
func (mmUpdateUserFromCache *mUserMockUpdateUserFromCache) Expect(ctx context.Context, userID int64) *mUserMockUpdateUserFromCache {
	if mmUpdateUserFromCache.mock.funcUpdateUserFromCache != nil {
		mmUpdateUserFromCache.mock.t.Fatalf("UserMock.UpdateUserFromCache mock is already set by Set")
	}

	if mmUpdateUserFromCache.defaultExpectation == nil {
		mmUpdateUserFromCache.defaultExpectation = &UserMockUpdateUserFromCacheExpectation{}
	}

	if mmUpdateUserFromCache.defaultExpectation.paramPtrs != nil {
		mmUpdateUserFromCache.mock.t.Fatalf("UserMock.UpdateUserFromCache mock is already set by ExpectParams functions")
	}

	mmUpdateUserFromCache.defaultExpectation.params = &UserMockUpdateUserFromCacheParams{ctx, userID}
	mmUpdateUserFromCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUserFromCache.expectations {
		if minimock.Equal(e.params, mmUpdateUserFromCache.defaultExpectation.params) {
			mmUpdateUserFromCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUserFromCache.defaultExpectation.params)
		}
	}

	return mmUpdateUserFromCache
}

// ExpectCtxParam1 sets up expected param ctx for User.UpdateUserFromCache
func (mmUpdateUserFromCache *mUserMockUpdateUserFromCache) ExpectCtxParam1(ctx context.Context) *mUserMockUpdateUserFromCache {
	if mmUpdateUserFromCache.mock.funcUpdateUserFromCache != nil {
		mmUpdateUserFromCache.mock.t.Fatalf("UserMock.UpdateUserFromCache mock is already set by Set")
	}

	if mmUpdateUserFromCache.defaultExpectation == nil {
		mmUpdateUserFromCache.defaultExpectation = &UserMockUpdateUserFromCacheExpectation{}
	}

	if mmUpdateUserFromCache.defaultExpectation.params != nil {
		mmUpdateUserFromCache.mock.t.Fatalf("UserMock.UpdateUserFromCache mock is already set by Expect")
	}

	if mmUpdateUserFromCache.defaultExpectation.paramPtrs == nil {
		mmUpdateUserFromCache.defaultExpectation.paramPtrs = &UserMockUpdateUserFromCacheParamPtrs{}
	}
	mmUpdateUserFromCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUserFromCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUserFromCache
}

// ExpectUserIDParam2 sets up expected param userID for User.UpdateUserFromCache
func (mmUpdateUserFromCache *mUserMockUpdateUserFromCache) ExpectUserIDParam2(userID int64) *mUserMockUpdateUserFromCache {
	if mmUpdateUserFromCache.mock.funcUpdateUserFromCache != nil {
		mmUpdateUserFromCache.mock.t.Fatalf("UserMock.UpdateUserFromCache mock is already set by Set")
	}

	if mmUpdateUserFromCache.defaultExpectation == nil {
		mmUpdateUserFromCache.defaultExpectation = &UserMockUpdateUserFromCacheExpectation{}
	}

	if mmUpdateUserFromCache.defaultExpectation.params != nil {
		mmUpdateUserFromCache.mock.t.Fatalf("UserMock.UpdateUserFromCache mock is already set by Expect")
	}

	if mmUpdateUserFromCache.defaultExpectation.paramPtrs == nil {
		mmUpdateUserFromCache.defaultExpectation.paramPtrs = &UserMockUpdateUserFromCacheParamPtrs{}
	}
	mmUpdateUserFromCache.defaultExpectation.paramPtrs.userID = &userID
	mmUpdateUserFromCache.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUpdateUserFromCache
}

// Inspect accepts an inspector function that has same arguments as the User.UpdateUserFromCache
func (mmUpdateUserFromCache *mUserMockUpdateUserFromCache) Inspect(f func(ctx context.Context, userID int64)) *mUserMockUpdateUserFromCache {
	if mmUpdateUserFromCache.mock.inspectFuncUpdateUserFromCache != nil {
		mmUpdateUserFromCache.mock.t.Fatalf("Inspect function is already set for UserMock.UpdateUserFromCache")
	}

	mmUpdateUserFromCache.mock.inspectFuncUpdateUserFromCache = f

	return mmUpdateUserFromCache
}

// Return sets up results that will be returned by User.UpdateUserFromCache
func (mmUpdateUserFromCache *mUserMockUpdateUserFromCache) Return(err error) *UserMock {
	if mmUpdateUserFromCache.mock.funcUpdateUserFromCache != nil {
		mmUpdateUserFromCache.mock.t.Fatalf("UserMock.UpdateUserFromCache mock is already set by Set")
	}

	if mmUpdateUserFromCache.defaultExpectation == nil {
		mmUpdateUserFromCache.defaultExpectation = &UserMockUpdateUserFromCacheExpectation{mock: mmUpdateUserFromCache.mock}
	}
	mmUpdateUserFromCache.defaultExpectation.results = &UserMockUpdateUserFromCacheResults{err}
	mmUpdateUserFromCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUserFromCache.mock
}

// Set uses given function f to mock the User.UpdateUserFromCache method
func (mmUpdateUserFromCache *mUserMockUpdateUserFromCache) Set(f func(ctx context.Context, userID int64) (err error)) *UserMock {
	if mmUpdateUserFromCache.defaultExpectation != nil {
		mmUpdateUserFromCache.mock.t.Fatalf("Default expectation is already set for the User.UpdateUserFromCache method")
	}

	if len(mmUpdateUserFromCache.expectations) > 0 {
		mmUpdateUserFromCache.mock.t.Fatalf("Some expectations are already set for the User.UpdateUserFromCache method")
	}

	mmUpdateUserFromCache.mock.funcUpdateUserFromCache = f
	mmUpdateUserFromCache.mock.funcUpdateUserFromCacheOrigin = minimock.CallerInfo(1)
	return mmUpdateUserFromCache.mock
}

// When sets expectation for the User.UpdateUserFromCache which will trigger the result defined by the following
// Then helper
func (mmUpdateUserFromCache *mUserMockUpdateUserFromCache) When(ctx context.Context, userID int64) *UserMockUpdateUserFromCacheExpectation {
	if mmUpdateUserFromCache.mock.funcUpdateUserFromCache != nil {
		mmUpdateUserFromCache.mock.t.Fatalf("UserMock.UpdateUserFromCache mock is already set by Set")
	}

	expectation := &UserMockUpdateUserFromCacheExpectation{
		mock:               mmUpdateUserFromCache.mock,
		params:             &UserMockUpdateUserFromCacheParams{ctx, userID},
		expectationOrigins: UserMockUpdateUserFromCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUserFromCache.expectations = append(mmUpdateUserFromCache.expectations, expectation)
	return expectation
}

// Then sets up User.UpdateUserFromCache return parameters for the expectation previously defined by the When method
func (e *UserMockUpdateUserFromCacheExpectation) Then(err error) *UserMock {
	e.results = &UserMockUpdateUserFromCacheResults{err}
	return e.mock
}

// Times sets number of times User.UpdateUserFromCache should be invoked
func (mmUpdateUserFromCache *mUserMockUpdateUserFromCache) Times(n uint64) *mUserMockUpdateUserFromCache {
	if n == 0 {
		mmUpdateUserFromCache.mock.t.Fatalf("Times of UserMock.UpdateUserFromCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUserFromCache.expectedInvocations, n)
	mmUpdateUserFromCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUserFromCache
}

func (mmUpdateUserFromCache *mUserMockUpdateUserFromCache) invocationsDone() bool {
	if len(mmUpdateUserFromCache.expectations) == 0 && mmUpdateUserFromCache.defaultExpectation == nil && mmUpdateUserFromCache.mock.funcUpdateUserFromCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUserFromCache.mock.afterUpdateUserFromCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUserFromCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUserFromCache implements mm_service.User
func (mmUpdateUserFromCache *UserMock) UpdateUserFromCache(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmUpdateUserFromCache.beforeUpdateUserFromCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUserFromCache.afterUpdateUserFromCacheCounter, 1)

	mmUpdateUserFromCache.t.Helper()

	if mmUpdateUserFromCache.inspectFuncUpdateUserFromCache != nil {
		mmUpdateUserFromCache.inspectFuncUpdateUserFromCache(ctx, userID)
	}

	mm_params := UserMockUpdateUserFromCacheParams{ctx, userID}

	// Record call args
	mmUpdateUserFromCache.UpdateUserFromCacheMock.mutex.Lock()
	mmUpdateUserFromCache.UpdateUserFromCacheMock.callArgs = append(mmUpdateUserFromCache.UpdateUserFromCacheMock.callArgs, &mm_params)
	mmUpdateUserFromCache.UpdateUserFromCacheMock.mutex.Unlock()

	for _, e := range mmUpdateUserFromCache.UpdateUserFromCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUserFromCache.UpdateUserFromCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUserFromCache.UpdateUserFromCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUserFromCache.UpdateUserFromCacheMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUserFromCache.UpdateUserFromCacheMock.defaultExpectation.paramPtrs

		mm_got := UserMockUpdateUserFromCacheParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUserFromCache.t.Errorf("UserMock.UpdateUserFromCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserFromCache.UpdateUserFromCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUpdateUserFromCache.t.Errorf("UserMock.UpdateUserFromCache got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserFromCache.UpdateUserFromCacheMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUserFromCache.t.Errorf("UserMock.UpdateUserFromCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUserFromCache.UpdateUserFromCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUserFromCache.UpdateUserFromCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUserFromCache.t.Fatal("No results are set for the UserMock.UpdateUserFromCache")
		}
		return (*mm_results).err
	}
	if mmUpdateUserFromCache.funcUpdateUserFromCache != nil {
		return mmUpdateUserFromCache.funcUpdateUserFromCache(ctx, userID)
	}
	mmUpdateUserFromCache.t.Fatalf("Unexpected call to UserMock.UpdateUserFromCache. %v %v", ctx, userID)
	return
}

// UpdateUserFromCacheAfterCounter returns a count of finished UserMock.UpdateUserFromCache invocations
func (mmUpdateUserFromCache *UserMock) UpdateUserFromCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserFromCache.afterUpdateUserFromCacheCounter)
}

// UpdateUserFromCacheBeforeCounter returns a count of UserMock.UpdateUserFromCache invocations
func (mmUpdateUserFromCache *UserMock) UpdateUserFromCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserFromCache.beforeUpdateUserFromCacheCounter)
}

// Calls returns a list of arguments used in each call to UserMock.UpdateUserFromCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUserFromCache *mUserMockUpdateUserFromCache) Calls() []*UserMockUpdateUserFromCacheParams {
	mmUpdateUserFromCache.mutex.RLock()

	argCopy := make([]*UserMockUpdateUserFromCacheParams, len(mmUpdateUserFromCache.callArgs))
	copy(argCopy, mmUpdateUserFromCache.callArgs)

	mmUpdateUserFromCache.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserFromCacheDone returns true if the count of the UpdateUserFromCache invocations corresponds
// the number of defined expectations
func (m *UserMock) MinimockUpdateUserFromCacheDone() bool {
	if m.UpdateUserFromCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserFromCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserFromCacheMock.invocationsDone()
}

// MinimockUpdateUserFromCacheInspect logs each unmet expectation
func (m *UserMock) MinimockUpdateUserFromCacheInspect() {
	for _, e := range m.UpdateUserFromCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserMock.UpdateUserFromCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserFromCacheCounter := mm_atomic.LoadUint64(&m.afterUpdateUserFromCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserFromCacheMock.defaultExpectation != nil && afterUpdateUserFromCacheCounter < 1 {
		if m.UpdateUserFromCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserMock.UpdateUserFromCache at\n%s", m.UpdateUserFromCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserMock.UpdateUserFromCache at\n%s with params: %#v", m.UpdateUserFromCacheMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserFromCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUserFromCache != nil && afterUpdateUserFromCacheCounter < 1 {
		m.t.Errorf("Expected call to UserMock.UpdateUserFromCache at\n%s", m.funcUpdateUserFromCacheOrigin)
	}

	if !m.UpdateUserFromCacheMock.invocationsDone() && afterUpdateUserFromCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to UserMock.UpdateUserFromCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserFromCacheMock.expectedInvocations), m.UpdateUserFromCacheMock.expectedInvocationsOrigin, afterUpdateUserFromCacheCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockGetUserInspect()

			m.MinimockSaveUserParamInspect()

			m.MinimockUpdateUserFromCacheInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockSaveUserParamDone() &&
		m.MinimockUpdateUserFromCacheDone()
}
